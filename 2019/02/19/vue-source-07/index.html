<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vue源码解读 07 - 组件 patch · choteewang</title><meta name="description" content="Vue源码解读 07 - 组件 patch - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vue源码解读 07 - 组件 patch</h1><div class="post-info">2019年2月19日</div><div class="post-content"><p>上节分析了在<code>vm._render()</code>内部运行<code>createElement</code>生成组件<code>vnode</code>的过程. <code>vm._update(vm._render())</code>会将<code>vnode</code>挂载到页面上. 这节分析其中的过程.</p>
<p>在分析前, 先明确几个概念, 方便分析, 假设有下面一段<code>vue</code>代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>;</span><br><span class="line">  render: <span class="function"><span class="params">createElement</span> =&gt;</span> createElement(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这时我们定义:</p>
<ol>
<li><strong>占位vnode</strong>: <code>App</code>标签的<code>vnode</code>叫做<strong>占位vnode</strong></li>
<li><strong>渲染vnode</strong>: <code>App</code>组件的<code>template</code>或<code>render</code>方法返回的最外层标签的<code>vnode</code>叫做<strong>渲染vnode</strong></li>
<li><strong>父实例</strong>: <code>father</code>是一个<code>vm</code>实例, 它是相对于<code>App</code>组件实例的<strong>父实例</strong></li>
</ol>
<p>前面分析过, <code>vm._update</code>内部会调用<code>patch</code>方法, <code>patch</code>会递归调用<code>createElm</code>方法将<code>vnode</code>挂载为真实<code>dom</code>, 于是要想分析组件<code>vnode</code>挂载过程, 应从<code>createElm</code>入手.</p>
<h3 id="createElm-gt-createComponent"><a href="#createElm-gt-createComponent" class="headerlink" title="createElm -&gt; createComponent"></a>createElm -&gt; createComponent</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  nested,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it's used as an insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="comment">// 组件vnode patch start</span></span><br><span class="line">  <span class="comment">// 这里的vnode是占位vnode, 例如&lt;App /&gt;的vnode</span></span><br><span class="line">  <span class="comment">// createComponent返回一个布尔值, 判断组件的根vnode是不是一个组件, 如果是走createComponent逻辑(包括整个组件树的vm实例的创建, patch过程), 返回true, 不再继续后续逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是vnode, 跟html reserved element逻辑基本类似</span></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="comment">// 首次真实渲染isDef(tag)为true</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Unknown custom element: &lt;'</span> +</span><br><span class="line">            tag +</span><br><span class="line">            <span class="string">'&gt; - did you '</span> +</span><br><span class="line">            <span class="string">'register the component correctly? For recursive components, '</span> +</span><br><span class="line">            <span class="string">'make sure to provide the "name" option.'</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// in Weex, the default insertion order is parent-first.</span></span><br><span class="line">      <span class="comment">// List items can be optimized to use children-first insertion</span></span><br><span class="line">      <span class="comment">// with append="tree".</span></span><br><span class="line">      <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      <span class="keyword">if</span> (!appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// createChildren会递归调用createElm, 所以子节点的dom先被插入(insert()执行), 之后才会插入父</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (appendAsTree) </span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再插入父节点</span></span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建子节点, 递归的调用createElm</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是注释节点, 创建注释节点 </span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 如果是文本节点, 创建文本节点</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先需要对组件树的递归<code>patch</code>有个整体逻辑</p>
<p>首先要明白<code>createElm</code>本身在<code>patch</code>的过程中. <code>createElm</code>在执行过程中, 会进入<code>createComponent</code>逻辑. </p>
<p><code>createComponent</code>内部, 如果<code>vnode</code>是一个组件<code>vnode</code>, <code>createComponent</code>会完成该组件及其下属组件树所有的<code>vm</code>实例创建和<code>patch</code>到页面上的过程, 并在执行完毕后不再继续<code>createElm</code>后续逻辑.</p>
<p><code>createComponent</code>内部逻辑在递归时执行后代组件<code>vnode</code>的<code>patch</code>时, 还会在<code>createElm</code>执行时递归调用<code>createComponent</code>, 一层层递归进去, 直到所有子节点都是<code>html</code>保留节点为止, 再向父节点中插入真实dom, 如此这般, 一层层从子向父插入回去. 所以组件<code>vnode</code>的<code>patch</code>过程, 也是子组件的真实dom先插入父组件, 一层层向上插入的.</p>
<p>下面看看<code>createComponent</code>方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行组件vnode的init钩子, 生成组件渲染vnode对应的vm实例, 并将执行组件的patch过程(patch过程会递归调用createComponent)</span></span><br><span class="line"><span class="comment">// 每层patch结束后将真实dom插入到页面中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="comment">// keep-alive逻辑</span></span><br><span class="line">    <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="comment">// 执行组件vnode的init钩子</span></span><br><span class="line">    <span class="comment">// init方法会代理全部的子vnode, mount -&gt; patch的全过程</span></span><br><span class="line">    <span class="keyword">if</span> (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should've created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode's elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断vnode的根节点是组件, return true, 停止对createElm的执行</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      <span class="comment">// 在这里将vnode.elm赋值为vnode.componentInstance.$el</span></span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 初始化完vnode.elm, 在这里插入真实dom</span></span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createComponent</code>先拿到组件的<code>data</code>属性上的<code>init</code>钩子, 执行<code>init</code>钩子, 创建组件的<code>vm</code>实例, 并执行<code>patch</code>(<code>patch</code>会再次走到<code>createElm</code>递归调用<code>createComponent</code>自身)过程, 在<code>patch</code>过后执行<code>initComponent</code>和<code>insert</code>, 将<code>patch</code>得到<code>dom</code>元素挂载到页面上.</p>
<p>下面看看组件<code>vnode</code>的<code>init</code>钩子实现: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  init (vnode: VNodeWithData, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="comment">// if是keep-alive逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.componentInstance &amp;&amp;</span><br><span class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">      vnode.data.keepAlive</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 返回组件vnode, child是组件vm实例, 且已和父vm(template中包含组件html标签的vm实例)实例绑定了父子关系</span></span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 执行组件vnode mount过程</span></span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code>方法先调用<code>createComponentInstanceForVnode</code>给<code>vnode</code>挂载<code>componentInstance</code>属性, 它是<code>createComponentInstanceForVnode</code>返回的组件的<code>vm</code>实例, 该方法传入了两个参数, 第一个参数<code>vnode</code>是<strong>占位vnode</strong>(<code>&lt;App /&gt;</code>), 第二个参数<code>activeInstance</code>是当前激活的<code>vm</code>实例, 实际是<strong>template或render包裹着该组件标签的vm实例</strong>(<code>new Vue()</code>), 也就是开篇介绍的<strong>父实例</strong>, 下面来具体分析<code>createComponentInstanceForVnode</code>的过程</p>
<h3 id="createComponentInstanceForVnode-生成组件vm-并和父实例形成父子属性关联"><a href="#createComponentInstanceForVnode-生成组件vm-并和父实例形成父子属性关联" class="headerlink" title="createComponentInstanceForVnode: 生成组件vm, 并和父实例形成父子属性关联"></a>createComponentInstanceForVnode: 生成组件vm, 并和父实例形成父子属性关联</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 组件占位vnode, &lt;<span class="regexp">/App&gt;的vnode</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  vnode: any, /</span><span class="regexp">/ we know it's MountedComponentVNode but flow doesn't</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  /</span><span class="regexp">/ vm实例</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  parent: any, /</span><span class="regexp">/ activeInstance in lifecycle state</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">): Component &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  const options: InternalComponentOptions = &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    _isComponent: true,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    /</span><span class="regexp">/ 组件标签vnode,占位符vnode, 比如&lt;App /</span>&gt;的vnode</span></span></span><br><span class="line"><span class="function"><span class="params">    _parentVnode: vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> template中包含组件标签的vm实例, <span class="string">"父"</span>vm实例, 全局存储的activeIndex</span></span></span><br><span class="line"><span class="function"><span class="params">    parent</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> check inline-template render functions</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> inline-template逻辑</span></span></span><br><span class="line"><span class="function"><span class="params">  const inlineTemplate = vnode.data.inlineTemplate</span></span></span><br><span class="line"><span class="function"><span class="params">  if (isDef(inlineTemplate</span>)) </span>&#123;</span><br><span class="line">    options.render = inlineTemplate.render</span><br><span class="line">    options.staticRenderFns = inlineTemplate.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里的Ctor是上节讲的组件的构造函数Sub, 会执行this._init</span></span><br><span class="line">  <span class="comment">// 返回组件vm实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createComponentInstanceForVnode</code>方法组合了一个<code>options</code>, 其中<code>_parentVnode</code>属性指向占位vnode, <code>parent</code>指向父实例.</p>
<p>并将其传给了<code>new vnode.componentOptions.Ctor</code>. 经过上节的分析, 我们知道这个就是组件的<code>Sub</code>类, 它的逻辑在<code>Vue.extend</code>中, 我们来回忆下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/global-api/extend.js</span></span><br><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 因为原型继承过, 所以_init是Vue的方法但是在原型链中可以找到</span></span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承过程</span></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">Sub.prototype.constructor = Sub</span><br></pre></td></tr></table></figure>
<p>所以<code>createComponentInstanceForVnode</code>这个方法最终会返回参数是<code>options</code>的<code>vm</code>实例, 我们跳到<code>sub._init()</code>的过程里:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="comment">// Vue或其子类Sub constructor中的方法</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// a uid</span></span><br><span class="line">  vm._uid = uid++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startTag, endTag</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    mark(startTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">  vm._isVue = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    <span class="comment">// options._isComponent是true, 进入下面的逻辑</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initInternalComponent方法执行完后调用</span></span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在组件Sub类构造函数执行过程中, 下面没有el所以走不到, 返回 createComponentInstanceForVnode 方法</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    vm是Sub类实例,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    const options: InternalComponentOptions = &#123;</span></span><br><span class="line"><span class="comment">      _isComponent: true,</span></span><br><span class="line"><span class="comment">      // 父vnode,组件vnode,占位符vnode</span></span><br><span class="line"><span class="comment">      _parentVnode: vnode,</span></span><br><span class="line"><span class="comment">      // 子组件的父vm实例</span></span><br><span class="line"><span class="comment">      parent</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//  options</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// doing this because it's faster than dynamic enumeration.]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent <span class="comment">// 这个代表组件的父vm实例</span></span><br><span class="line">  opts._parentVnode = parentVnode <span class="comment">// 组件占位vnode &lt;App/&gt;的vnode</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给vm.$options挂载组件vnode上的属性</span></span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = vnodeComponentOptions.tag</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_init</code>方法的执行过程中, 由于<code>options._isComponent</code>是true, 会进入<code>initInternalComponent(vm, options)</code>逻辑.</p>
<p>这个方法会给<code>vm.$options</code>挂载<code>parent</code>属性, 值是父实例, 还会挂载<code>_parentVnode</code>属性, 值是占位vnode, 之后再将<code>vnode.componentOptions</code>上的属性挂载给<code>vm.$options</code>.</p>
<p>继续回到<code>_init</code>方法逻辑, 进入<code>initLifecycle</code>逻辑, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="comment">// parent实际上是activeInstance,当前激活的vm实例(父vm实例)</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前vm实例(父组件实例)的$children会push入子组件的vm</span></span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同时给组件vm实例的$parent指向父vm实例, 如此建立vm之间的父子关系 -&gt;返回init方法</span></span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher = <span class="literal">null</span></span><br><span class="line">  vm._inactive = <span class="literal">null</span></span><br><span class="line">  vm._directInactive = <span class="literal">false</span></span><br><span class="line">  vm._isMounted = <span class="literal">false</span></span><br><span class="line">  vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">  vm._isBeingDestroyed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initLifecycle</code>中, 父实例的<code>$children</code>属性会push入当前组件<code>vm</code>实例, 组件<code>vm</code>实例的<code>$parent</code>会指向父实例, 由此, <strong>父实例和当前<code>vm</code>实例间建立了父子关系</strong></p>
<p>回到<code>_init</code>方法的过程, 最后<code>vm.$mount</code>不会执行(因为<code>vm.$options.el</code>不存在). 至此<code>init_</code>执行完毕, <code>Sub</code>的构造函数执行完毕返回组件<code>vm</code>实例, 再向外, <code>createComponentInstanceForVnode</code>方法也返回了这个<code>vm</code>实例, 组件<code>vnode</code>的<code>init</code>钩子用<code>child</code>变量接收了这个实例, 调用<code>child.$mount(hydrating ? vnode.elm : undefined, hydrating)</code>, 首次调时, <code>vnode.elm</code>是undefined, 进入<code>patch</code>过程</p>
<h3 id="patch过程"><a href="#patch过程" class="headerlink" title="patch过程"></a>patch过程</h3><p><code>patch</code>的过程如同前面的章节讲的, 这里就不详细叙述了. 最终会走到<code>mountComponent</code>方法中, 用渲染<code>watcher</code>的<code>getter</code>调用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js: mountComponent方法内部</span></span><br><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看看啊<code>vm._render</code>的过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"><span class="comment">// 生成vm对应的vnode</span></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  <span class="comment">// 占位vnode赋值给vm.$vnode, &lt;App /&gt;</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// render方法产生vnode并返回, 调用vm.$createElement方法</span></span><br><span class="line">    <span class="comment">// vm._renderProxy在生产环境就是vm, 在开发环境是个proxy对象, 初始化过程在 instance/init.js</span></span><br><span class="line">    <span class="comment">// 可以理解直接点, vm._renderProxy就是vue实例vm本身</span></span><br><span class="line">    <span class="comment">// render.call的返回值就是$createElement的返回值, 就是createElement的返回值, 就是_createElement的返回值</span></span><br><span class="line">    <span class="comment">// 会运行组件的render函数, 生成组件vnode(渲染vnode) &lt;App/&gt;对应的组件模板生成的vnode</span></span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染vnode(App组件的template生成的vnode)的parent指向占位vnode &lt;App /&gt;</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="comment">//返回生成的组件vnode</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_render</code>方法先从<code>vm.$options</code>上获得了<code>_parentVnode</code>(占位vnode), 然后调用组件的<code>render</code>方法生成组件<code>vnode</code>(上一节的内容), 组件<code>vnode</code>返回后, 给<code>parent</code>属性挂载占位vnode, 返回组件vnode给<code>vm._update</code>方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifesycle.js</span></span><br><span class="line"><span class="comment">// vnode -&gt; dom</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="comment">// 全局变量activeInstance赋值, 把当前要进行patch(vnode-&gt;dom)的vm实例赋值给activeInstance, 同时用prevActiveInstance去记录上一个activeInstance, 在patch完成后将记录的上一个activeInstance再赋值回去给actvieInstance变量</span></span><br><span class="line">  <span class="comment">// 这样在子组件再建立子组件的时候, 就可以把activeInstance作为父组件vm传入</span></span><br><span class="line">  <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  <span class="comment">// 把渲染vnode赋值给_vnode</span></span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次渲染preVnode为空</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    <span class="comment">// vm.patch -&gt; platforms/runtime/index.js</span></span><br><span class="line">    <span class="comment">// 执行patch过程, 第一次时vm.$el是undefined, vm.$el会接收patch的返回值</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// else 对应数据改变</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// patch过后, 再将刚才存储的activeInstance复原给activeInstance, 可以继续本层递归</span></span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>activeInstance</code>是一个全局变量, <code>_update</code>方法用<code>prevActiveInstance</code>变量缓存上一层循环<code>activeInstance</code>, 它是上一轮递归的父实例, 之后将本轮循环的组件<code>vm</code>赋值给<code>activeInstance</code>, 继续走<code>patch</code>方法, <code>patch</code>里又会调用<code>createElm</code>和<code>createComponent</code>, 如果再遇到组件的占位vnode时, 就会将本轮递归的<code>activeInstance</code>也就是<code>vm</code>实例作为父实例传入, 以此类推, 一直递归下去.</p>
<p>在<code>patch</code>方法结束后, <code>activeInstance</code>会被恢复为上层递归的<code>prevActiveInstance</code>.</p>
<p>再看<code>patch</code>的过程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  nested,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次渲染走不到</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it's used as an insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="comment">// 组件vnode patch start</span></span><br><span class="line">  <span class="comment">// 这里的vnode是占位vnode, 例如&lt;App /&gt;的vnode</span></span><br><span class="line">  <span class="comment">// reateComponent返回一个布尔值, 判断组件的根vnode是不是一个组件, 如果是走createComponent逻辑, 返回true, renturn</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是vnode, 跟html reserved element逻辑基本类似</span></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="comment">// 首次真实渲染isDef(tag)为true</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Unknown custom element: &lt;'</span> +</span><br><span class="line">            tag +</span><br><span class="line">            <span class="string">'&gt; - did you '</span> +</span><br><span class="line">            <span class="string">'register the component correctly? For recursive components, '</span> +</span><br><span class="line">            <span class="string">'make sure to provide the "name" option.'</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先根据vnode创建一个当前的dom元素标签(用dom原生api)</span></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// in Weex, the default insertion order is parent-first.</span></span><br><span class="line">      <span class="comment">// List items can be optimized to use children-first insertion</span></span><br><span class="line">      <span class="comment">// with append="tree".</span></span><br><span class="line">      <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      <span class="keyword">if</span> (!appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// createChildren会递归调用createElm, 所以子节点的dom先被插入(insert()执行), 之后才会插入父</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再插入父节点</span></span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建子节点, 递归的调用createElm</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向html中插入节点</span></span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是注释节点, 创建注释节点 </span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 如果是文本节点, 创建文本节点</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次挂载时, <code>patch</code>方法的<code>oldVnode</code>参数, 也就是<code>vm.$el</code>是undefined, 故会调用<code>createElm</code>逻辑,<br>如果是组件vnode, 又会进入<code>createComponent</code>逻辑, 回到这篇博客的初始, 形成递归. <code>patch</code>方法最后会返回<code>vnode.elm</code>, 被赋值给<code>vm.$el</code>.<br>如果不是组件vnode, 则会进入之前分析的将<code>html reserved element</code>插入父元素的过程.</p>
<p>组件的插入是在<code>createComponent</code>方法中完成的, 让我们再回到<code>createComponent</code>方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vodom/patch.js: createComponent方法内:</span></span><br><span class="line"><span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">  <span class="comment">// 在这里将vnode.elm赋值为vnode.componentInstance.$el</span></span><br><span class="line">  initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">  <span class="comment">// 初始化完vnode.elm, 在这里插入真实dom</span></span><br><span class="line">  insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComponent</span>(<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.data.pendingInsert)) &#123;</span><br><span class="line">    insertedVnodeQueue.push.apply(</span><br><span class="line">      insertedVnodeQueue,</span><br><span class="line">      vnode.data.pendingInsert</span><br><span class="line">    )</span><br><span class="line">    vnode.data.pendingInsert = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将vnode.componentInstance.$el真实dom元素赋值给vnode.elm</span></span><br><span class="line">  vnode.elm = vnode.componentInstance.$el</span><br><span class="line">  <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">    invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">    setScope(vnode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// empty component root.</span></span><br><span class="line">    <span class="comment">// skip all element-related modules except for ref (#3455)</span></span><br><span class="line">    registerRef(vnode)</span><br><span class="line">    <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line">    insertedVnodeQueue.push(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行完组件vnode的<code>init</code>钩子(代理了整个组件树的vm生成, vnode生成和patch过程)后, 会依次执行<code>initComponent</code>方法和<code>insert</code>方法, 前者给<code>vnode.elm</code>赋值, 后者将<code>vnode.elm</code>插入到父元素中.</p>
<p>至此, 我们分析了组件<code>vnode</code>的<code>patch</code>过程. 整个过程是层层嵌套递归的过程, 直到到内层的根节点上, 所有子元素都是<code>html reserved element</code>, 再层层退出递归, 子节点先插入父元素, 父节点再插入, 依次类推, 最后插入到<code>body</code>中.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/13/vue-source-06/" class="next">上一篇</a><a href="/2019/03/14/vue-source-08/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>