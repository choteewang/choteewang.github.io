<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> two-vuex: 小程序状态管理的研究和实现 · choteewang</title><meta name="description" content="two-vuex: 小程序状态管理的研究和实现 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">two-vuex: 小程序状态管理的研究和实现</h1><div class="post-info">2019年5月6日</div><div class="post-content"><p>一直以来, 小程序组件和页面间传值的方式处于一个比较传统的状态. 小程序的页面间通过 <code>queryString</code> 的方式进行传值, 组件间通过<code>triggerEvent</code> 进行传值. 这些都是比较传统的值传递方式. 在实际业务开发中, 碰到前端场景比较复杂的情况, 这种落后的状态共享方式, 不能满足开发需要, 引入状态管理势在必行.</p>
<p>因为对这方面比较感兴趣, 再加上工作有交集, 我开始了实现小程序状态管理功能的一次尝试.</p>
<h2 id="需求都有什么-？"><a href="#需求都有什么-？" class="headerlink" title="需求都有什么 ？"></a>需求都有什么 ？</h2><p>要给小程序添加状态管理, 要对需求功能点做细致的考量. 网上有很多<code>&quot;demo&quot;</code>, 但因为只是<code>demo</code>, 功能点太少, 无法满足复杂业务开发的需要. 另外, 很多大型的编译框架也给小程序运行时添加了状态管理, 但一般会依赖其他npm库, 也没有针对小程序的特性做处理. </p>
<p>综上, 开发小程序的状态管理, 我考虑有三点必要性:</p>
<ol>
<li>一定要是可独立运行的模块(可以脱离任何框架, 在任何小程序项目中使用)</li>
<li>一定要针对小程序开发的特性(逻辑层和视图层通讯的方式)做特殊处理</li>
<li>可以应用于大型项目</li>
</ol>
<p>于是, 考虑了业务开发中的具体需求, 我将要求细化为以下几点.</p>
<ul>
<li>具备状态管理的一般功能, 不自造标准, 向流行规范靠拢.</li>
<li>可追踪到状态引起视图改变已完成的时间点(什么时候<code>setData</code>完毕)</li>
<li>模块化, 可适应大型项目需要</li>
</ul>
<p>经过几周的调研和开发, <code>two-vuex</code>就这么迎来了初版.</p>
<h2 id="two-vuex实现解读"><a href="#two-vuex实现解读" class="headerlink" title="two-vuex实现解读"></a>two-vuex实现解读</h2><p><code>two-vuex</code>的调用模式十分接近<code>Vue.js</code>的状态管理库<code>vuex</code>, 并针对小程序<code>setData</code>的方式进行了特殊处理. 使开发者可以在<code>dispatch</code>的<code>Promise</code>中获取视图全部更新完毕的时间点. 下面, 我们从设计层面分析下<code>two-vuex</code>是怎么实现的.</p>
<h3 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h3><p><code>two-vuex</code>最终导出一个<code>Store</code>类, 通过传入配置对象, 实例化一个<code>store</code>对象, 状态管理的一切都由这个对象控制.</p>
<p>调用方式大概是这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getterCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(setData, state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> setData(&#123; <span class="attr">count</span>: state.count + payload.add &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(&#123; commit &#125;, payload) &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getterCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(setData, state, payload) &#123;</span><br><span class="line">      <span class="keyword">return</span> setData(&#123; <span class="attr">count</span>: state.count + payload.add &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(&#123; commit &#125;, payload) &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Store(config)</span><br></pre></td></tr></table></figure>
<p>先来看看store对象的结构:</p>
<p><img src="https://i.loli.net/2019/04/11/5caf27f46845f.jpg" alt="store对象结构"></p>
<p>这就是最终想生成的store对象, 按照<code>vuex</code>规范, 状态<code>state</code>是按照模块名层层嵌套的一个树结构, 但<code>mutation</code>, <code>action</code>和<code>getters</code>却是扁平化的, 模块之间用<code>/</code>连接. 这样的设计和<code>vuex</code>规范完全相符. </p>
<p>下面先来了解下<code>Store</code>实例化的最外层流程</p>
<h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">     <span class="comment">// store的mutations映射表, 一个type字段(包含namespage)可以对应多个mutations</span></span><br><span class="line">     <span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">     <span class="comment">// store的state与组件内this.data.$states的映射表</span></span><br><span class="line">     <span class="keyword">this</span>._statesMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// store的getters 映射表, 一个type字段只能代表一个计算属性方法方法</span></span><br><span class="line">     <span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">     <span class="comment">// store的getters与组件内this.data.$getters的映射表</span></span><br><span class="line">     <span class="keyword">this</span>._gettersMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// store的actions映射表, 一个type字段(包含namespace)可以对应多个action</span></span><br><span class="line">     <span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 以namespacedKey存储所有模块</span></span><br><span class="line">     <span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 重要步骤1. 递归生成所有modules及其父子关系</span></span><br><span class="line">     <span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 重要步骤2. 给actions mutations getters 赋值</span></span><br><span class="line">     installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 给store.getters增加getter</span></span><br><span class="line">     addGetterToStoreGetters(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一份<code>Store</code>类的<code>constructor</code>伪代码, <code>Store</code>类在实例化的过程中首先为<code>mutations</code>, <code>getters</code>, <code>actions</code>等生成了各自对应的容器空对象, 然后进行两个重要步骤, 第一个步骤递归生成所有<code>modules</code>节点, 并形成嵌套的模块关系. 第二个步骤从根节点开始, 给每个模块的<code>mutations</code>, <code>getters</code>, <code>actions</code>赋值.</p>
<h3 id="new-ModuleCollection的过程-生成模块树"><a href="#new-ModuleCollection的过程-生成模块树" class="headerlink" title="new ModuleCollection的过程, 生成模块树"></a>new ModuleCollection的过程, 生成模块树</h3><p>先来看<code>new ModuleCollection</code>的过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawRootModule) &#123;</span><br><span class="line">    <span class="comment">// 外部调用: new ModuleCollection(options)</span></span><br><span class="line">    <span class="keyword">this</span>.register([], rawRootModule, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register(path, rawModule, isRoot) &#123;</span><br><span class="line">    <span class="comment">// 将每个对应模块实例化为Module类型</span></span><br><span class="line">    <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, isRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是根模块, 将moduleCollection实例的root属性设置为根模块</span></span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.root = newModule</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是根模块, 则找到当前模块的父模块(父模块肯定先于子模块注册)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">      <span class="comment">// 给父模块的_children数组中设置对应的子模块, 这里的parent也是Module类型的模块</span></span><br><span class="line">      parent.addChild(path[path.length - <span class="number">1</span>], newModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该模块有modules配置, 递归执行register方法</span></span><br><span class="line">    <span class="keyword">if</span> (rawModule.modules) &#123;</span><br><span class="line">      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</span><br><span class="line">        <span class="comment">// path在这里会concat key, 从而形成路径结构</span></span><br><span class="line">        <span class="keyword">this</span>.register(path.concat(key), rawChildModule)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawModule, isRoot) &#123;</span><br><span class="line">      <span class="keyword">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="comment">// 每个module的在config中字面量对象的原始定义</span></span><br><span class="line">      <span class="keyword">this</span>._rawModule = rawModule</span><br><span class="line">      <span class="comment">// 获取module原始定义上的原始state定义(不嵌套的), 并挂载在this.state上</span></span><br><span class="line">      <span class="keyword">const</span> rawState = rawModule.state</span><br><span class="line">      <span class="keyword">this</span>.state = <span class="keyword">typeof</span> rawState === <span class="string">'function'</span> ? rawState() : rawState || &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ModuleCollection</code>对象生成的过程中, 会为每一个单独模块生成一个<code>Module</code>类对象, 对象中有<code>children</code>数组, 用来装载当前模块的所有子模块, 并给每个<code>Module</code>挂载模块下的<code>state</code>值, 在运行<code>register</code>方法时, 将模块间的父子关系定义下来, 并给<code>Module</code>的每一个子模块递归调用<code>register</code>方法, 递归生成模块树.</p>
<p>下面, 我们看看<code>installModule</code>的过程.</p>
<h3 id="installModule-递归给每个模块注册mutation-getters-和-action"><a href="#installModule-递归给每个模块注册mutation-getters-和-action" class="headerlink" title="installModule, 递归给每个模块注册mutation, getters 和 action"></a>installModule, 递归给每个模块注册mutation, getters 和 action</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 给父模块的state设置当前子模块的state</span></span><br><span class="line">    <span class="comment">// store.state[...parent]['son'] = son['state']</span></span><br><span class="line">    parentState[moduleName] = <span class="built_in">module</span>.state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给当前模块注册mutation</span></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给当前模块注册getters</span></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给当前模块注册action</span></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerAction(store, namespacedType, action, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归对当前模块的子模块(this._children)调用installModule</span></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>installModule</code>的过程会对每个模块进行一系列处理, 然后再递归对其子模块进行同样的处理. 我们先关注下处理过程: 首先会根据<code>path</code>数组生成每个模块的<code>namespace</code>, 这个<code>namespace</code>即<code>&quot;a/b&quot;</code>这样的扁平化的命名空间字符串的拼接, 再用<code>getNestedState</code>方法找到当前模块的父模块, 并给父模块命名空间下挂载当前模块的<code>state</code>(注意, 直到此时, 才生成了真正逻辑上由各个模块组合的<code>state</code>树). 然后, 会用<code>makeLocalContext</code>方法生成一个本地化的<code>local</code>对象. 最后, 会进入到依次注册<code>mutation</code>, <code>getters</code> 和 <code>action</code>的过程中, 这些过程都需要用到<code>local</code>对象.</p>
<p>继续分析生成<code>local</code>对象的过程.</p>
<h3 id="makeLocalContext的过程-生成局部化的store对象"><a href="#makeLocalContext的过程-生成局部化的store对象" class="headerlink" title="makeLocalContext的过程, 生成局部化的store对象"></a>makeLocalContext的过程, 生成局部化的store对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span>(<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noNamespace标识当前模块是否是嵌套子模块</span></span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></span><br><span class="line">  <span class="keyword">const</span> local = &#123;</span><br><span class="line">    state: getNestedState(store.state, path),</span><br><span class="line">    dispatch: noNamespace</span><br><span class="line">      ? store.dispatch</span><br><span class="line">      : <span class="function">(<span class="params">type, payload, options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果没设置options: &#123; root:true &#125;, 给action type拼接namespace前缀, 并检查是否有该action被注册</span></span><br><span class="line">          <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">            type = namespace + type</span><br><span class="line">            <span class="keyword">if</span> (!store._actions[type]) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">console</span>.error(</span><br><span class="line">                <span class="string">`[two-vuex] unknown local action type: <span class="subst">$&#123;type&#125;</span>`</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> store.dispatch(type, payload)</span><br><span class="line">        &#125;,</span><br><span class="line">    commit: noNamespace</span><br><span class="line">      ? store.commit</span><br><span class="line">      : <span class="function">(<span class="params">type, payload, options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果没设置options: &#123; root:true &#125;, 给 mutation type拼接namespace前缀, 并检查是否有该action被注册</span></span><br><span class="line">          <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">            type = namespace + type</span><br><span class="line">            <span class="keyword">if</span> (!store._mutations[type]) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">console</span>.error(</span><br><span class="line">                <span class="string">`[two-vuex] unknow local mutation type: <span class="subst">$&#123;type&#125;</span>`</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> store.commit(type, payload)</span><br><span class="line">        &#125;,</span><br><span class="line">    setStore: noNamespace</span><br><span class="line">      ? store.setStore</span><br><span class="line">      : <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> prefix = namespace</span><br><span class="line">            .split(<span class="string">'/'</span>)</span><br><span class="line">            .filter(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">            .join(<span class="string">'.'</span>)</span><br><span class="line">          config = <span class="built_in">Object</span>.keys(config).reduce(<span class="function">(<span class="params">accumulator, key</span>) =&gt;</span> &#123;</span><br><span class="line">            accumulator[<span class="string">`<span class="subst">$&#123;prefix&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span>] = config[key]</span><br><span class="line">            <span class="keyword">return</span> accumulator</span><br><span class="line">          &#125;, &#123;&#125;)</span><br><span class="line">          <span class="keyword">return</span> store.setStore(config)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state和getters会产生改变, 所以用lazy获取的方式</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      get: noNamespace</span><br><span class="line">        ? <span class="function"><span class="params">()</span> =&gt;</span> store.getters</span><br><span class="line">        : <span class="function"><span class="params">()</span> =&gt;</span> makeLocalGetters(store, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeLocalContext</code>方法是vuex源码中的重要一环, dispatch action时的第一个参数, 可以拿到局部模块的<code>state</code>, <code>commit</code>, <code>dispatch</code>, <code>setStore</code>(一会再解释<code>setStore</code>是什么). 实际上, 它是在<code>commit</code>, <code>dispatch</code>, <code>setStore</code>外再包一层, 使这些方法在真正执行时, 执行的对应方法<code>key</code>前加了命名空间前缀(比如<code>commit</code>一个<code>a</code>模块下的<code>add</code>方法, 实际上执行的<code>mutation</code>是<code>a/add</code>). <code>local</code>内部的<code>state</code>是根据<code>path</code>从根状态上取到的, 所以也做到了局部化.</p>
<h3 id="注册Mutation"><a href="#注册Mutation" class="headerlink" title="注册Mutation"></a>注册Mutation</h3><p>生成<code>local</code>对象后, 要给模块分别注册<code>mutation</code>, <code>getters</code>, <code>action</code>, 争取扁平化的存储这些要素.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给当前模块注册mutation</span></span><br><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span>(<span class="params">store, type, mutation, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutation.call(store, local.setStore, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>store._mutations</code>用于扁平化的存储所有store中的<code>mutations</code>, 首先<code>mutation type</code>是 <code>模块名</code> 与 <code>mutation名</code> 的一个拼接, 以此达到扁平化的目的, 每一个扁平化的<code>key</code>对应一个<code>mutation</code>数组, 其中存放的方法绑定了上下文<code>store</code>, 并将<code>local</code>对象传入, 达到参数局部化的目的.</p>
<h3 id="注册Action"><a href="#注册Action" class="headerlink" title="注册Action"></a>注册Action</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给当前模块注册action</span></span><br><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerAction(store, namespacedType, action, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span>(<span class="params">store, type, action, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span>(<span class="params">payload, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = action.call(</span><br><span class="line">      store,</span><br><span class="line">      &#123;</span><br><span class="line">        dispatch: local.dispatch,</span><br><span class="line">        getters: local.getters,</span><br><span class="line">        commit: local.commit,</span><br><span class="line">        state: local.state,</span><br><span class="line">        rootState: store.state,</span><br><span class="line">        rootGetters: store.getters</span><br><span class="line">      &#125;,</span><br><span class="line">      payload</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 将action的返回结果promise化</span></span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>action</code>的注册过程和<code>mutation</code>类似, 在<code>action</code>被<code>call</code>时根据<code>local</code>对象组装局部<code>context</code>对象, 并将返回结果<code>Promise</code>化, 方便后续调用.</p>
<h3 id="store-setStore-与-store-commit"><a href="#store-setStore-与-store-commit" class="headerlink" title="store.setStore 与 store.commit"></a>store.setStore 与 store.commit</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.setStore方法</span></span><br><span class="line">setStore(config = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// setStore返回一个promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历setStore的config, 对每个key, value做处理</span></span><br><span class="line">    forEachValue(config, (val, key) =&gt; &#123;</span><br><span class="line">      processNestedState(<span class="keyword">this</span>, key, (nestedState, tailKey) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 给store中的对应项赋值</span></span><br><span class="line">        nestedState[tailKey] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历_statesMap中的依赖项, 对每个依赖项调用setData, 在渲染完成后resolve</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果调用namespacedKey state 没有组件注册过, 报警, return</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._statesMap[key])</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[two-vuex] 没有页面或组件订阅store中的状态: "<span class="subst">$&#123;key&#125;</span>"`</span></span><br><span class="line">          )</span><br><span class="line">        <span class="comment">// 循环_statesMap映射表, 找到namespacedKey对应的数组, 对其数组中的每一个注册过的依赖项执行setData</span></span><br><span class="line">        <span class="comment">// 在setData的回调中收集promise的resolved状态, 方便在最后的Promise.all中获取全部视图渲染完毕的状态</span></span><br><span class="line">        <span class="keyword">const</span> promises = <span class="keyword">this</span>._statesMap[key].map(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; component, dataKey &#125; = o</span><br><span class="line">            <span class="keyword">const</span> setData =</span><br><span class="line">              <span class="keyword">typeof</span> component.$setData === <span class="string">'function'</span></span><br><span class="line">                ? component.$setData</span><br><span class="line">                : component.setData</span><br><span class="line">            setData.call(component, &#123; [<span class="string">`$state.<span class="subst">$&#123;dataKey&#125;</span>`</span>]: val &#125;, () =&gt; &#123;</span><br><span class="line">              resolve()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个Promise resolved 时代表所有states和getters在所有组件上渲染完毕(所有setData的回调执行完毕)</span></span><br><span class="line">        <span class="built_in">Promise</span>.all(promises.concat(computedPromises)).then(<span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(promises)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.commit 方法</span></span><br><span class="line">commit(type, payload) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// options中的root若为true, 可以在命名空间里提交根mutation</span></span><br><span class="line">    <span class="comment">// 需在这里给mutation传递setStore方法</span></span><br><span class="line">    <span class="keyword">const</span> entry = <span class="keyword">this</span>._mutations[type]</span><br><span class="line">    <span class="comment">// 如果没有该mutation, 报错</span></span><br><span class="line">    <span class="keyword">if</span> (!entry)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">`[two-vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// 将所有mutation循环调用, 实际调用的是wrappedMutationHandler</span></span><br><span class="line">    <span class="keyword">const</span> promises = entry.map(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="keyword">this</span>._withCommit === <span class="string">'function'</span></span><br><span class="line">        ? <span class="keyword">this</span>._withCommit(mutation.bind(<span class="keyword">this</span>, payload))</span><br><span class="line">        : mutation(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(promises)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>two-vuex</code>并没有采用<code>vue</code>的数据监听机制, 为了不引入其他npm库, 并对代码的性能做严格把控. 我选择在每个组件注册时记录每个组件对store内数据的订阅者, 用一套类发布订阅机制去触发数据的改变, 触发数据改变的扳机就是<code>setStore</code>方法, 它作为<code>mutation</code>的第一个参数被传入, 在<code>mutation</code>内约定用<code>setStore</code>方法触发数据的改变.</p>
<p>在代码设计上, 在<code>mutation</code>中返回<code>setStore</code>方法的运行结果(一个包装过的<code>Promise</code>), 在所有依赖<code>store</code>中<code>state</code>的数据和更改过的计算属性在页面上渲染完毕后, 可以用<code>commit.then</code>获取所有页面更新完毕的时间节点, 这个改动我认为对小程序开发是十分必要的. 在许多场景的<code>action</code>封装中, 获取数据全部渲染完成的时间点(所有<code>setData</code>执行完毕)是一个必要需求.</p>
<h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch(type, payload) &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">this</span>._actions[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">`[two-vuex] unknown action type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> result =</span><br><span class="line">    entry.length &gt; <span class="number">1</span></span><br><span class="line">      ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">action</span> =&gt;</span> action(payload)))</span><br><span class="line">      : entry[<span class="number">0</span>](payload)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Action在注册时已经将返回结果<code>Promise</code>化, 所以<code>dispatch</code>方法在调用<code>action</code>后传递<code>Promise</code>即可</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><code>store</code>的计算属性<code>getters</code>是<code>vuex</code>思想中重要的一环, 但由于小程序不宜使用<code>new Vue</code>实例的<code>computed</code>功能进行监听, 从实现上要做一些修改. </p>
<p>先来看一下在<code>installModule</code>的过程中, <code>getters</code>的注册过程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在installModule的过程中注册getters</span></span><br><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span>(<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果_wrappedGetters表中, type已经有值, 警告重复声明getter, 返回</span></span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">`[two-vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log('registerGetter', type)</span></span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有installModule步骤结束后, 给store.getters对象赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addGetterToStoreGetters</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 给store增加getters属性</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="comment">// 遍历_wrappedGetters映射表, 给store.getters增加:</span></span><br><span class="line">  <span class="comment">// 以namespacedKey为属性名, 惰性求值的getter为值的Object property</span></span><br><span class="line">  forEachValue(store._wrappedGetters, (getter, namespacedKey) =&gt; &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, namespacedKey, &#123;</span><br><span class="line">      get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getter(store)</span><br><span class="line">      &#125;,</span><br><span class="line">      enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>store._wrappedGetters</code>对象用来承载经过扁平化模块名拼接的<code>getters</code>, 在<code>installModule</code>过程结束后, 会统一用<code>lazy getter</code>的方式挂载所有计算属性到<code>store.getters</code>对象上.</p>
<p>下面是<code>makeLocalContext</code>过程中,针对计算属性做的处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在makeLocalContext过程中, 产生的和计算属性的相关处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span>(<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// noNamespace标识当前模块是否是嵌套子模块</span></span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></span><br><span class="line">  <span class="keyword">const</span> local = &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// state和getters会产生改变, 所以用lazy获取的方式</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      get: <span class="function"><span class="params">()</span> =&gt;</span> getNestedState(store.state, path)</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">      get: noNamespace</span><br><span class="line">        ? <span class="function"><span class="params">()</span> =&gt;</span> store.getters</span><br><span class="line">        : <span class="function"><span class="params">()</span> =&gt;</span> makeLocalGetters(store, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> local</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalGetters</span>(<span class="params">store, namespace</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gettersProxy = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> namespaceLen = namespace.length</span><br><span class="line">  forEachValue(store._wrappedGetters, (getter, type) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果命名空间不是以namespace开头, 过滤掉</span></span><br><span class="line">    <span class="keyword">if</span> (type.slice(<span class="number">0</span>, namespaceLen) !== namespace) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// localType: a/b/c -&gt; c</span></span><br><span class="line">    <span class="keyword">const</span> localType = type.slice(namespaceLen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getterProxy['c'] = getter: () =&gt; store.getters['a/b/c']</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">      get: <span class="function"><span class="params">()</span> =&gt;</span> getter(store),</span><br><span class="line">      enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> gettersProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>makeLocalContext</code>的过程中, 通过<code>defineProperty</code>用<code>lazy get</code>的方式将<code>getters</code>的<code>key</code>指向注册<code>getters</code>时包装的<code>wrappedGetter</code>方法的实际运行结果.</p>
<p>下面是<code>setStore</code>执行的过程中关于<code>getter</code>的处理.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setStore的过程中产生的和计算属性相关的处理</span></span><br><span class="line">setStore(config = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 计算属性Promises数组</span></span><br><span class="line">  <span class="keyword">let</span> computedPromises = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环computed映射表, 计算全部getter, 再去_gettersMap中找到对应的依赖项setData</span></span><br><span class="line">  forEachValue(<span class="keyword">this</span>._wrappedGetters, (getter, key) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算对应的计算属性值</span></span><br><span class="line">    <span class="keyword">const</span> computedValue = getter(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果计算属性值和上次缓存值不同, 进行计算属性渲染逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (getter.cache !== computedValue) &#123;</span><br><span class="line">      <span class="comment">// 将计算属性缓存值更新</span></span><br><span class="line">      getter.cache = computedValue</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果没有任何组件注册了计算属性, 计算属性也要计算(上面几行逻辑), 但不需进行下面的关联组件渲染逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>._gettersMap[key]) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 循环gettersMap映射表, 找到namespacedKey对应的数组, 对其数组中的每一个注册过的依赖项执行setData</span></span><br><span class="line">      <span class="comment">// 在setData的回调中收集promise的resolved状态, 方便在最后的Promise.all中获取全部视图渲染完毕的状态</span></span><br><span class="line">      computedPromises = <span class="keyword">this</span>._gettersMap[key].map(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; component, dataKey &#125; = o</span><br><span class="line">          <span class="keyword">const</span> setData =</span><br><span class="line">            <span class="keyword">typeof</span> component.$setData === <span class="string">'function'</span></span><br><span class="line">              ? component.$setData</span><br><span class="line">              : component.setData</span><br><span class="line">          <span class="comment">// key: 'ABCount', value: this._wrappedGetters['a/b/count'](store)</span></span><br><span class="line">          setData.call(</span><br><span class="line">            component,</span><br><span class="line">            &#123; [<span class="string">`$getters.<span class="subst">$&#123;dataKey&#125;</span>`</span>]: computedValue &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              resolve()</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次<code>setStore</code>执行时, 会依次计算新的<code>getter</code>的值和缓存中的是否三等, 设计为是否三等是出于对性能的考虑, 如果计算属性计算的是一个引用类型, 需要返回一个新引用地址的字面量对象.</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><code>two-vuex</code>是一项非常有意思的尝试, 在实现过程中遇到了很多设计层面的抉择, 思考并实践过后, 着实受益匪浅, 自己的技术和设计能力也得到了成长.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/04/12/vue-source-09/" class="next">上一篇</a><a href="/2019/05/22/vue-source-10/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>