<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vue-router 源码解读 06 - RouterView组件 · choteewang</title><meta name="description" content="Vue-router 源码解读 06 - RouterView组件 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vue-router 源码解读 06 - RouterView组件</h1><div class="post-info">2019年10月2日</div><div class="post-content"><p>上节分析了路径切换的过程, URL切换后, 还是要触发对应的组件渲染过程, 本节来分析组件渲染的过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/install.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证installed方法只执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="keyword">return</span></span><br><span class="line">  install.installed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="keyword">if</span> (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用全局Vue.mixin让给每个组件都添加beforeCreate和destroyed的部分逻辑</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="comment">// 根Vue实例的options上用户才会定义router配置对象</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="comment">// 将当前vue实例赋值给this._routerRoot</span></span><br><span class="line">        <span class="keyword">this</span>._routerRoot = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        <span class="comment">// 执行init方法</span></span><br><span class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</span><br><span class="line">        <span class="comment">// 将_route对象定义为响应式的</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 对根vm实例的_route属性进行响应式监听, 依赖收集渲染watcher(router-view), 在setter发生时重新出发渲染watcher(router-view)的render函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// setter -&gt; history.listen</span></span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 让每一个组件初始化时就将_routerRoot赋值为根vue实例</span></span><br><span class="line">        <span class="keyword">this</span>._routerRoot = (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._routerRoot) || <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型上定义 $router 为 rootVue实例.$options.router</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;</span><br><span class="line">    get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型上定义 $route 为 rootVue实例.$route</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">    get () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册RouterView和RouterLink组件</span></span><br><span class="line">  Vue.component(<span class="string">'RouterView'</span>, View)</span><br><span class="line">  Vue.component(<span class="string">'RouterLink'</span>, Link)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>install</code>方法的逻辑最后, 会执行<code>Vue.component</code>方法注册<code>RouterView</code>和<code>RouterLink</code>组件, 继续看看<code>RouterView</code>组件的实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/view.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'RouterView'</span>,</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (_, &#123; props, children, parent, data &#125;) &#123;</span><br><span class="line">    data.routerView = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// directly use parent context's createElement() function</span></span><br><span class="line">    <span class="comment">// so that components rendered by router-view can resolve named slots</span></span><br><span class="line">    <span class="comment">// parent是承载viewRouter组件的上层vue实例 </span></span><br><span class="line">    <span class="comment">// &lt;App&gt;组件的模板中有&lt;router-view/&gt;, 这里的parent就是App对应的vm实例</span></span><br><span class="line">    <span class="keyword">const</span> h = parent.$createElement</span><br><span class="line">    <span class="comment">// 命名视图</span></span><br><span class="line">    <span class="keyword">const</span> name = props.name</span><br><span class="line">    <span class="comment">// 访问$route实际访问的是 this._router.history.current</span></span><br><span class="line">    <span class="comment">// 也就是找到当前路径</span></span><br><span class="line">    <span class="keyword">const</span> route = parent.$route</span><br><span class="line">    <span class="keyword">const</span> cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determine current view depth, also check to see if the tree</span></span><br><span class="line">    <span class="comment">// has been toggled inactive but kept-alive.</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">      <span class="comment">// router-view组件的data.routerView=true</span></span><br><span class="line">      <span class="comment">// 当父占位节点存在切父占位节点是router-view组件时, 深度++</span></span><br><span class="line">      <span class="comment">// 将深度赋值给data.routerViewDepth上, 以此来找到和用户定义的routes中对应组件该显示在哪层router-view上.(用户定义的routes和data.routerViewDepth的层级一一对应)</span></span><br><span class="line">      <span class="keyword">if</span> (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">        depth++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent._inactive) &#123;</span><br><span class="line">        inactive = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    data.routerViewDepth = depth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render previous view if the tree is inactive and kept-alive</span></span><br><span class="line">    <span class="keyword">if</span> (inactive) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(cache[name], data, children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过当前路由的matched数组, 找到对应路由组件</span></span><br><span class="line">    <span class="comment">// (matched数组是[祖先, 父, 子]的结构, 前面几节分析了)</span></span><br><span class="line">    <span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line">    <span class="comment">// render empty node if no matched route</span></span><br><span class="line">    <span class="keyword">if</span> (!matched) &#123;</span><br><span class="line">      cache[name] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配到的组件先从缓存中取</span></span><br><span class="line">    <span class="keyword">const</span> component = cache[name] = matched.components[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach instance registration hook</span></span><br><span class="line">    <span class="comment">// this will be called in the instance's injected lifecycle hooks</span></span><br><span class="line">    data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// val could be undefined for unregistration</span></span><br><span class="line">      <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (val &amp;&amp; current !== vm) ||</span><br><span class="line">        (!val &amp;&amp; current === vm)</span><br><span class="line">      ) &#123;</span><br><span class="line">        matched.instances[name] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also register instance in prepatch hook</span></span><br><span class="line">    <span class="comment">// in case the same component instance is reused across different routes</span></span><br><span class="line">    ;<span class="function">(<span class="params">data.hook || (data.hook = &#123;&#125;</span>)).<span class="params">prepatch</span> = (<span class="params">_, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">      matched.instances[name] = vnode.componentInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve props</span></span><br><span class="line">    <span class="keyword">let</span> propsToPass = data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name])</span><br><span class="line">    <span class="keyword">if</span> (propsToPass) &#123;</span><br><span class="line">      <span class="comment">// clone to prevent mutation</span></span><br><span class="line">      propsToPass = data.props = extend(&#123;&#125;, propsToPass)</span><br><span class="line">      <span class="comment">// pass non-declared props as attrs</span></span><br><span class="line">      <span class="keyword">const</span> attrs = data.attrs = data.attrs || &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsToPass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!component.props || !(key <span class="keyword">in</span> component.props)) &#123;</span><br><span class="line">          attrs[key] = propsToPass[key]</span><br><span class="line">          <span class="keyword">delete</span> propsToPass[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用h函数渲染该组件</span></span><br><span class="line">    <span class="comment">// -&gt; 如何出发此render函数? defineReactive -&gt; _route</span></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>router-view</code>组件有一个<code>name</code>的<code>prop</code>来定义命名视图, 然后就是<code>render</code>函数的逻辑.</p>
<p><code>render</code>函数首先将<code>data.routerView</code>设置为<code>true</code>(后续层级计算的重要依据), 然后获取父实例对应的<code>createElement</code>方法(<code>h</code>函数), 然后获取<code>parent.$route</code>, 实际上是获取当前的<code>route</code>对象, 我们回到<code>install</code>方法可以看到对应的逻辑.</p>
<p>在<code>install</code>方法中, <code>vm</code>实例的<code>$route</code>设置为返回<code>this._routerRoot._route</code>, 在之前分析<code>install</code>方法时, 每一个<code>vm</code>实例上的<code>_routerRoot</code>都指向跟<code>vue</code>实例, 它的<code>_route</code>属性用<code>defineReactive</code>方法设置为返回<code>this._router.history.current</code>, 也就是当前路径.</p>
<p>回到<code>RouterView</code>的<code>render</code>方法的逻辑中, 之后会计算计算当前<code>routerView</code>的深度, 当父占位节点存在切父占位节点是<code>router-view</code>组件时, 深度++, 将深度赋值给<code>data.routerViewDepth</code>上, 以此来找到和用户定义的routes中对应组件该显示在哪层<code>router-view</code>上.(用户定义的<code>routes</code>和<code>data.routerViewDepth</code>的层级一一对应).</p>
<p>根据<code>depth</code>, 去<code>route</code>的<code>matched</code>属性(前面分析过)根据层级获取对应的用户定义<code>route</code>对象, 从而拿到用户定义的<code>component</code>. 最终调用<code>h</code>函数将组件渲染到页面上.</p>
<p>当<code>new VueRouter</code>时, 组件会执行全局混入的<code>beforeCreate</code>方法, 之中会执行<code>this._router.init(this)</code>, 之后会执行<code>this.history.listen</code>方法, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 注册history.listen的回调</span></span><br><span class="line">    <span class="comment">// 在路由发生变化时对根实例的_route进行改变从而出发_route的响应式setter</span></span><br><span class="line">    <span class="comment">// 再触发对应渲染watcher(router-view)的render方法的更新</span></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// app是根vue实例, 根vue实例</span></span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在路由切换后, 会执行<code>history.listen</code>注册的回调, 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/history/base.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  listen (cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">  &#125;</span><br><span class="line">  updateRoute (route: Route) &#123;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="keyword">this</span>.current</span><br><span class="line">    <span class="keyword">this</span>.current = route</span><br><span class="line">    <span class="keyword">this</span>.cb &amp;&amp; <span class="keyword">this</span>.cb(route)</span><br><span class="line">    <span class="keyword">this</span>.router.afterHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时会将<code>app._route</code>赋值为<code>route</code>, 又因为在组件<code>beforeCreate</code>的过程中(<code>install</code>方法中), 会执行<code>Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</code>, 所以其实给<code>_route</code>赋值触发的是<code>_route</code>属性的<code>getter</code>, 会触发<code>route</code>依赖的对应<code>routerView</code>组件的<code>render Watcer</code>的更新, 从而触发<code>render</code>函数, 从新渲染对应组件.</p>
<p>至此, 我们分析了<code>RouterView</code>根据路径切换渲染对应组件的过程.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/09/30/vue-source-23/" class="next">上一篇</a><a href="/2019/10/22/vue-source-25/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>