<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Koa源码解读 · choteewang</title><meta name="description" content="Koa源码解读 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Koa源码解读</h1><div class="post-info">2019年10月29日</div><div class="post-content"><p><code>Koa</code>是一个精巧的 <code>Node.js</code> 框架, 源码质量极高. 其设计巧妙的<code>&quot;洋葱模型&quot;</code>中间件实现十分经典. 值得仔细研读以学习其优秀的设计思想. 在业余时间里, 我阅读了<code>Koa</code>的源码, 下面是我的一些总结和收获.</p>
<h3 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h3><p><code>Koa</code>的源码文件在<code>lib</code>文件夹中, 还引用一些成熟的库, 他们的分工如下</p>
<blockquote>
<p><code>application.js</code>内含<code>Koa</code>类, 是整个框架的入口<br><code>context.js</code>是ctx对象的原型, 代理<code>request</code>和<code>response</code>对象上的属性和方法<br><code>request.js</code>导出<code>request</code>的原型对象<br><code>response.js</code>导出<code>response</code>的原型对象<br>实现<code>&quot;洋葱模型&quot;</code>的<code>compose</code>函数在单独的npm包<code>koa-compose</code>中<br>项目还依赖了<code>node-delegates</code>库, 用来代理方法和属性.</p>
</blockquote>
<h3 id="new-Koa-listen"><a href="#new-Koa-listen" class="headerlink" title="new Koa().listen()"></a>new Koa().listen()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 中间件数组</span></span><br><span class="line">    <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    <span class="comment">// 原型继承 context, request, response 后, 挂载在app实例上</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      <span class="keyword">this</span>[util.inspect.custom] = <span class="keyword">this</span>.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Application</code>就是<code>Koa</code>类, 它继承自Node原生模块<code>Emitter</code>, 具备了事件机制的能力. 在<code>new Koa()</code>时, 类实例挂载了中间件数组, 环境变量, 并原型继承了从<code>context</code>, <code>request</code>, <code>response</code>三个模块导出的对象, 将继承后的对象挂载到<code>app</code>上.</p>
<p>在调用<code>app.listen</code>方法时, 内部调用Node原生的<code>http.createServer</code>, 并将<code>listen</code>的全部参数透传给<code>server.listen</code></p>
<p>至此, node服务初始化完成, <code>http.createServer</code>的回调由<code>this.callback</code>运行时返回, 这里是一切框架逻辑的实际入口.</p>
<h3 id="app-use"><a href="#app-use" class="headerlink" title="app.use()"></a>app.use()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">  <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">    deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">              <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">              <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">    fn = convert(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>app.use</code>方法用于注册中间件, <code>&quot;洋葱机制&quot;</code>会保证中间件的异步执行顺序, 该方法会先检查<code>fn</code>是否是一个<code>function</code>, 如果中间件不是<code>async function</code>, 而是<code>generator function</code>, 会用<code>koa-convert</code>对方法进行转换. </p>
<p>在检查结束后, 将中间件方法放入<code>this.middleware</code>数组, <code>return this</code>确保链式调用.</p>
<h3 id="this-callback-生成-createServer-方法的回调函数"><a href="#this-callback-生成-createServer-方法的回调函数" class="headerlink" title="this.callback(): 生成 createServer 方法的回调函数"></a>this.callback(): 生成 createServer 方法的回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listenerCount(<span class="string">'error'</span>)) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this.callback</code>方法先组合所有的中间件(组合中间件的部分将在下节重点分析), 再生成<code>http.createServer</code>的回调. <code>handleRequest</code>方法即<code>http.createServer</code>的最外层, 该方法内部先组合<code>ctx</code>对象, 用<code>ctx</code>代理Node原生的<code>request</code>和<code>response</code>上的属性和方法(<code>ctx</code>的构造过程将在最后一节重点分析), 再调用实例上的<code>handleRequest</code>方法.</p>
<h3 id="构建洋葱模型-compose方法解读"><a href="#构建洋葱模型-compose方法解读" class="headerlink" title="构建洋葱模型, compose方法解读"></a>构建洋葱模型, compose方法解读</h3><p><img src="https://i.loli.net/2019/07/22/5d355e003651531664.png" alt="洋葱模型"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 类型检查</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数 next 表明在执行完所有中间件后, 是否还要额外执行一个中间件(全局后置中间件)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 每执行一个中间件 i++, index也++, i-index=1, 但如果连续调用两次await next(), 第二次调用next()时i没变(上次调用的闭包作用域引用), index却++了</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套执行中间件</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="comment">// 如果所有中间件都执行完了, 运行传入的全局后置中间件</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="comment">// 这里用try-catch是为了捕获 fn 不是async方法, 是同步方法的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果fn是异步的async function, 错误会被handleRequest中的.catch(onerror)捕获</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&quot;洋葱模型&quot;</code>是<code>Koa</code>设计模式的精髓, <code>koa</code>的中间件函数是<code>async function</code>, 每个中间件函数等待下层中间件执行完毕(<code>await next()</code>)后再继续执行当前中间件的后续逻辑, 让所有中间件像洋葱一样嵌套起来.</p>
<p><code>&quot;洋葱模型&quot;</code>是通过<code>compose</code>方法实现的. <code>compose</code>方法非常经典, 是对尾触发设计模式, 函数柯里化, 闭包, 作用域, 同步与异步错误处理的综合运用, 值得仔细研读.</p>
<h4 id="compose-函数柯里化"><a href="#compose-函数柯里化" class="headerlink" title="compose: 函数柯里化"></a>compose: 函数柯里化</h4><p><code>compose</code>方法先检查中间件数组和其每一项的类型, 然后运用函数柯里化, 返回一个接收<code>ctx</code>和全局后置中间件函数的方法.</p>
<p>这个方法内部先在最上层定义一个<code>index</code>代表实际中间件的执行计数, 然后定义<code>dispatch</code>方法(这里有函数提升), 并<code>return dispatch(0)</code>, 实际上代表从<code>middleware</code>数组的第0项开始执行, <code>dispatch</code>内部执行的中间件函数会继续调用<code>dispatch(n+1)</code>. 如此递归直至所有中间件函数执行完毕, 如果传入了全局后置中间件(<code>koa-compose</code>是个单独的包, 全局后置中间件在其他库的使用中可用), 继续执行全局后置中间件, 最后向外<code>return Promise.resolve()</code>.</p>
<h4 id="compose-巧用闭包-避免多次调用await-next"><a href="#compose-巧用闭包-避免多次调用await-next" class="headerlink" title="compose: 巧用闭包, 避免多次调用await next()"></a>compose: 巧用闭包, 避免多次调用await next()</h4><p>中间件方法中的参数<code>next</code>其实就是<code>dispatch.bind(null, i + 1)</code>, 如果在一个中间件函数中<strong>多次调用<code>await next()</code>, 等于执行了多次<code>dispatch.bind(null, i + 1)</code>(注意这里的<code>i</code>是固定作用域的, 不会变)</strong>. 每次调用<code>dispatch</code>方法时, 会判断<code>i</code>是否大于<code>index</code>, 如果不然则报错. 并将<code>i</code>赋值给<code>dispatch</code>上层闭包作用域的<code>index</code>. </p>
<p>在这种机制下, 在一个中间件方法中多次执行<code>await next()</code>会让<code>index</code>的值每次都+1, 但<code>i</code>则不变, 从而导致<code>i&lt;=index</code>而报错. 作者用这种方式防止了<code>await next()</code>被调用多次.</p>
<h4 id="compose-尾触发模式执行中间件-保证异步执行顺序-可以获取下级中间件的返回结果"><a href="#compose-尾触发模式执行中间件-保证异步执行顺序-可以获取下级中间件的返回结果" class="headerlink" title="compose: 尾触发模式执行中间件, 保证异步执行顺序, 可以获取下级中间件的返回结果"></a>compose: 尾触发模式执行中间件, 保证异步执行顺序, 可以获取下级中间件的返回结果</h4><p>中间件函数内部执行<code>await next()</code>就是执行了<code>await dispatch.bind(null, i + 1)</code>, <code>dispatch</code>方法返回一个<code>promise</code>, 并<code>return</code>了下层中间件方法的执行结果<code>fn(ctx, dispatch.bind(null, n + 1))</code>, 如此这般, 在本层中间件执行过程中可以拿到下层中间件的执行结果.</p>
<p><strong>在<code>async function</code>中<code>await</code>后的逻辑会在<code>await</code>后的<code>promise resolved</code>后再执行</strong>, 用这种”尾触发+async await”的模式实现了<code>&quot;洋葱模型&quot;</code>, 所有中间件的逻辑一层套一层, 异步顺序清晰明了.</p>
<p>为了兼容中间件函数不是<code>async function</code>, 在<code>return</code>中间件函数返回值时用了<code>promise.resolve</code>包裹, 保证了中间件中有同步函数时的异步执行顺序.</p>
<h4 id="compose-错误处理"><a href="#compose-错误处理" class="headerlink" title="compose: 错误处理"></a>compose: 错误处理</h4><p>由于中间件函数返回<code>promise</code>, <code>dispatch</code>也返回<code>promise</code>, 在<code>application.js</code>中的<code>app.handleRequest</code>方法中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .then可以获取 dispatch(0) resolved后的时间点, handleResponse可以获取修改后的ctx</span></span><br><span class="line"><span class="comment">// .catch可以拿到所有中间件嵌套执行时, async function产生的错误.</span></span><br><span class="line">fnMiddleware(ctx).then(handleResponse).catch(onerror)</span><br></pre></td></tr></table></figure>
<p>如注释所示, 外层调用<code>compose</code>方法返回的函数时, 可以获取返回的<code>promise</code>的错误. 为什么还要在<code>dispatch</code>中<code>try-catch</code>? </p>
<p>如果当前中间件方法不是<code>async function</code>, <code>promise</code>无法捕获同步方法中产生的错误, 所以这个<code>try-catch</code>是为了兼容同步的中间件写法的错误捕获.</p>
<p>综上, 我们分析了<code>compose</code>方法, 这个方法是<code>Koa</code>设计模式的精髓之一, 值得反复推敲.</p>
<h3 id="createContext-req-res-组装ctx"><a href="#createContext-req-res-组装ctx" class="headerlink" title="createContext(req, res), 组装ctx"></a>createContext(req, res), 组装ctx</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">createContext(req, res) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">  <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">  <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">  context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createContext</code>方法接收Node原生的<code>req</code>和<code>res</code>, 并以<code>request.js</code>, <code>response.js</code>, <code>context.js</code>三个模块导出的对象为原型对象, 使用原型继承创造了对应的对象, 用这些对象组装了<code>ctx</code>对象并返回.</p>
<p>这里有个大概印象即可, 在最后一节的解析中会详细分析此处的设计模式.</p>
<h3 id="Application-gt-handleRequest-ctx-fn"><a href="#Application-gt-handleRequest-ctx-fn" class="headerlink" title="Application -&gt; handleRequest(ctx, fn)"></a>Application -&gt; handleRequest(ctx, fn)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  res.statusCode = <span class="number">404</span>;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">  onFinished(res, onerror);</span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面两节回顾了<code>compose</code>和<code>createContext</code>的过程, 分别生成了<code>this.handleRequest</code>的两个参数. </p>
<p><code>handleRequest</code>方法先将响应状态设为<code>404</code>(如果响应结果不为404, 会在<code>respond</code>方法中更改), 定义错误处理函数<code>onerror</code>(内部调用<code>ctx.onerror</code>, 之后会详细解读), 然后通过<code>on-finished</code>库注册<code>onerror</code>方法, <code>on-Finished</code>库会在请求关闭或出错后调用<code>onerror</code>方法, 所以每次请求后<code>onerror</code>方法都会执行. <code>ctx.onerror</code>方法上来会判断:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>所以只要没有错误对象为<code>null</code>或者<code>undefined</code>, <code>ctx.onerror</code>的方法的逻辑实际不会执行.</p>
<p>继续来看<code>handleRequest</code>方法, 除了<code>onerror</code>方法, 还定义了<code>handleResponse</code>方法, 实际调用的是<code>respond</code>方法(下详), 最后调用<code>compose</code>组成的中间件洋葱函数, 按照<code>&quot;洋葱模型&quot;</code>的异步顺序执行并逐步改造参数<code>ctx</code>. <code>fnMiddleware</code>返回一个<code>promise</code>, 这个<code>promise</code>代表最外层中间件的执行状态, 用<code>respond</code>方法处理其<code>resolved</code>的状态, 如果中间件执行过程中出现错误, 用<code>onerror</code>处理错误.</p>
<h3 id="respond-在所有中间件执行结束后处理response"><a href="#respond-在所有中间件执行结束后处理response" class="headerlink" title="respond, 在所有中间件执行结束后处理response"></a>respond, 在所有中间件执行结束后处理response</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果在业务代码里显示的设置绕过koa的respond处理, return</span></span><br><span class="line">  <span class="comment">// allow bypassing koa</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> === ctx.respond) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ctx被设置为不可写, return</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.writable) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">const</span> code = ctx.status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用statuses库监测当前status是否不需要处理响应体, 如果是将响应体设置为null, 直接结束响应</span></span><br><span class="line">  <span class="comment">// ignore body</span></span><br><span class="line">  <span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">    <span class="comment">// strip headers</span></span><br><span class="line">    ctx.body = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是ctx的HEAD方法, 对响应头进行处理, 并直接结束响应</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'HEAD'</span> == ctx.method) &#123;</span><br><span class="line">    <span class="comment">// 如果未发送响应头, 且响应体是JSON, 对Content-Length进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码(其实是一种体验升级)。</span></span><br><span class="line">  <span class="comment">// status body</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == body) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.req.httpVersionMajor &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      body = <span class="built_in">String</span>(code);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当响应头未发送时设置Content-Type与Content-Length(因为res.write可以多次)：</span></span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">      <span class="comment">// ctx.type代理的是设置Content-type的方法</span></span><br><span class="line">      <span class="comment">// ctx.length代理的是设置Content-length的方法</span></span><br><span class="line">      ctx.type = <span class="string">'text'</span>;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对不同响应体进行处理</span></span><br><span class="line">  <span class="comment">// responses</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="comment">// 如果未发送响应头</span></span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>respond</code>方法是在中间件处理<code>resolved</code>后处理<code>response</code>的过程. 我们来看一下他的具体逻辑</p>
<p>如果在中间件处理的过程中曾显式的注明了<code>ctx.respond = false</code>, 则代表需要跳过<code>koa</code>的<code>response</code>处理过程, 直接<code>return</code></p>
<p>如果<code>ctx</code>曾被设置为不可写, <code>return</code></p>
<p>之后, 用<code>statuses</code>库判断当前的<code>status code</code>是否是不需要响应体的类型, 如果是直接将响应体置空, 并结束响应. </p>
<p>继续对<code>HEAD</code>方法做特殊处理, 如果响应头已发送, 响应体是<code>JSON</code>, 计算响应体长度后结束响应.</p>
<p>然后处理<code>status</code>可以有响应体的情况，当响应体为空时，将响应体设置为响应信息或状态码(其实是一种体验优化)。并当响应头未发送时设置<code>Content-Type</code>与<code>Content-Length</code></p>
<p>最后对不同类型的响应做处理后返回.</p>
<h3 id="Context-onerror"><a href="#Context-onerror" class="headerlink" title="Context.onerror"></a>Context.onerror</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">onerror(err) &#123;</span><br><span class="line">  <span class="comment">// don't do anything if there is no error.</span></span><br><span class="line">  <span class="comment">// this allows you to pass `this.onerror`</span></span><br><span class="line">  <span class="comment">// to node-style callbacks.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当err为null或undefined时直接return, 否则创造异常对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> <span class="built_in">Error</span>)) err = <span class="keyword">new</span> <span class="built_in">Error</span>(util.format(<span class="string">'non-error thrown: %j'</span>, err));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果响应头已发送或响应不可写(无法在响应中写入错误信息), 则退出该函数</span></span><br><span class="line">  <span class="keyword">let</span> headerSent = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.headerSent || !<span class="keyword">this</span>.writable) &#123;</span><br><span class="line">    headerSent = err.headerSent = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate</span></span><br><span class="line">  <span class="comment">// 触发app的error事件, 将错误抛给外层业务</span></span><br><span class="line">  <span class="keyword">this</span>.app.emit(<span class="string">'error'</span>, err, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nothing we can do here other</span></span><br><span class="line">  <span class="comment">// than delegate to the app-level</span></span><br><span class="line">  <span class="comment">// handler and log.</span></span><br><span class="line">  <span class="keyword">if</span> (headerSent) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; res &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// first unset all headers</span></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为发生了错误, 将所有在中间件执行过程中的响应头清空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> res.getHeaderNames === <span class="string">'function'</span>) &#123;</span><br><span class="line">    res.getHeaderNames().forEach(<span class="function"><span class="params">name</span> =&gt;</span> res.removeHeader(name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res._headers = &#123;&#125;; <span class="comment">// Node &lt; 7.7</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then set those specified</span></span><br><span class="line">  <span class="comment">// 清空response头后将头设置为错误头</span></span><br><span class="line">  <span class="keyword">this</span>.set(err.headers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// force text/plain</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ENOENT support</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'ENOENT'</span> == err.code) err.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default to 500</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'number'</span> != <span class="keyword">typeof</span> err.status || !statuses[err.status]) err.status = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理错误的status和msg并返回</span></span><br><span class="line">  <span class="comment">// respond</span></span><br><span class="line">  <span class="keyword">const</span> code = statuses[err.status];</span><br><span class="line">  <span class="keyword">const</span> msg = err.expose ? err.message : code;</span><br><span class="line">  <span class="keyword">this</span>.status = err.status;</span><br><span class="line">  <span class="keyword">this</span>.length = Buffer.byteLength(msg);</span><br><span class="line">  res.end(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当中间件处理函数结果的<code>promise</code>被<code>resolved</code>后, 调用<code>respond</code>方法处理<code>response</code>. 并行的, 如果<code>promise</code>被<code>reject</code>, <code>ctx.onerror</code>用来处理中间件处理环节中的错误</p>
<p>当<code>err</code>是<code>null</code>或<code>undefined</code>时, 直接<code>return</code>, 否则创建一个错误对象.</p>
<p>首先将<code>err</code>抛给上层业务的<code>error</code>事件处理, 如果响应头已发送或响应不可写, 退出错误处理逻辑.</p>
<p>之后将所有被设置过的响应头清空并设置错误的响应头, 设置返回错误的<code>Content-type</code>是<code>text</code>, 设置默认错误码为500, 最后处理<code>status</code>和<code>message</code>并结束响应.</p>
<h3 id="Context-Request-Response模块"><a href="#Context-Request-Response模块" class="headerlink" title="Context, Request, Response模块"></a>Context, Request, Response模块</h3><h4 id="instance-request-严谨的二重防止污染逻辑"><a href="#instance-request-严谨的二重防止污染逻辑" class="headerlink" title="instance/request, 严谨的二重防止污染逻辑"></a>instance/request, 严谨的二重防止污染逻辑</h4><p>下面分析<code>Context</code>, <code>Request</code>, <code>Response</code>模块的设计模式, 先回忆下<code>koa</code>中与这三个模块相关的主流程方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">  <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">  <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">&#125;</span><br><span class="line">createContext(req, res) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">  <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">  <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">  context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line">callback() &#123;</span><br><span class="line">  <span class="comment">// 每个应用的compose方法只执行一次</span></span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listenerCount(<span class="string">'error'</span>)) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line">  <span class="comment">// handleRequest方法每个请求都会执行一次</span></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然, <code>koa</code>对<code>context</code>, <code>request</code>, <code>response</code>进行了两次原型继承, 第一次在<code>constructor</code>中, 第二次在<code>createContext</code>中. 为什么要进行两次原型继承? </p>
<p><code>createContext</code>方法是在<code>http.createServer</code>中执行的, 在一个<code>Koa</code>应用中, <code>http.createServer</code>只会执行一次, 所以<code>callback</code>方法只会执行一次, <code>compose</code>方法是组合中间件函数的过程, 也只执行一次. 但<code>handleRequest</code>方法却是每个请求进入时都会执行一次. 如此设计, 每个请求都会生成自己的<code>ctx</code>对象, 所以, 在<code>createContext</code>方法中进行第二次原型继承, 可以保证<code>this.context</code>, <code>this.response</code>, <code>this.request</code>不会在请求间被污染.</p>
<p>下面来思考下第一次继承的意义, 由于<code>Node</code>的<code>require</code>方法会缓存加载的对象, 所以第一次原型继承是为了多次<code>new Koa</code>时, <code>koa</code>实例间的三种对象的原型(<code>require(&quot;./request&quot;)</code>, <code>require(&quot;./response&quot;)</code>, <code>require(&quot;./request&quot;)</code>)不被污染. 在一个项目的多个依赖包都同时依赖了<code>koa</code>时, 有可能出现这种污染的情况. 读到这里时不禁佩服作者思维之严谨.</p>
<h3 id="context对象的构建过程"><a href="#context对象的构建过程" class="headerlink" title="context对象的构建过程"></a>context对象的构建过程</h3><p>最后, 我们来分析下<code>ctx</code>对象的构建过程, <code>koa</code>对其进行了两层代理</p>
<h4 id="getter-setter-实现到原生req-res的第一层代理"><a href="#getter-setter-实现到原生req-res的第一层代理" class="headerlink" title="getter, setter 实现到原生req, res的第一层代理"></a>getter, setter 实现到原生req, res的第一层代理</h4><p>这里用<code>request</code>举例, <code>response</code>和<code>request</code>的实现方式接近, 不再赘述.</p>
<p><code>request.js</code>文件向外返回了<code>this.request</code>的原型对象, 其分别用<code>getter</code>和<code>setter</code>代理了<code>this.req</code>的属性. 在<code>createContext</code>方法中: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createContext方法中</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context)</span><br><span class="line"><span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request)</span><br><span class="line"><span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response)</span><br><span class="line">context.req = request.req = response.req = req;</span><br><span class="line">context.res = request.res = response.res = res;</span><br></pre></td></tr></table></figure>
<p>这样, <code>req</code>以属性的形式绑定到了<code>request</code>对象上, 在<code>request.js</code>中, 以<code>url</code>属性为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  get url() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.req.url</span><br><span class="line">  &#125; </span><br><span class="line">  set url(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.req.url = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此, 在读写<code>request.url</code>时, 实际会对<code>req.url</code>进行读写, 以此完成了第一层代理.</p>
<h4 id="delegate-第二层代理"><a href="#delegate-第二层代理" class="headerlink" title="delegate 第二层代理"></a>delegate 第二层代理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createContext方法中</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line"><span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line"><span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br></pre></td></tr></table></figure>
<p>在<code>createContext</code>方法中, <code>request</code>和<code>response</code>对象实际绑定到了<code>context</code>的对应属性下, 作者使用了<code>delegates</code>库让<code>context</code>代理<code>request</code>和<code>response</code>下的各种方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delegate(proto, <span class="string">'response'</span>)</span><br><span class="line">  .method(<span class="string">'redirect'</span>)</span><br><span class="line">  .access(<span class="string">'status'</span>)</span><br><span class="line">  .getter(<span class="string">'writable'</span>);</span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">'request'</span>)</span><br><span class="line">  .method(<span class="string">'accepts'</span>)</span><br><span class="line">  .access(<span class="string">'querystring'</span>)</span><br><span class="line">  .getter(<span class="string">'href'</span>)</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>delegates</code>库的实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">Delegator</span>(<span class="params">proto, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Delegator)) <span class="keyword">return</span> <span class="keyword">new</span> Delegator(proto, target)</span><br><span class="line">  <span class="keyword">this</span>.proto = proto</span><br><span class="line">  <span class="keyword">this</span>.target = target</span><br><span class="line">  <span class="keyword">this</span>.methods = []</span><br><span class="line">  <span class="keyword">this</span>.getters = []</span><br><span class="line">  <span class="keyword">this</span>.setters = []</span><br><span class="line">  <span class="keyword">this</span>.fluents = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Delegator.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> proto = <span class="keyword">this</span>.proto</span><br><span class="line">  <span class="keyword">var</span> target = <span class="keyword">this</span>.target</span><br><span class="line">  <span class="keyword">this</span>.methods.push(name)</span><br><span class="line">  proto[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[target][name].apply(<span class="keyword">this</span>[target], <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Delegator.prototype.access = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getter(name).setter(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Delegator.prototype.getter = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> proto = <span class="keyword">this</span>.proto</span><br><span class="line">  <span class="keyword">var</span> target = <span class="keyword">this</span>.target</span><br><span class="line">  <span class="keyword">this</span>.getters.push(name)</span><br><span class="line">  proto.__defineGetter__(name, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[target][name]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Delegator.prototype.setter = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> proto = <span class="keyword">this</span>.proto</span><br><span class="line">  <span class="keyword">var</span> target = <span class="keyword">this</span>.target</span><br><span class="line">  <span class="keyword">this</span>.setters.push(name)</span><br><span class="line">  proto.__defineSetter__(name, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[target][name] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delegator</code>构造函数会稳定的返回一个<code>Delegator</code>实例. <code>method</code>方法让被代理对象命名空间下的方法以被代理对象为上下文执行. <code>getter</code>和<code>setter</code>方法用于返回和设置被代理对象上的属性. <code>access</code>方法用于同时注册<code>getter</code>和<code>setter</code>.</p>
<p>经过第二重代理, context对象的结构如下图所示:</p>
<p><img src="https://i.loli.net/2019/07/22/5d355d71330b888111.png" alt="context对象"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Koa</code>的代码短小精悍, 其中蕴含了大量值得推敲的设计和实现. 是围绕我们工作的周边生态链中, 最值得研读的库之一. 不积跬步, 无以至千里, 希望自己可以在学习中不断进步. </p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/22/vue-source-18/" class="next">上一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>