<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vue源码解读 18 - 组件更新 · choteewang</title><meta name="description" content="Vue源码解读 18 - 组件更新 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vue源码解读 18 - 组件更新</h1><div class="post-info">2019年10月22日</div><div class="post-content"><p>本节来分析组件更新的过程.</p>
<p>前面的章节我们分析了, <code>updateComponent</code>方法内部调用了<code>vm._update(vm._render())</code>, 而<code>updateComponent</code>方法是作为<code>render watcher</code>的<code>getter</code>传入的, 当数据发生变化时, 作为变化数据依赖的<code>render watcher</code>会重新计算, 执行<code>updateComponent</code>就会调用. 在<code>nextTick</code>执行.</p>
<p>这个过程首先会执行<code>vm._render</code>方法, 它的目的是从新生成一个<code>vnode</code>, 然后执行<code>vm._update</code>并传入这个<code>new vnode</code>, 将<code>new vnode</code>更新到页面dom上去(<code>patch</code>的过程).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="comment">// prevVnode存在, 是渲染vnode</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  <span class="comment">// 把渲染vnode赋值给下划线vnode</span></span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// else 对应数据改变</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组件更新时, 参数<code>vnode</code>是<code>render</code>函数生成的<code>vnode</code>, 此时<code>prevVnode</code>是<code>render vnode</code>, 会执行<code>vm.$el=vm.__patch__(prevVnode, vnode)</code>, 我们继续看看<code>patch</code>方法的实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不是原生节点, 都是vnode, isRealElement为false</span></span><br><span class="line">    <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">    <span class="comment">// 比对新旧vnode节点 -&gt; sameVnode方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      <span class="comment">// patch existing root node</span></span><br><span class="line">      <span class="comment">// 新旧vnode节点是同一个vnode, 走patchVnode方法</span></span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新旧节点不是同一个vnode,走这里</span></span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// replacing existing element</span></span><br><span class="line">      <span class="comment">// 第一步, 创新新的节点</span></span><br><span class="line">      <span class="comment">// 通过旧节点的dom节点拿到父dom节点</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create new node</span></span><br><span class="line">      <span class="comment">// 将新节点和父dom节点传入</span></span><br><span class="line">      <span class="comment">// 这样createElm逻辑就知道创建的节点应该挂载在父dom的下面</span></span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">      <span class="comment">// 第二步, 更新父占位符节点</span></span><br><span class="line">      <span class="comment">// vnode是App组件模板的最外层div的dom, vnode.parent是占位符节点&lt;App /&gt;</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="comment">// 保存 &lt;App /&gt;</span></span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">        <span class="comment">// 判断当前vnode节点是否是可挂载的 -&gt; isPatchable</span></span><br><span class="line">        <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          <span class="comment">// 执行&lt;App/&gt;的snabdom destroy钩子</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">            cbs.destroy[i](ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将占位符节点的elm赋值为新vnode的elm(createElm生成的真实dom)</span></span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">            <span class="comment">// 可挂载的话 执行create钩子和insert钩子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">              cbs.create[i](emptyNode, ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// #6513</span></span><br><span class="line">            <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">            <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">            <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">            <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">              <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                insert.fns[i]()</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerRef(ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将ancester指向&lt;App/&gt;的父节点, 递归向上找</span></span><br><span class="line">          <span class="comment">// (假设&lt;App/&gt;的父占位符节点还是一个组件&lt;Bpp/&gt;, 继续进行while里面的逻辑)</span></span><br><span class="line">          <span class="comment">// 重复更新父占位符节点过程, 直到&lt;App/&gt;的外层直接套一个div而不是自定义组件节点</span></span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// destroy old node</span></span><br><span class="line">      <span class="comment">// 第三步, 删除旧的节点  </span></span><br><span class="line">      <span class="comment">// 如果父dom节点存在, 从父dom节点里删除oldVnode对应的节点      </span></span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>patch</code>方法的逻辑比较复杂, 我们慢慢分析. 此时<code>oldVnode</code>存在, 进入else逻辑, <code>isRealElement</code>为<code>false</code>.<br>此时会判断<code>sameVnode(oldVnode, vnode)</code>, 如果真, 证明<code>oldVnode</code>和<code>vnode</code>是同一节点, 进入<code>patchVnode</code>逻辑. 如果假, <code>oldVnode</code>和<code>vnode</code>是不是同一节点, 需新增节点替换旧借点. </p>
<p>先看看<code>sameVnode</code>逻辑, <code>sameVnode</code>用来判断两个<code>vnode</code>是否是同一个节点, 逻辑注释所示. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// key要相等(vfor的key)</span></span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    <span class="comment">// tag要相等, 是不是注释借点相等, data是否都定义了相等, 是不是同样的input类型要相等</span></span><br><span class="line">    ((a.tag === b.tag &amp;&amp;</span><br><span class="line">      a.isComment === b.isComment &amp;&amp;</span><br><span class="line">      isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">      sameInputType(a, b)) ||</span><br><span class="line">      (isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们先假设<code>oldVnode</code>和<code>vnode</code>不是同一个节点, 进入else逻辑, 首先需要创建新的节点, 步骤如下:</p>
<ol>
<li>先根据<code>oldVnode</code>挂载的<code>elm</code>得到父dom元素<code>parentElm</code></li>
<li>执行<code>createElm</code>, 因为传入了父dom元素, 于是新建的元素被挂载在父dom元素下, 旧dom元素的<code>nextSibling</code></li>
</ol>
<p>第二步,需要更新父占位符节点, 先获取<code>ancestor</code>, 其值<code>vnode.parent</code>对应类<code>&lt;App/&gt;</code>这样的占位Vnode, 然后判断一个节点<code>isPatchable</code>, 该方法逻辑如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个vnode是否为可挂载的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPatchable</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果vnode有componentInstance方法, 证明是一个占位符vnode(&lt;App/&gt;)</span></span><br><span class="line">  <span class="keyword">while</span> (vnode.componentInstance) &#123;</span><br><span class="line">    <span class="comment">// 将vnode赋值为组件vnode的渲染vnode(&lt;App/&gt;的template最外层div), 循环判断</span></span><br><span class="line">    vnode = vnode.componentInstance._vnode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直到找到一个占位符vnode的模板最外层节点不是占位符, 而是一个真实html标签(div), 则当前节点为可挂载节点</span></span><br><span class="line">  <span class="keyword">return</span> isDef(vnode.tag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下<code>isPatchable</code>方法, 如果<code>vnode.componentInstance</code>存在证明该方法是一个占位符vnode(<code>&lt;App/&gt;</code>), 继续找到该占位符vnode的<code>render watcher</code>, 如此递归一直找到<code>vnode</code>最外层不是占位符<code>vnode</code>, 而是一个<code>html</code>标签, 则当前节点为可挂载节点</p>
<p>回到<code>patch</code>方法逻辑, 进入<code>while</code>逻辑, 步骤如下:</p>
<ol>
<li>执行<code>snabbdom</code>的<code>destroy</code>钩子</li>
<li>将占位符节点的<code>elm</code>赋值为新<code>vnode</code>的<code>elm</code>(<code>createElm</code>生成的真实dom)</li>
<li>如果<code>vnode``isPatchable</code>, 执行<code>snabbdom</code>的<code>create</code>和<code>insert</code>钩子</li>
<li>将<code>ancester</code>指向<code>&lt;App/&gt;</code>的父节点, 递归向上找, 重复更新父占位符节点的<code>elm</code>属性的过程, 直到<code>&lt;App/&gt;</code>外层直接套一个html元素而不是自定义组件节点为止.</li>
</ol>
<p>在完成更新父占位符节点后, 还要删除掉之前的旧<code>vnode</code>节点对应的dom, 完成dom更新. 至此, <code>oldVnode</code>和<code>vnode</code>不是同一个节点的逻辑更新完毕.</p>
<p>我们再假设<code>oldVnode</code>和<code>vnode</code>是同一个节点, 此时进入<code>patchVnode</code>逻辑:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新节点 = 旧借点 return</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取旧vnode的dom节点赋值给新vnode(因为新旧节点相同)</span></span><br><span class="line">  <span class="keyword">const</span> elm = (vnode.elm = oldVnode.elm)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步组件的情况, 可跳过</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reuse element for static trees.</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="comment">// 如果vnode定义了data, 且定义了data.hook.prepatch方法, 执行prepatch方法 -&gt; prepatch方法</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) &#123;</span><br><span class="line">    <span class="comment">// 执行prepatch方法</span></span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿新vnode的children</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 执行update钩子</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update))) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch)</span><br><span class="line">        <span class="comment">// 如果新旧节点的children不一样(同一个vnode, 下面子节点的内容换了), 执行updateChildren(diff算法, 内部递归调用updateChildren)</span></span><br><span class="line">        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果新节点有children老节点没有, 将新children插入即可</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 旧节点有children但新节点没有, 从旧借点处删除旧children</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果新节点没有children, 老节点也没有children, 但老节点有文本节点, 将其置空</span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果有文本节点且文本节点内容更新, 设置文本节点</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行postpatch钩子</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch))) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>patchVnode</code>因为在处理同一个<code>vnode</code>的更新前后的异同, 实际是在执行<code>diff算法</code>的过程.</p>
<p>首先直接取旧<code>vnode</code>的dom节点赋值给新<code>vnode</code>(因为新旧节点相同), 之后执行<code>prepatch</code>方法, 先来看看<code>prepatch</code>的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line">prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedComponentVNode) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">  <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">  <span class="comment">// 执行updateChildComponent方法, 更新组件内组件的props 事件等</span></span><br><span class="line">  <span class="comment">// 所以在更新父组件内部的data时, 可以触发父组件data传入子组件作为props时, 子组件的更新</span></span><br><span class="line">  <span class="comment">// 因为这里updateChildComponent会触发对应的子组件props的setter,从而触发子组件的更新</span></span><br><span class="line">  updateChildComponent(</span><br><span class="line">    child,</span><br><span class="line">    options.propsData, <span class="comment">// updated props</span></span><br><span class="line">    options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">    vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">    options.children <span class="comment">// new children</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepatch</code>方法主要调用<code>updateChildComponent</code>, 根据<code>vnode</code>数据的改变更新子组件<code>props</code>, <code>listeners</code>等. 所以在父组件<code>vnode</code>的数据项通过<code>setter</code>发生改变后, 才会触发子组件<code>props</code>等连锁更改, 都是这里触发的逻辑.</p>
<p>回到<code>patchVnode</code>方法, 拿到新旧<code>vnode</code>的<code>children</code>, 先执行<code>snabbdom</code>的<code>update</code>钩子, 然后开始一连串更新逻辑:</p>
<ol>
<li>如果<code>vnode</code>有文本节点, 且文本节点内容更新, 调用<code>dom</code>方法更新文本节点内容</li>
<li>如果<code>vnode</code>没有文本节点, 分类讨论<ul>
<li>如果新旧节点的<code>children</code>不一样(同一个<code>vnode</code>, 下面子节点的内容换了), 执行<code>updateChildren</code>, 该方法内部使用<code>diff</code>算法, 高效的更新dom</li>
<li>如果新节点有<code>children</code>老节点没有, 将新<code>children</code>插入即可</li>
<li>如果旧节点有<code>children</code>但新节点没有, 删除旧借点下的旧<code>children</code></li>
<li>如果新节点没有<code>children</code>, 老节点也没有<code>children</code>, 但老节点有文本节点, 将其置空</li>
</ul>
</li>
</ol>
<p>至此 我们分析了组件更新时, <code>render watcher</code>的<code>getter</code>(<code>vm._update(vm._render())</code>)执行过程中, <code>Vue.js</code>内部的更新逻辑.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/02/vue-source-17/" class="next">上一篇</a><a href="/2019/10/29/koa源码解读/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>