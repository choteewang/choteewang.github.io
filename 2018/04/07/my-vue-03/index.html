<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 模拟Vue.js的设计模式实现 (三): Observer类 & Watcher类 · choteewang</title><meta name="description" content="模拟Vue.js的设计模式实现 (三): Observer类 &amp; Watcher类 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li><li class="nav-list-item"><a href="https://github.com/choteewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">模拟Vue.js的设计模式实现 (三): Observer类 & Watcher类</h1><div class="post-info">2018年4月7日</div><div class="post-content"><p><a href="https://choteewang.github.io/2018/04/03/my-vue-2/" target="_blank" rel="noopener">上篇博客</a>解释了<code>Vue</code>进行数据代理的过程和<code>Dep</code>类的实现模式, 循着上篇留下的问题: <code>dep</code>实例与外界是如何交互的? 我们开始本篇.</p>
<p>这个小项目的源码的<code>github</code>地址是: <a href="https://github.com/choteewang/my-vue" target="_blank" rel="noopener">https://github.com/choteewang/my-vue</a></p>
<h3 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h3><p>在之前的<code>index.js</code>中<code>Vue</code>的构造函数中添加调用<code>observer</code>方法的代码, 并将<code>vm.data</code>传入. 需要注意的是在执行这行代码时, 已经执行了<code>vm.init</code>方法, 将<code>data</code>对象的数据通过<code>vm.proxyKeys</code>代理到了<code>vm</code>实例上.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = options.data</span><br><span class="line">  <span class="keyword">this</span>.el = options.el</span><br><span class="line">  <span class="keyword">this</span>.methods = options.methods</span><br><span class="line">  <span class="keyword">this</span>.init(<span class="keyword">this</span>.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化observer,为vm.data添加观察者模式</span></span><br><span class="line">  observe(<span class="keyword">this</span>.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>observer.js</code>, 添加<code>observer</code>方法的代码, 它首先检测传入的<code>data</code>对象是否是一个对象(<strong>需要检测的原因是该函数在后面的代码中会被递归调用, 有可能传入一个不是对象的基本类型</strong>), 并将<code>data</code>传递给<code>Observer</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查data参数是否是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将data传入Observer构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来完成<code>Observer</code>构造函数和其原型, <code>observer</code>实例有一个<code>walk</code>方法, 它遍历了传入的<code>data</code>对象, 并将<code>key</code>与<code>value</code>传入<code>observer</code>实例的<code>defineReactive</code>方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.walk(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  walk: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      self.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... Dep类代码</span></span><br></pre></td></tr></table></figure>
<p>下面我们完成<code>defineReactive</code>方法, 这个方法非常重要, 设计也十分巧妙, 是<code>Vue</code>响应式设计模式的核心方法, 我们需要对其进行详细解读</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意参数val是原始数据对象data中的属性key的值data[key]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个Dep(Dependency)</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 对data中的key设置get, set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 调用getter时添加依赖项到dep实例</span></span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          <span class="comment">// 注意dep是通过闭包访问到的</span></span><br><span class="line">          dep.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意val是通过闭包访问到的</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 调用setter时通知所有依赖data[key]的项进行更新</span></span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 比较新旧值(注意旧值val是通过闭包获取的)</span></span><br><span class="line">        <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">          <span class="comment">// 更新data[key]的值</span></span><br><span class="line">          <span class="comment">// 注意val值是通过闭包访问到的</span></span><br><span class="line">          val = newVal</span><br><span class="line">          <span class="comment">// 通知所有依赖进行更新</span></span><br><span class="line">          <span class="comment">// 注意dep是通过闭包访问到的</span></span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 递归调用observer,保证data[key]的子孙也都添加了监听与dep</span></span><br><span class="line">    observe(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defineReactive</code>是一个经典的闭包设计, 闭包主要维护了两个变量: </p>
<ol>
<li><code>val</code>, 是<code>data[key]</code>的值</li>
<li><code>dep</code>, 是<code>Dep</code>的实例, 由于闭包逻辑的关联, <strong>每个<code>dep</code>实例形成了与<code>data[key]</code>的关联</strong></li>
</ol>
<p>由于<code>Object.definePropery</code>定义的<code>getter</code>与<code>setter</code>存在对其的引用, 形成闭包, <strong>无论何时调用<code>getter</code>与<code>setter</code>, <code>val</code>和<code>dep</code>都可以被<code>getter</code>和<code>setter</code>访问到</strong>. 方法尾部对<code>data[key]</code>继续调用了<code>observe</code>方法, 形成了递归调用, 保证了<strong><code>data</code>中任何一层的任意一个数据项都有一个对应的<code>dep</code>实例与之相对应</strong>.</p>
<p>我们可以先忽略<code>getter</code>与<code>setter</code>内部与<code>Dep.target</code>,<code>dep</code>实例之间存在的具体逻辑, 下面介绍<code>Watcher</code>对象后, 这些逻辑会逐渐清晰. 现在可以简单理解为<code>getter</code>用来返回<code>data[key]</code>的值, <code>setter</code>用来设置<code>data[key]</code>的值, 重点是要理解每一项<code>data[key]</code>都有一个<code>dep</code>与之对应.</p>
<h3 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h3><p>带着上面未完成的问题: <code>getter</code>与<code>setter</code>到底如何与<code>dep</code>, <code>Dep.target</code>交互的, 我们需要在<code>watcher.js</code>中完成<code>Watcher</code>类</p>
<p><code>Watcher</code>的构造函数接收三个参数, <code>vm</code>实例, <code>exp</code>表示编译时从模板传入的<code>js表达式</code>( 在本项目中, 不支持所有<code>js</code>表达式, 可以看做是代理到<code>vm</code>实例上的<code>data</code>中某个<code>key</code>的值在<code>Vue template</code>中的表达式, 比如<code>vm.a</code>代理的是<code>vm.data.a</code>, 它的表达式在<code>Vue template</code>中是<code>a</code>, 但是<code>a.toString()</code>在本项目中没有做处理 ), <code>cb</code>是编译<code>Vue template</code>时传入的回调函数, 用来绑定<code>watcher</code>与对应的<code>data[key]</code>, 它在<code>watcher</code>依赖项被通知需”更新”(<code>update</code>)时被调用.</p>
<p>现在我们忽略<code>cb</code>的具体实现, 只单纯的理解为<code>cb</code>是用来更新依赖项用于<code>Vue re-render</code>的, 在<code>vm</code>,<code>exp</code>,<code>cb</code>三个参数被代理到<code>watcher</code>实例上后, <code>watcher</code>执行<code>get</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm <span class="comment">// vm实例</span></span><br><span class="line">  <span class="keyword">this</span>.exp = exp <span class="comment">// 相当于vm.data[key]中的key值</span></span><br><span class="line">  <span class="keyword">this</span>.cb = cb <span class="comment">// 数据更新后用于更新视图的回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.val = <span class="keyword">this</span>.get() <span class="comment">// this.val是data[key]的当前值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法是继<code>defineReactive</code>后, 又一个<code>Vue</code>设计模式的重要方法, 了解它调用的时机和作用至关重要. 要谨记, <strong><code>watcher.get</code>方法是在每个<code>watcher</code>被实例化时调用的</strong>, 它的返回值是对应的<code>vm.data[key]</code>值, 并被保存在<code>watcher.val</code>中. 我们看看它是如何取到值的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  <span class="comment">// new Watcher时候调用get方法</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 设置Dep.target静态属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发data[key]的getter函数</span></span><br><span class="line">    <span class="comment">// 通过闭包得到dep实例</span></span><br><span class="line">    <span class="comment">// 执行dep.addSub(Dep.target)收集依赖</span></span><br><span class="line">    <span class="comment">// 通过闭包返回data[key]值(val参数)</span></span><br><span class="line">    <span class="keyword">var</span> val = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp]</span><br><span class="line"></span><br><span class="line">    Dep.target = <span class="literal">null</span> <span class="comment">// 清空Dep.target占用</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法内部, 先将前面注意到的<code>Dep</code>的静态属性<code>Dep.target</code>赋值为<code>watcher</code>实例自己, 然后读取<code>vm.data[key]</code>的值, 这会触发之前学习的<code>defineReactive</code>中的<code>getter</code>并返回<code>data[key]</code>的最新值, <code>get</code>方法的返回值被赋值给<code>watcher.val</code>, <code>Dep.target</code>在获取值后被重新设置为<code>null</code>, 方便下次单例模式调用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js中的defineReactive方法</span></span><br><span class="line">defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 对data中的key设置get, set</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 注意dep是通过闭包访问到的</span></span><br><span class="line">      dep.addSub(Dep.target)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 注意val是通过闭包访问到的</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>watcher.get</code>方法读取<code>vm.data[key]</code>的值时, <code>defineReactive</code>方法中的<code>getter</code>被触发, 它先判断<code>Dep.target</code>是否存在(已被赋值为<code>watcher</code>), 再<strong>通过闭包获取与<code>data[key]</code>对应的<code>dep</code></strong>, 将<code>watcher</code>添加入<code>dep</code>内部维护的<code>subs</code>订阅者列表, 最后<strong>通过闭包返回对应的data[key]的最新值</strong>, 这个过程被称之为”依赖收集”(<code>collect Dependency</code>)</p>
<p><code>watcher</code>被实例化的同时, <code>Vue.js</code>同时进行了依赖收集. 理解这一点对后续理解模板编译(<code>compile</code>)至关重要. 下面我们看看<code>watcher</code>被收集后是如何进行更新(<code>update</code>)的. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用setter时通知所有依赖data[key]的项进行更新</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 比较新旧值(注意旧值val是通过闭包获取的)</span></span><br><span class="line">      <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="comment">// 更新data[key]的值, 也就是闭包中的参数变量val</span></span><br><span class="line">        <span class="comment">// 此值在调用data[key]的setter时被闭包读取返回</span></span><br><span class="line">        val = newVal</span><br><span class="line">        <span class="comment">// 通知所有依赖进行更新</span></span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">      watcher.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给<code>vm[key]</code>赋值时会触发<code>vm.data[key]</code>的<code>setter</code>, 它<strong>先通过闭包获取<code>data[key]</code>的缓存值</strong>, 与<code>setter</code>接收的参数进行比较, 若值已更新, <strong>通过闭包获取<code>dep</code>实例</strong>, 调用<code>dep</code>的<code>notify</code>方法. <code>dep.notify</code>方法调用所有<code>subs</code>数组中所有<code>data[key]</code>的<code>watcher</code>依赖项, 执行他们各自的<code>update</code>方法. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  <span class="comment">// 依赖项需更新时调用update方法</span></span><br><span class="line">  update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最新值</span></span><br><span class="line">    <span class="keyword">var</span> newVal = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp]</span><br><span class="line">    <span class="comment">// 获取缓存值</span></span><br><span class="line">    <span class="keyword">var</span> oldVal = <span class="keyword">this</span>.val</span><br><span class="line">    <span class="keyword">if</span> (newVal !== oldVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val = newVal <span class="comment">// 更新缓存值</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行回调,用于re-render</span></span><br><span class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, newVal, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>watcher.updater</code>方法中, 先通过<code>data[key]</code>的<code>getter</code>拿到最新值, 然后获取上一次调用<code>getter</code>时缓存在<code>wathcer.val</code>中的缓存值, 若需要更新, 调用存储在<code>watcher.cb</code>中的回调函数, 它也是在<code>watcher</code>实例化时绑定的. 最后, 为了模拟使用<code>Vue.js</code>开发时的写法(在<code>methods</code>中可以用<code>this</code>指向<code>vm</code>实例, 在<code>watch</code>的参数中可以获取<code>newVal</code>和<code>oldVal</code>), 我们给<code>cb</code>绑定上下文<code>vm</code>, 并传入最新值和缓存值.</p>
<p>到目前为止, 还不用太关心<code>re-render</code>的过程, 很明显, 它们是被封装在<code>cb</code>中的, 在下篇会模拟<code>Vue.js</code>编译模板(<code>Compile</code>)的过程, 更多细节将在到时讨论.</p>
<p>下面先附上<code>observer.js</code>和<code>watcher.js</code>的完整代码</p>
<h3 id="observer-js-与-watcher-js-完整代码"><a href="#observer-js-与-watcher-js-完整代码" class="headerlink" title="observer.js 与 watcher.js 完整代码"></a>observer.js 与 watcher.js 完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js完整代码</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意参数val是原始数据对象data中的属性key的值data[key]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个Dep(Dependency)</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 对data中的key设置get, set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 调用getter时添加依赖项到dep实例</span></span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          <span class="comment">// 注意dep是通过闭包访问到的</span></span><br><span class="line">          dep.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意val是通过闭包访问到的</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 调用setter时通知所有依赖data[key]的项进行更新</span></span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 比较新旧值(注意旧值val是通过闭包获取的)</span></span><br><span class="line">        <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">          <span class="comment">// 更新data[key]的值</span></span><br><span class="line">          <span class="comment">// 注意val值是通过闭包访问到的</span></span><br><span class="line">          val = newVal</span><br><span class="line">          <span class="comment">// 通知所有依赖进行更新</span></span><br><span class="line">          <span class="comment">// 注意dep是通过闭包访问到的</span></span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 递归调用observer,保证data[key]的子孙也都添加了监听与dep</span></span><br><span class="line">    observe(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js完整代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.walk(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  walk: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      self.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意参数val是原始数据对象data中的属性key的值data[key]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个Dep(Dependency)</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 对data中的key设置get, set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 调用getter时添加依赖项到dep实例</span></span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          dep.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 调用setter时通知所有依赖data[key]的项进行更新</span></span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 比较新旧值(注意旧值val是通过闭包获取的)</span></span><br><span class="line">        <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">          <span class="comment">// 更新data[key]的值, 也就是闭包中的参数变量val</span></span><br><span class="line">          <span class="comment">// 此值在调用data[key]的setter时被闭包读取返回</span></span><br><span class="line">          val = newVal</span><br><span class="line">          <span class="comment">// 通知所有依赖进行更新</span></span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用observer,保证data[key]的子孙也都添加了监听与dep</span></span><br><span class="line">    observe(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个Dep实例对应一个对应的data[key]依赖</span></span><br><span class="line">  <span class="comment">// 内部维护一个依赖列表subs,每项是一个watcher实例</span></span><br><span class="line">  <span class="comment">// 每个watcher实例都是一个data[key]的依赖项</span></span><br><span class="line">  <span class="comment">// 这些watcher可能是Vue的template中绑定vm.a的位置</span></span><br><span class="line">  <span class="comment">// 此外,也可能是依赖vm.a的位置(比如依赖vm.a的计算属性)</span></span><br><span class="line">  <span class="comment">// vm.a改变时,这些依赖项都要被通知更新(notify)</span></span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: <span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">      watcher.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h3 id="深入Vue-js设计模式"><a href="#深入Vue-js设计模式" class="headerlink" title="深入Vue.js设计模式"></a>深入Vue.js设计模式</h3><p>写完<code>observer.js</code>和<code>watcher.js</code>, 让我们再回顾下<code>Vue.js</code>的设计模式, 从局部回到全局后, 为了更形象的理解, 我画了一张图:</p>
<p><img src="https://i.loli.net/2018/04/22/5adc3ff06cc7a.jpg" alt=""></p>
<p>从上图中, 我们可以更清晰的理解数据流和设计模式, 值得注意的是, 整个流程有两个入口:</p>
<p>第一个是<code>new Vue()</code>, 程序从这里开始, 先完成数据代理<code>data proxy</code>, 再完成<code>劫持监听</code>(<code>Object.defineProperty</code>), 将<code>data</code>的每层每项数据全部用闭包封装成寄存器模式, 并给每项<code>getter</code>与<code>setter</code>绑定了对应的<code>dep</code>实例. 程序运行到这里戛然而止.</p>
<p>第二个入口是<code>new Watcher()</code>, 从这个方向, <code>watcher</code>在实例化的过程中调用了第一个入口设置好的<code>getter</code>, 向对应的<code>data[key]</code>的<code>dep</code>实例中维护的观察者列表<code>subs</code>添加依赖项(<code>watcher</code>自己), 并在<code>data[key]</code>被重新赋值时被<code>dep</code>通知(<code>dep.notify</code>), 进行自我更新<code>watcher.update</code></p>
<p>那么有两个问题浮现在我们眼前: </p>
<ul>
<li><strong>为什么要用多个<code>dep</code>, 而不是维护一个全局<code>dep</code>对象 ?</strong> </li>
<li><strong>什么时候调用new Watcher() ?</strong></li>
</ul>
<p>这就要涉及到”模板编译”(<code>Compile</code>)过程, 将在下篇中介绍.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/03/my-vue-2/" class="next">上一篇</a><a href="/2018/04/10/my-vue-04/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>