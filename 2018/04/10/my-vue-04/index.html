<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 模拟Vue.js的设计模式实现 (四): 模拟Compile · choteewang</title><meta name="description" content="模拟Vue.js的设计模式实现 (四): 模拟Compile - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">模拟Vue.js的设计模式实现 (四): 模拟Compile</h1><div class="post-info">2018年4月10日</div><div class="post-content"><p><a href="https://choteewang.github.io/2018/04/07/my-vue-03/" target="_blank" rel="noopener">上篇博客</a>完成了<code>observer.js</code>与<code>watcher.js</code>, 并从全局的角度理解了<code>Vue.js</code>的设计模式</p>
<p>这个小项目的源码的<code>github</code>地址是: <a href="https://github.com/choteewang/my-vue" target="_blank" rel="noopener">https://github.com/choteewang/my-vue</a></p>
<p><img src="https://i.loli.net/2018/04/22/5adc3ff06cc7a.jpg" alt="Vue设计模式"></p>
<p>我们同时抛出了两个问题: </p>
<ul>
<li><strong>为什么要用多个<code>dep</code>, 而不是维护一个全局<code>dep</code>对象 ?</strong> </li>
<li><strong>什么时候调用new Watcher() ?</strong></li>
</ul>
<blockquote>
<p>为什么要用多个<code>dep</code>实例, 而不是维护一个全局列表 ?</p>
</blockquote>
<p>传统的观察者模式的<code>dep.subs</code>不是一个数组, 而是一个对象, 用<code>key</code>代表依赖, <code>key</code>的值代表依赖列表, 统一管理所有<code>订阅者</code>.</p>
<p><code>MVVM</code>框架的依赖项是<code>多维</code>的, 处于同一维度的不是不同的<code>key</code>, 而是依赖同一个<code>data[key]</code>的不同依赖项. </p>
<p>具体来说, 不能将<code>dep,subs</code>本身设置成一个全局<code>对象</code>或<code>数组</code>, 却用一维平行装载<code>vm.a</code>, <code>vm.b</code>这些依赖. 倘若如此, 如果有一个依赖<code>vm.a</code>的计算属性<code>vm.computedFromA</code>呢?</p>
<p>当然也可以将<code>dep.subs</code>设计成多维的, 比如<code>dep.subs</code>是一个对象, 每个<code>key</code>代表一个<code>data[key]</code>依赖, 它的值再是一个依赖<code>data[key]</code>依赖项们组成的数组. 而我们还是要从每个<code>data[key]</code>的<code>getter</code>与<code>setter</code>中取这个<code>dep</code>的实例, 闭包一点都没少用, 性能当然不会大幅提升.</p>
<p>所以, 最好的做法就是像现在这样, 依赖<code>vm.a</code>的所有依赖项共享一个<code>dep</code>, 共享<code>dep.subs</code>观察者列表. <code>dep</code>的角色从传统观察者模式的全局对象降低为类似全局对象中的一个<code>key</code>, 而<code>dep.subs</code>设计成一维数组, 用来同时维护<code>vm.a</code>, <code>vm.computedFromA</code>等所有依赖<code>vm.a</code>的<code>watcher</code>依赖项</p>
<p>于是, 第二个问题又会随之浮上水面: 何时调用<code>new Watcher()</code>实例化<code>watcher</code>触发<code>data[key]</code>的依赖收集?</p>
<blockquote>
<p>何时调用<code>new Watcher()</code>进行依赖收集?</p>
</blockquote>
<p>答案是模板编译(<code>Compile</code>)的时候, 我们先来看下<code>render</code>函数</p>
<h3 id="Vue-js中render函数的介绍"><a href="#Vue-js中render函数的介绍" class="headerlink" title="Vue.js中render函数的介绍"></a>Vue.js中render函数的介绍</h3><p>在<code>Vue.js</code>中, 如果我们写这样一个<code>Vue template</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;price&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的模板字符串会被编译成js执行, 具体点说是被解析为一个<code>render</code>函数, 这个函数长这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;  <span class="comment">// this 就是 vm</span></span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">      <span class="string">'div'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        attrs: &#123; <span class="string">'id'</span>: <span class="string">'app'</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      [</span><br><span class="line">        _c(<span class="string">'p'</span>, [_v(_s(price))])</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>render</code>函数中的<code>with(this)</code>扩展了大括号的作用域, 这个<code>this</code>指向<code>vm</code>实例, 下面的<code>_c</code>函数实际上是<code>vm._c</code>, 同理, <code>_v</code>是<code>vm._v</code>, <code>_s</code>是<code>vm._s</code>, <code>price</code>是<code>vm.price</code>, 我们将其改写如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vm._c(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// vm._c =&gt; 创建dom标签</span></span><br><span class="line">      attrs: &#123; <span class="string">'id'</span>: <span class="string">'app'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">// vm._v =&gt; 创建文本节点</span></span><br><span class="line">      <span class="comment">// vm._s =&gt; toString()</span></span><br><span class="line">      vm._c(<span class="string">'p'</span>, [vm._v(vm._s(vm.price))])</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎变的清晰些了, 这个<code>render</code>函数非常像<code>VNode</code>的实现方式, 以字符串表示<code>node.tagName</code>, 以一个对象表示<code>node.attributes</code>, 以及最后用数组表示<code>node.childNodes</code>, 实际上, <code>vm._c</code>本质上就是<code>VNode</code>实现中的<code>h函数</code>, 用来把一个<code>VNode</code>对象转化为一个元素节点, 它的返回值的确就是一个<code>VNode</code>节点, 同理, <code>vm._v</code>是创建文本节点的方法, <code>vm._s</code>则是转化字符串的方法</p>
<p>这里涉及到<code>VNode</code>的知识, 再说下去就是<code>diff算法</code>, 就不过多展开了, 之所以介绍<code>render</code>函数, 是因为我们要模拟的<code>Compile</code>过程其实就类似创建<code>render</code>函数的过程, 不过我们用的不是<code>VNode</code>,<code>diff算法</code>,<code>render函数</code>, 而是<code>Fragment</code>, 这样做的原因有两个: 一是可以简化这里的实现, 把重点放在之前<code>Vue</code>的设计模式上, 二是无论<code>Fragment</code>, 还是<code>render</code>函数, 它们调用<code>new Watcher()</code>进行依赖收集的时机本质上是一样的.</p>
<h3 id="模拟-Compile"><a href="#模拟-Compile" class="headerlink" title="模拟 Compile"></a>模拟 Compile</h3><p>打开<code>index.js</code>, 在数据代理和劫持监听过程之后, 加入<code>compile</code>过程入口, 传递挂载点dom选择器和<code>vm</code>实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = options.data</span><br><span class="line">  <span class="keyword">this</span>.el = options.el</span><br><span class="line">  <span class="keyword">this</span>.methods = options.methods</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.init(<span class="keyword">this</span>.data)</span><br><span class="line">  observe(<span class="keyword">this</span>.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compile入口</span></span><br><span class="line">  <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>compile.js</code>, 写下架构雏形:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将挂载点dom缓存</span></span><br><span class="line">  <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="comment">// 用于dom更新的片段</span></span><br><span class="line">  <span class="keyword">this</span>.fragment = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 创建片段</span></span><br><span class="line">  createFragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 循环遍历节点,分类编译</span></span><br><span class="line">  compile: <span class="function"><span class="keyword">function</span>(<span class="params">fragment</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 编译元素节点</span></span><br><span class="line">  compileElement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 编译v-on指令</span></span><br><span class="line">  compileEvent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 编译v-model指令</span></span><br><span class="line">  compileVmodel: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 编译v-bind指令</span></span><br><span class="line">  compileVbind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  compileTextNode: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Compile</code>构造函数在内部先缓存根挂载点和<code>vm</code>实例, 定义用于<code>dom</code>更新的<code>fragment</code>片段, 调用<code>init</code>方法开始编译, 搭完这个骨架后, 我们一点点实现编译过程.</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p><code>init</code>方法是整个编译过程的入口, 它清晰的显示了同步编译流程的各个步骤: </p>
<ol>
<li>将<code>Vue template</code>放入一个片段并缓存给<code>compile.fragment</code></li>
<li>逐个节点编译这个片段, 进行必要的<code>dom</code>操作和更新</li>
<li>最后将编译完成的片段<code>append</code>入挂载点</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.el) &#123;</span><br><span class="line">    <span class="comment">// 创建并缓存片段</span></span><br><span class="line">    <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.createFragment(<span class="keyword">this</span>.el)</span><br><span class="line">    <span class="comment">// 编译片段</span></span><br><span class="line">    <span class="keyword">this</span>.compile(<span class="keyword">this</span>.fragment)</span><br><span class="line">    <span class="comment">// 将编译完成的片段append入挂载点</span></span><br><span class="line">    <span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.fragment)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'can not find root element'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用<code>Vue.js</code>使用的<code>Virtual Dom</code>方法, 会将<code>Vue template</code>编译成一个<code>render</code>函数, <code>render</code>函数的返回值是一个<code>Vnode</code>, 使用<code>patch</code>方法将此<code>Vnode</code>挂载入页面.</p>
<h4 id="创建片段"><a href="#创建片段" class="headerlink" title="创建片段"></a>创建片段</h4><p><code>createFragment</code>方法创建并返回<code>Vue template</code>dom结构的片段, 用<code>createDocumentFragment</code>方法创建一个片段, 循环遍历挂载点的子节点 将子节点<code>append</code>入片段中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createFragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">  <span class="keyword">var</span> child = el.firstChild</span><br><span class="line">  <span class="keyword">while</span>(child) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    child = el.firstChild</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="分类编译"><a href="#分类编译" class="headerlink" title="分类编译"></a>分类编译</h4><p><code>compile</code>方法的功能是为不同的节点分配不同的编译函数, 如果是元素节点直接进行编译, 文本节点则用正则表达式匹配是否符合<code>\{\{ xxx \}\}</code>的插值形式, 如果匹配再进行编译. 最后递归调用编译每个子节点, 保证整个<code>Fragment</code>的<code>Dom Tree</code>被完全编译</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">compile: <span class="function"><span class="keyword">function</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> childNodes = fragment.childNodes</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(childNodes, <span class="function"><span class="keyword">function</span>(<span class="params">childNode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是元素节点, 调用compileElment</span></span><br><span class="line">    <span class="keyword">if</span>(childNode.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">      self.compileElement(childNode)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果是文本节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(childNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断是否匹配vue插值格式</span></span><br><span class="line">      <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span> <span class="comment">// 匹配&#123;&#123; xxx &#125;&#125;</span></span><br><span class="line">      <span class="keyword">if</span>(reg.test(childNode.nodeValue)) &#123;</span><br><span class="line">        <span class="comment">// 传入捕获组匹配的表达式, 调用compileTextNode</span></span><br><span class="line">        self.compileTextNode(childNode, <span class="built_in">RegExp</span>.$<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果childNode仍然存在子节点, 递归调用</span></span><br><span class="line">    <span class="comment">// 这里注意childNodes是带有length属性的伪数组, 注意判断条件</span></span><br><span class="line">    <span class="keyword">if</span>(childNode.childNodes &amp;&amp; childNode.childNodes.length) &#123;</span><br><span class="line">      self.compile(childNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译文本节点"><a href="#编译文本节点" class="headerlink" title="编译文本节点"></a>编译文本节点</h4><p><code>compileTextNode</code>方法用于编译形如<code>\{\{ xxx \}\}</code>类型的文本节点. 这里就是调用<code>new Watcher</code>的时机. </p>
<p>比如文本节点是<code></code>, 实例化一个<code>watcher</code>触发<code>data[&#39;triggerTip&#39;]</code>的<code>getter</code>, 此<code>watcher</code>由于被赋值给<code>Dep.target</code>最终被<code>push</code>入对应的<code>dep</code>实例的观察者数组<code>subs</code>, 同时<code>watcher.val</code>拿到返回值并返回给<code>node.nodeValue</code>完成初次渲染.</p>
<p>当下次<code>data[&#39;triggerTip&#39;]</code>的值改变时, 会通过其<code>getter</code>通知同一个<code>dep</code>通知<code>watcher</code>的<code>update</code>方法执行我们现在传入的回调函数, 回调函数调用<code>compile._updateTextNode</code>方法更新文本节点的<code>nodeValue</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compileTextNode: <span class="function"><span class="keyword">function</span>(<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 初始化watcher</span></span><br><span class="line">  <span class="comment">// 此步骤会调用data[key]的getter添加依赖项</span></span><br><span class="line">  <span class="comment">// 获取并设置初始渲染的值</span></span><br><span class="line">  node.nodeValue = <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    self._updateTextNode(node, val)</span><br><span class="line">  &#125;).val</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 更新文本节点</span></span><br><span class="line">_updateTextNode: <span class="function"><span class="keyword">function</span>(<span class="params">node, val</span>) </span>&#123;</span><br><span class="line">  node.nodeValue = <span class="keyword">typeof</span> val === <span class="string">'undefined'</span> ? <span class="string">''</span> : val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编辑元素节点"><a href="#编辑元素节点" class="headerlink" title="编辑元素节点"></a>编辑元素节点</h4><p><code>compileElement</code>方法用于编译<code>Vue</code>元素节点, 再根据特性节点中<code>Vue指令</code>的不同分派不同的处理函数. 它的大概运行过程是这样的.</p>
<ol>
<li>获取元素的特性节点集合</li>
<li>遍历集合并对其中形式为<code>v-</code>开头的各个指令做不同的处理函数指派</li>
<li>从元素上移除<code>Vue指令</code>特性, 使其渲染到页面后成为标准的<code>HTML</code>元素</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> attrs = node.attributes <span class="comment">// 获取特性list</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(attrs, <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> attrName = attr.nodeName <span class="comment">// 获取特性名</span></span><br><span class="line">    <span class="keyword">var</span> exp = attr.nodeValue<span class="comment">// 获取特性值</span></span><br><span class="line">    <span class="comment">// 判断是不是v-开头的指令</span></span><br><span class="line">    <span class="keyword">if</span> (self._isDirective(attrName)) &#123;</span><br><span class="line">      <span class="keyword">var</span> directive = attrName.slice(<span class="number">2</span>) <span class="comment">// 去掉v-</span></span><br><span class="line">      <span class="comment">// 如果是v-on指令</span></span><br><span class="line">      <span class="keyword">if</span> (self._isVon(directive)) &#123;</span><br><span class="line">        self.compileEvent(node, self.vm, exp, directive)</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 如果是v-model指令</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(self._isVmodel(directive)) &#123;</span><br><span class="line">        self.compileVmodel(node, self.vm, exp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是v-bind指令</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(self._isVbind(directive)) &#123;</span><br><span class="line">        self.compileVbind(node, self.vm, exp, directive)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除vue指令特性</span></span><br><span class="line">      node.removeAttribute(attrName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 判断是否Vue指令</span></span><br><span class="line">_isDirective: <span class="function"><span class="keyword">function</span>(<span class="params">attrName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> attrName.indexOf(<span class="string">'v-'</span>) === <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 判断是否v-on指令</span></span><br><span class="line">_isVon: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> directive.indexOf(<span class="string">'on:'</span>) === <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 判断是否v-model指令</span></span><br><span class="line">_isVmodel: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> directive.indexOf(<span class="string">'model'</span>) === <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line">_isVbind: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> directive.indexOf(<span class="string">'bind'</span>) === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译v-on指令"><a href="#编译v-on指令" class="headerlink" title="编译v-on指令"></a>编译v-on指令</h4><p><code>compileEvent</code>用于编译<code>v-on</code>指令, 它先获取事件类型(<code>eventType</code>), 再从<code>vm.methods</code>中获取表达式对应的方法名, 最终用<code>addEventListener</code>方法进行事件绑定, 为了模拟<code>Vue</code>的处理方式, 将<code>this</code>绑定为<code>vm</code>实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">compileEvent: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, directive</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取事件类型</span></span><br><span class="line">  <span class="keyword">var</span> type = directive.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 获取methods中的对应方法</span></span><br><span class="line">  <span class="keyword">var</span> cb = vm.methods &amp;&amp; vm.methods[exp]</span><br><span class="line">  <span class="comment">// 给节点绑定事件,注意将cb内部this绑定vm</span></span><br><span class="line">  <span class="keyword">if</span>(type &amp;&amp; cb) &#123;</span><br><span class="line">    node.addEventListener(type, cb.bind(vm), <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译v-bind指令"><a href="#编译v-bind指令" class="headerlink" title="编译v-bind指令"></a>编译v-bind指令</h4><p><code>compileVbind</code>方法用于编译<code>v-bind</code>指令, 它先获取需绑定的<code>HTML</code>特性名, 再执行<code>new Watcher()</code>触发对应<code>getter</code>收集依赖并返回初值, 进行首次渲染. 同时绑定了回调函数<code>cb</code>, 在<code>data[attr]</code>改变时, 触发回调, <code>re-render</code>页面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">compileVbind: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, directive</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 获取要绑定的特性名</span></span><br><span class="line">  <span class="keyword">var</span> attr = directive.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 获取初始值</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    self._updateNodeAttr(node, attr, val)</span><br><span class="line">  &#125;).val</span><br><span class="line">  <span class="comment">// 首次渲染</span></span><br><span class="line">  <span class="keyword">this</span>._updateNodeAttr(node, attr, value)    </span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 更新元素的attr特性</span></span><br><span class="line">_updateNodeAttr: <span class="function"><span class="keyword">function</span>(<span class="params">node, attr, val</span>) </span>&#123;</span><br><span class="line">  node[attr] = <span class="keyword">typeof</span> val === <span class="string">'undefined'</span> ? <span class="string">''</span> : val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译v-model指令"><a href="#编译v-model指令" class="headerlink" title="编译v-model指令"></a>编译v-model指令</h4><p><code>compileVmodel</code>方法用于编译<code>v-model</code>指令, 这里执行了一个双向绑定的过程</p>
<ul>
<li><code>data -&gt; view</code>: 同上述<code>v-bind</code>过程, 改变<code>element.value</code>的值</li>
<li><code>view -&gt; input</code>: 监听元素的<code>input</code>事件, 将<code>event.target.value</code>赋值给<code>vm[key]</code>触发<code>setter</code>, <code>setter</code>通知依赖<code>watcher</code>执行<code>update</code>方法, 执行回调进行<code>re-render</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">compileVmodel: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// data -&gt; view</span></span><br><span class="line">  <span class="comment">// 初始化watcher</span></span><br><span class="line">  <span class="comment">// 此步骤会调用data[key]的getter添加依赖项</span></span><br><span class="line">  <span class="comment">// 获取初值</span></span><br><span class="line">  <span class="keyword">var</span> value =  <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    self._updateNodeAttr(node, <span class="string">'value'</span> ,val)</span><br><span class="line">  &#125;).val </span><br><span class="line">  <span class="comment">// 首次渲染设置nodeValue</span></span><br><span class="line">  <span class="keyword">this</span>._updateNodeAttr(node, <span class="string">'value'</span>, value)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// view -&gt; data</span></span><br><span class="line">  node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    self.vm[exp] = event.target.value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新元素的attr特性</span></span><br><span class="line">_updateNodeAttr: <span class="function"><span class="keyword">function</span>(<span class="params">node, attr, val</span>) </span>&#123;</span><br><span class="line">  node[attr] = <span class="keyword">typeof</span> val === <span class="string">'undefined'</span> ? <span class="string">''</span> : val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟-mounted"><a href="#模拟-mounted" class="headerlink" title="模拟 mounted"></a>模拟 mounted</h4><p>全部编译完成后, <code>init</code>方法执行<code>this.el.appendChild(this.fragment)</code>将编译完成的<code>DOM</code>节点<code>append</code>入挂载点<code>el</code>, <code>dom</code>挂载完成.</p>
<p>回到<code>index.js</code>, 加上执行<code>mounted</code>钩子的代码, 注意模拟<code>Vue.js</code>绑定<code>this</code>为<code>vm</code>实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = options.data</span><br><span class="line">  <span class="keyword">this</span>.el = options.el</span><br><span class="line">  <span class="keyword">this</span>.methods = options.methods</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.init(<span class="keyword">this</span>.data)</span><br><span class="line">  observe(<span class="keyword">this</span>.data)</span><br><span class="line">  <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将dom挂载完成后,执行mounted钩子</span></span><br><span class="line">  options.mounted &amp;&amp; options.mounted.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回顾流程"><a href="#回顾流程" class="headerlink" title="回顾流程"></a>回顾流程</h3><p><code>compile.js</code>完成后, 所有开发已经完成, 将之前画的图进行扩充, 项目的设计模式如下:</p>
<p><img src="https://i.loli.net/2018/04/23/5adcc9ecb3e4a.jpg" alt=""></p>
<p>从图中可以清晰的看到, 在编译模板的的过程中, 通过<code>new Watcher().val</code>拿到首次渲染的对应值, <code>data[key]</code>更新后, 通过<code>setter</code>-&gt;<code>dep.notify</code>-&gt;<code>wathcer.update</code>, 最终执行<code>new Watcher()</code>过程中绑定的回调函数<code>cb</code>, 该函数回到<code>compile</code>作用域执行, 对视图进行更新.</p>
<h3 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h3><p>用浏览器打开<code>index.html</code>观察效果, 可以看到所有<code>dom</code>挂载完毕后显示<code>mounted function called</code>, 证明<code>mounted</code>钩子已正确执行.</p>
<p>改变<code>input</code>的输入值, 输入框下插值<code>inputValue</code>的<code>h1</code>标签可跟随<code>input</code>的输入改变. 打开浏览器设置<code>vm.inputValue = finished coding!</code>, 可以看到<code>input</code>输入框和<code>h1</code>标签的共同改变, 双向绑定完成!</p>
<p>点击<code>button</code>, <code>img</code>标签的图片会正常切换, 打开控制台将<code>vm.src</code>设置为一个网络地址, 图片改变.</p>
<p>完结, 撒花! </p>
<p><img src="https://i.loli.net/2018/04/22/5adc7ce746bae.jpg" alt=""></p>
<p><img src="https://i.loli.net/2018/04/22/5adc7ce7794ef.jpg" alt=""></p>
<h3 id="compile-js-完整代码"><a href="#compile-js-完整代码" class="headerlink" title="compile.js 完整代码"></a>compile.js 完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将挂载点dom缓存</span></span><br><span class="line">  <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="comment">// 用于dom更新的片段</span></span><br><span class="line">  <span class="keyword">this</span>.fragment = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.el) &#123;</span><br><span class="line">      <span class="comment">// 将vue字符模板放入片段中操作,提高性能</span></span><br><span class="line">      <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.node2Fragment(<span class="keyword">this</span>.el)</span><br><span class="line">      <span class="comment">// 编译片段</span></span><br><span class="line">      <span class="keyword">this</span>.compile(<span class="keyword">this</span>.fragment)</span><br><span class="line">      <span class="comment">// 将编译完成的片段append入挂载点</span></span><br><span class="line">      <span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.fragment)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'can not find root element'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 将挂载点的innerHTML append入fragment</span></span><br><span class="line">  node2Fragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">    <span class="keyword">var</span> child = el.firstChild</span><br><span class="line">    <span class="keyword">while</span>(child) &#123;</span><br><span class="line">      fragment.appendChild(child)</span><br><span class="line">      child = el.firstChild</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 循环遍历节点,分类编译</span></span><br><span class="line">  compile: <span class="function"><span class="keyword">function</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> childNodes = fragment.childNodes</span><br><span class="line">    <span class="built_in">Array</span>.prototype.forEach.call(childNodes, <span class="function"><span class="keyword">function</span>(<span class="params">childNode</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果是元素节点, 直接传递node</span></span><br><span class="line">      <span class="keyword">if</span>(childNode.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">        self.compileElement(childNode)</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 如果是文本节点</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(childNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否匹配vue插值格式</span></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span> <span class="comment">// 匹配&#123;&#123; xxx &#125;&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(childNode.nodeValue)) &#123;</span><br><span class="line">          <span class="comment">// 传入捕获组匹配的表达式</span></span><br><span class="line">          self.compileTextNode(childNode, <span class="built_in">RegExp</span>.$<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果childNode仍然存在子节点, 递归调用</span></span><br><span class="line">      <span class="comment">// 这里注意childNodes是带有length属性的伪数组, 注意判断条件</span></span><br><span class="line">      <span class="keyword">if</span>(childNode.childNodes &amp;&amp; childNode.childNodes.length) &#123;</span><br><span class="line">        self.compile(childNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 编译元素节点</span></span><br><span class="line">  compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> attrs = node.attributes <span class="comment">// 获取特性list</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.forEach.call(attrs, <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> attrName = attr.nodeName <span class="comment">// 获取特性名</span></span><br><span class="line">      <span class="keyword">var</span> exp = attr.nodeValue<span class="comment">// 获取特性值</span></span><br><span class="line">      <span class="comment">// 判断是不是v-开头的指令</span></span><br><span class="line">      <span class="keyword">if</span> (self._isDirective(attrName)) &#123;</span><br><span class="line">        <span class="keyword">var</span> directive = attrName.slice(<span class="number">2</span>) <span class="comment">// 去掉v-</span></span><br><span class="line">        <span class="comment">// 如果是v-on指令</span></span><br><span class="line">        <span class="keyword">if</span> (self._isVon(directive)) &#123;</span><br><span class="line">          self.compileEvent(node, self.vm, exp, directive)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果是v-model指令</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(self._isVmodel(directive)) &#123;</span><br><span class="line">          self.compileVmodel(node, self.vm, exp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是v-bind指令</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(self._isVbind(directive)) &#123;</span><br><span class="line">          self.compileVbind(node, self.vm, exp, directive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除vue指令特性</span></span><br><span class="line">        node.removeAttribute(attrName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 判断是否Vue指令</span></span><br><span class="line">  _isDirective: <span class="function"><span class="keyword">function</span>(<span class="params">attrName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.indexOf(<span class="string">'v-'</span>) === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 判断是否v-on指令</span></span><br><span class="line">  _isVon: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> directive.indexOf(<span class="string">'on:'</span>) === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 判断是否v-model指令</span></span><br><span class="line">  _isVmodel: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> directive.indexOf(<span class="string">'model'</span>) === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  _isVbind: <span class="function"><span class="keyword">function</span>(<span class="params">directive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> directive.indexOf(<span class="string">'bind'</span>) === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 编译v-on指令</span></span><br><span class="line">  compileEvent: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, directive</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取事件类型</span></span><br><span class="line">    <span class="keyword">var</span> type = directive.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 获取methods中的对应方法</span></span><br><span class="line">    <span class="keyword">var</span> cb = vm.methods &amp;&amp; vm.methods[exp]</span><br><span class="line">    <span class="comment">// 给节点绑定事件,注意将cb内部this绑定vm</span></span><br><span class="line">    <span class="keyword">if</span>(type &amp;&amp; cb) &#123;</span><br><span class="line">      node.addEventListener(type, cb.bind(vm), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 编译v-model指令</span></span><br><span class="line">  compileVmodel: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> value = vm[exp] <span class="comment">// 获取初值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data -&gt; view</span></span><br><span class="line">    <span class="comment">// 首次渲染设置nodeValue</span></span><br><span class="line">    <span class="keyword">this</span>._updateNodeAttr(node, <span class="string">'value'</span>, value)</span><br><span class="line">    <span class="comment">// 初始化watcher</span></span><br><span class="line">    <span class="comment">// 此步骤会调用data[key]的getter添加依赖项</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      self._updateNodeAttr(node, <span class="string">'value'</span> ,val)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// view -&gt; data</span></span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      self.vm[exp] = event.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 编译v-bind指令</span></span><br><span class="line">  compileVbind: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, directive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 获取要绑定的特性名</span></span><br><span class="line">    <span class="keyword">var</span> attr = directive.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 获取初始值</span></span><br><span class="line">    <span class="keyword">var</span> value = vm[exp]</span><br><span class="line">    <span class="comment">// 首次渲染赋值</span></span><br><span class="line">    <span class="keyword">this</span>._updateNodeAttr(node, attr, value)</span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      self._updateNodeAttr(node, attr, val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更新元素的attr特性</span></span><br><span class="line">  _updateNodeAttr: <span class="function"><span class="keyword">function</span>(<span class="params">node, attr, val</span>) </span>&#123;</span><br><span class="line">    node[attr] = <span class="keyword">typeof</span> val === <span class="string">'undefined'</span> ? <span class="string">''</span> : val</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  compileTextNode: <span class="function"><span class="keyword">function</span>(<span class="params">node, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 获取并设置初始渲染的值</span></span><br><span class="line">    node.nodeValue = <span class="keyword">this</span>.vm[exp]</span><br><span class="line">    <span class="comment">// 初始化watcher</span></span><br><span class="line">    <span class="comment">// 此步骤会调用data[key]的getter添加依赖项</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      self._updateTextNode(node, val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更新文本节点</span></span><br><span class="line">  _updateTextNode: <span class="function"><span class="keyword">function</span>(<span class="params">node, val</span>) </span>&#123;</span><br><span class="line">    node.nodeValue = <span class="keyword">typeof</span> val === <span class="string">'undefined'</span> ? <span class="string">''</span> : val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/07/my-vue-03/" class="next">上一篇</a><a href="/2018/08/01/vue-source-01/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>