<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正反馈系列:《JavaScript高级程序设计》事件 · choteewang</title><meta name="description" content="正反馈系列:《JavaScript高级程序设计》事件 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li><li class="nav-list-item"><a href="https://github.com/choteewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">正反馈系列:《JavaScript高级程序设计》事件</h1><div class="post-info">2017年12月28日</div><div class="post-content"><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>JavaScript 与 HTML 之间的交互是通过<code>事件</code>实现的。<code>事件</code>，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为<code>观察员模式</code>的模型, 关于<code>观察者模式</code>的代码实现,可以看我的另一边blog: <a href="https://choteewang.github.io/2017/12/23/javascript-%E4%B8%8E-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">《javascript 与 “发布/订阅(观察者)模式》</a></p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>想象画在一张纸上的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面</p>
<blockquote>
<p><code>事件流</code>描述的上述过程中,从页面接收事件的顺序.<br>IE 的事件流是<code>事件冒泡流</code>，而 Netscape Communicator 的事件流是<code>事件捕获流</code></p>
</blockquote>
<h3 id="事件冒泡-event-bubbling"><a href="#事件冒泡-event-bubbling" class="headerlink" title="事件冒泡 event bubbling"></a>事件冒泡 event bubbling</h3><blockquote>
<p>事件触发顺序从触发对象沿DOM树向外传播,直至<code>document</code>对象,IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 <code>window</code> 对象。</p>
</blockquote>
<p><img src="https://i.loli.net/2017/12/28/5a445c95c45a1.jpg" alt=""></p>
<h3 id="事件捕获-event-capturing"><a href="#事件捕获-event-capturing" class="headerlink" title="事件捕获 event capturing"></a>事件捕获 event capturing</h3><blockquote>
<p>事件触发顺序从<code>window</code>开始触发,沿DOM树逐级往下按顺序触发,触发对象最后触发</p>
</blockquote>
<p><img src="https://i.loli.net/2017/12/28/5a445c95ddf87.jpg" alt=""></p>
<blockquote>
<p>由于老版本的浏览器不支持，因此很少有人使用事件捕获。<strong>建议使用事件冒泡</strong>，在有特殊需要时再使用事件捕获。</p>
</blockquote>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：</p>
<ol>
<li><code>事件捕获阶段</code></li>
<li><code>处于目标阶段</code></li>
<li><code>事件冒泡阶段</code></li>
</ol>
<p><img src="https://i.loli.net/2017/12/28/5a445c95e67fe.jpg" alt=""></p>
<blockquote>
<p>在DOM事件流中，实际的目标（<code>&lt;div&gt;</code>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>后就停止了。下一个阶段是“处于目标”阶段，于是事件在<code>&lt;div&gt;</code>上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。<br>实际上,当代浏览器在事件捕获阶段都可以触发事件,结果,就有两个机会在目标对象上面操作事件.</p>
</blockquote>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><blockquote>
<p>事件处理程序的名字以”on”开头，因此 click 事件的事件处理程序就是 onclick</p>
</blockquote>
<h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><blockquote>
<p>在HTML元素中,事件可以用与相应处理程序同名的特性指定, 特性的值应该是<strong>能够执行的javascript代码</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Clicked')"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。但前提是代码已被浏览器解析完成</p>
<p>这样指定时间处理程序,会创建一个封装着元素属性值的函数(this.attr可以访问HTML DOM结构对应的attr特性值)。这个函数中有一个局部变量 event，也就是事件对象,通过 event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。在这个函数内部，<strong>this 值等于事件的目标元素</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出 "click" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(this.value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数内部，可以像访问局部变量一样访问 <code>document</code> 及<strong>该元素本身的成员</strong>。这个函数使用 <code>with</code> 像下面这样扩展作用域</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//元素属性值 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，事件处理程序无需引用表单元素就能访问其他表单字段,这个函数就变成了如下所示,</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">      <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//元素属性值 </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM-0级-事件处理程序"><a href="#DOM-0级-事件处理程序" class="headerlink" title="DOM 0级 事件处理程序"></a>DOM 0级 事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id); <span class="comment">//"myBtn" </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序中<code>this</code>引用当前调用元素,可以在事件处理程序中通过 <code>this</code> 访问元素节点的任何属性和方法<br>事件处理程序会在事件流的冒泡阶段被处理。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除事件处理程序</span></span><br><span class="line"><span class="comment">// 也可以删除HTML指定的时间处理程序</span></span><br><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="DOM-2级-事件处理程序"><a href="#DOM-2级-事件处理程序" class="headerlink" title="DOM 2级 事件处理程序"></a>DOM 2级 事件处理程序</h3><h3 id="element-addEventListener-element-removeEventListener"><a href="#element-addEventListener-element-removeEventListener" class="headerlink" title="element.addEventListener(),element.removeEventListener()"></a>element.addEventListener(),element.removeEventListener()</h3><p><code>element.addEventListener(eventName,function,boolean)</code>,<code>boolean</code>为true,捕获阶段调用,<code>boolean</code>为false,冒泡阶段调用</p>
<blockquote>
<p>与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。<code>this</code>指向<code>element</code><br>可以添加多个事件处理程序,按顺序执行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 先alert id,再alert 'Hello world'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只能使用 <code>element.removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener()添加的匿名函数将无法移除</p>
<p>都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。</p>
</blockquote>
<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><h3 id="element-attachEvent-element-detachEvent"><a href="#element-attachEvent-element-detachEvent" class="headerlink" title="element.attachEvent() element.detachEvent()"></a>element.attachEvent() element.detachEvent()</h3><p><code>element.attachEvent(eventName,function)</code>,<code>element.detachEvent(event,function)</code></p>
<blockquote>
<p><code>element.attachEvent</code>与<code>element.detachEvent()</code>第一个参数的事件名是<code>onclick</code>,而不是DOM 2级中的<code>click</code><br>事件会在全局作用域中执行,<code>this</code>等于<code>window</code><br>可以添加多个事件处理程序,但执行顺序是倒序<br>用<code>element.attachEvent()</code>添加的事件可用<code>element.detachEvent()</code>移除,也要提供相同的参数才行,匿名函数不能被移除</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello world</span></span><br><span class="line"><span class="comment">// Clicked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除事件绑定</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">btn.detachEvent(<span class="string">"onclick"</span>, handler);</span><br></pre></td></tr></table></figure>
<h3 id="跨浏览器事件处理程序"><a href="#跨浏览器事件处理程序" class="headerlink" title="跨浏览器事件处理程序"></a>跨浏览器事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 事件绑定与事件解绑</span></span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line"></span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote>
<p>在触发DOM上的某个事件时，会产生一个事件对象<code>event</code>，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持event对象</p>
</blockquote>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><blockquote>
<p>兼容 DOM 的浏览器会将一个 <code>event</code> 对象传入到事件处理程序中, 无论指定事件处理程序时使用什么方法（HTML特性指定事件处理程序, DOM0 级或 DOM2 级），都会传入 <code>event</code> 对象</p>
<p>event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下表列出的成员。</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">读/写</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bubbles</code></td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">表明事件是否冒泡</td>
</tr>
<tr>
<td><code>cancelable</code></td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">表明是否可以取消事件的默认行为</td>
</tr>
<tr>
<td><code>currentTarget</code></td>
<td style="text-align:center">Element</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">事件处理程序当前正在处理事件的那个元素,与<code>this</code>的值恒等,事件处理函数的调用对象,注册对象</td>
</tr>
<tr>
<td><code>defaultPrevented</code></td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">为true表示已调用<code>event.preventDefault()</code></td>
</tr>
<tr>
<td><code>detail</code></td>
<td style="text-align:center">Integer</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">与事件相关的细节信息</td>
</tr>
<tr>
<td><code>eventPhase</code></td>
<td style="text-align:center">Integer</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">调用事件处理程序的阶段,1捕获2目标3冒泡</td>
</tr>
<tr>
<td><code>preventDefault()</code></td>
<td style="text-align:center">Function</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">取消事件的默认行为,如果<code>event.cancelable</code>是true,可以使用此方法</td>
</tr>
<tr>
<td><code>stopImmediatePropagation()</code></td>
<td style="text-align:center">Function</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">取消事件的进一步捕获或冒泡,同时阻止任何事件处理程序被调用</td>
</tr>
<tr>
<td><code>stopPropagation()</code></td>
<td style="text-align:center">Function</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">取消事件的进一步捕获或冒泡,如果<code>event.bubbles</code>为true,可以使用此方法</td>
</tr>
<tr>
<td><code>target</code></td>
<td style="text-align:center">Element</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">事件的目标对象,实际触发目标</td>
</tr>
<tr>
<td><code>trusted</code></td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">为true表示是浏览器生成的,为false表示是工程师用js创建的</td>
</tr>
<tr>
<td><code>type</code></td>
<td style="text-align:center">String</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">被触发的事件的类型,没有on的格式</td>
</tr>
<tr>
<td><code>view</code></td>
<td style="text-align:center">AbstractView</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">与事件关联的抽象视图,等同于发生事件的<code>window</code>对象</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在事件处理程序内部,<code>this</code>的值始终等于<code>currentTarget</code>的值,也就是注册事件的元素(谁<code>.</code>出的,谁就是<code>this</code>,谁就是<code>currentTarget</code>),而<code>target</code>是事件的<code>实际触发目标</code><br>如果将事件处理程序制定给了目标元素,则<code>this</code>,<code>currentTarget</code>,<code>target</code>包含相同的值,指向同一对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="keyword">this</span>); <span class="comment">//true </span></span><br><span class="line">  alert(event.target === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">//true </span></span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">//true </span></span><br><span class="line">  alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>)); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二个例子中,当单机<code>id</code>是<code>myBtn</code>的按钮时,<code>this</code>和<code>currentTarget</code>都等于<code>document.body</code>，因为事件处理程序是注册到这个元素上的。然而，<code>target</code>元素却等于按钮元素，因为它是<code>click</code>事件真正的目标。由于按钮上并没有注册事件处理程序，结果click事件就冒泡到了<code>document.body</code>，在那里事件才得到了处理。</p>
</blockquote>
<p>在需要通过一个函数处理多个事件时,可以使用<code>event.type</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      alert(<span class="string">"Clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure>
<p><code>event.cancelable</code> 属性设置为 true 的事件，可以使用 <code>event.preventDefault()</code>来取消其默认行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>event.stopPropagation()</code>方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用<code>event.stopPropagation()</code>，从而避免触发注册在<code>document.body</code>上面的事件处理程序，如下面的例子所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Body clicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于这个例子而言，如果不调用<code>event.stopPropagation()</code>，就会在单击按钮时出现两个警告框。可是，由于click事件根本不会传播到<code>document.body</code>，因此就不会触发注册在这个元素上的onclick事件处理程序。</p>
</blockquote>
<p><code>event.eventPhase</code>属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么<code>event.eventPhase</code>等于1；如果事件处理程序处于目标对象上，则<code>event.eventPhase</code>等于2；如果是在冒泡阶段调用的事件处理程序，<code>event.eventPhase</code>等于3。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但<code>event.eventPhase</code>仍然一直等于2。来看下面的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.eventPhase); <span class="comment">//2 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.eventPhase); <span class="comment">//1 </span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.eventPhase); <span class="comment">//3 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到<code>document.body</code>中的那一个，结果会弹出一个警告框显示表示<code>event.eventPhase</code>的1。接着，会触发在按钮上注册的事件处理程序，此时的<code>event.eventPhase</code>值为2。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到<code>document.body</code>上的那一个，显示<code>event.eventPhase</code>的值为3。而当<code>event.eventPhase</code>等于2时，this、target和currentTarget始终都是相等的。<br>有在事件处理程序执行期间，<code>event</code> 对象才会存在；一旦事件处理程序执行完成，<code>event</code> 对象就会被销毁</p>
</blockquote>
<h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><p>与DOM中的<code>event</code>对象不同,要访问IE中的<code>event</code>对象,有几种不同的方式,取决于事件处理程序的绑定方法</p>
<p>在使用DOM 0级方法,添加事件处理程序时，<code>event</code> 对象作为 <code>window</code> 对象的一个属性<code>window.event</code>存在</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  alert(event.type); <span class="comment">//"click" </span></span><br><span class="line">  <span class="comment">// DOM 0级中的this指向调用元素btn,无论IE还是DOM</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果事件处理程序是使用 <code>element.attachEvent()</code>添加的，那么就会有一个 <code>event</code> 对象作为参数被传入事件处理程序函数中,但仍然可以使用<code>window.event</code>访问事件<code>event</code>对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">//"click" </span></span><br><span class="line">  <span class="comment">// attachEvent绑定的事件处理程序,this指向window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 HTML特性指定的事件处理程序，那么还可以通过一个名叫 <code>event</code> 的变量来访问 event 对象（与 DOM 中的事件模型相同）。再看一个例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IE中的所有事件对象都会包含下表所列属性和方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">读/写</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelBubble</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">读/写</td>
<td>默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中的stopPropagation()方法的作用相同）</td>
</tr>
<tr>
<td>returnValue</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">读/写</td>
<td>默认值为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同）</td>
</tr>
<tr>
<td>srcElement</td>
<td style="text-align:center">Element</td>
<td style="text-align:center">只读</td>
<td>事件的目标（与DOM中的target属性相同）</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">String</td>
<td style="text-align:center">只读</td>
<td>被触发的事件的类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为 this 会始终等于事件目标。故而，最好还是使用 <code>event.srcElement</code> 比较保险。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>); <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.srcElement === <span class="keyword">this</span>); <span class="comment">//false</span></span><br><span class="line">  <span class="comment">// attachEvent()方法注册的事件处理程序this指向window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一个事件处理程序中（使用 DOM0 级方法指定的），<code>event.srcElement</code> 属性等于 <code>this</code>，但在第二个事件处理程序中，这两者的值不相同</p>
</blockquote>
<p><code>returnValue</code> 属性相当于 DOM 中的 <code>preventDefault()</code>方法，它们的作用都是取消给定事件的默认行为。只要将 <code>returnValue</code> 设置为 false，就可以阻止默认行为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cancelBubble</code> 属性与 DOM 中的 <code>stopPropagation()</code>方法作用相同，都是用来停止事件冒泡的。由于 IE 不支持事件捕获，因而只能取消事件冒泡；但 <code>stopPropagatioin()</code>可以同时取消事件捕获和冒泡。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Body clicked"</span>); <span class="comment">//由于取消了冒泡,不显示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><blockquote>
<p>向我们的工具对象<code>EventUtil</code>中添加代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 获得事件对象</span></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 阻止浏览器默认事件</span></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消事件流</span></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得事件对象</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件触发对象</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止默认行为</span></span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止事件流</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.stopPropagation(event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p><code>DOM 3级事件</code>规定了以下几类事件。</p>
<ul>
<li>UI（UserInterface，用户界面）事件，当用户与页面上的元素交互时触发；</li>
<li>焦点事件，当元素获得或失去焦点时触发；</li>
<li>鼠标事件，当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件，当使用鼠标滚轮（或类似设备）时触发；</li>
<li>文本事件，当在文档中输入文本时触发；</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件，当为IME（InputMethodEditor，输入法编辑器）输入字符时触发；</li>
<li>变动（mutation）事件，当底层DOM结构发生变化时触发。</li>
</ul>
<blockquote>
<p>除了这几类事件之外，HTML5 也定义了一组事件，而有些浏览器还会在 DOM 和 BOM 中实现其他专有事件。这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现有可能不一致。</p>
</blockquote>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><blockquote>
<p>UI 事件指的是那些不一定与用户操作有关的事件</p>
</blockquote>
<ul>
<li><code>load</code>事件：当页面完全加载后在<code>window</code>上面触发，当所有框架都加载完毕时在<code>框架集</code>上面触发，当图像加载完毕时在<code>&lt;img&gt;</code>元素上面触发，或者当嵌入的内容加载完毕时在<code>&lt;object&gt;</code>元素上面触发。</li>
<li><code>unload</code>事件：当页面完全卸载后在<code>window</code>上面触发，当所有框架都卸载后在<code>框架集</code>上面触发，或者当嵌入的内容卸载完毕后在<code>&lt;object&gt;</code>元素上面触发。</li>
<li><code>abort</code>事件：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<code>&lt;object&gt;</code>元素上面触发。</li>
<li><code>error</code>事件：当发生JavaScript错误时在<code>window</code>上面触发，当无法加载图像时在<code>&lt;img&gt;</code>元素上面触发，当无法加载嵌入内容时在<code>&lt;object&gt;</code>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。</li>
<li><code>select</code>事件：当用户选择文本框（<code>&lt;input&gt;</code>或<code>&lt;texterea&gt;</code>）中的一或多个字符时触发。第14章将继续讨论这个事件。</li>
<li><code>resize</code>事件：当窗口或框架的大小变化时在<code>window</code>或<code>框架</code>上面触发。</li>
<li><code>scroll</code>事件：当用户滚动带滚动条的元素中的内容时，在<strong><code>该元素</code></strong>上面触发。<strong><code>&lt;body&gt;</code>元素中包含所加载页面的滚动条</strong></li>
</ul>
<h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><p>当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 <code>window</code> 上面的 <code>load</code> 事件,两种定义 <code>onload</code> 事件处理程序的方式,第一钟是用js给window对象绑定onload事件.第二种是是为<code>&lt;body&gt;</code>元素添加一个 <code>onload</code> 特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Loaded!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里也给事件处理程序传入了一个 <code>event</code> 对象。这个 <code>event</code> 对象中不包含有关这个事件的任何附加信息，但在兼容 DOM 的浏览器中，<code>event.target</code> 属性的值会被设置为 <code>document</code>，而 IE 并不会为这个事件设置 <code>srcElement</code> 属性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"alert('Loaded!')"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，在<code>window</code>上面发生的任何事件都可以在<code>&lt;body&gt;</code>元素中通过相应的特性来指定，因为在HTML中无法访问<code>window</code>元素。<strong>建议尽可能使用JavaScript方式</strong></p>
</blockquote>
<p>图像上面也可以触发 <code>load</code> 事件，无论是在 DOM 中的图像元素还是 HTML 中的图像元素。因此，可以在 HTML 中为任何图像指定 <code>onload</code> 事件处理程序</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"smile.gif"</span> <span class="attr">onload</span>=<span class="string">"alert('Image loaded.')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在创建新的<code>&lt;img&gt;</code>元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是<strong>要在指定 src 属性之前先指定事件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">  EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    alert(EventUtil.getTarget(event).src);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">  image.src = <span class="string">"smile.gif"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先为 <code>window</code> 指定了 <code>onload</code> 事件处理程序。原因在于，我们是想向 DOM 中添加一个新元素，所以必须确定页面已经加载完毕——如果在页面加载前操作 <code>document.body</code> 会导致错误,新图像元素不一定要从添加到文档后才开始下载，只要设置了 src 属性就会开始下载。</p>
</blockquote>
<p><code>&lt;script&gt;</code>元素也会触发 <code>load</code> 事件，以便开发人员确定动态加载的 JavaScript 文件是否加载完毕。与图像不同，只有在设置了<code>&lt;script&gt;</code>元素的 src 属性并将该元素添加到文档后，才会开始下载 JavaScript 文件。换句话说，对于<code>&lt;script&gt;</code>元素而言，指定 src 属性和指定事件处理程序的先后顺序就不重要了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  EventUtil.addHandler(script, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Loaded"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  script.src = <span class="string">"example.js"</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="unload事件"><a href="#unload事件" class="headerlink" title="unload事件"></a>unload事件</h4><p>这个事件在文档被完全卸载后触发,与 load 事件类似，也有两种指定 <code>onunload</code> 事件处理程序的方式。第一种方式是使用 JavaScript,第二种方式，也是为<code>&lt;body&gt;</code>元素添加一个特性（与 load 事件相似）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"unload"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Unloaded"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时生成的 <code>event</code> 对象在兼容 DOM 的浏览器中只包含 <code>target</code> 属性（值为 <code>document</code>）。IE8 及之 前版本则为这个事件对象提供了 <code>srcElement</code> 属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onunload=<span class="string">"alert('Unloaded!')"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><p>浏览器窗口被调整到一个新的高度或宽度时，就会触发<code>resize</code>事件。这个事件在<code>window</code>上面触发，因此可以通过JavaScript或<code>&lt;body&gt;</code>元素中的<code>onresize</code>特性来指定事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Resized"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与其他发生在 <code>window</code> 上的事件类似，在兼容 DOM 的浏览器中，传入事件处理程序中的 <code>event</code> 对象有一个 <code>target</code> 属性，值为 <code>document</code>；而 IE8 及之前版本则未提供任何属性。<br>浏览器窗口最小化或最大化时也会触发 <code>resize</code> 事件</p>
</blockquote>
<h4 id="scroll事件"><a href="#scroll事件" class="headerlink" title="scroll事件"></a>scroll事件</h4><blockquote>
<p>虽然<code>scroll</code>事件在<code>window</code>对象上触发, 但它实际表示的则是页面中元素的变化,混杂模式和旧版本浏览器可以通过<code>document.body</code>的<code>scrollLeft</code>,<code>scrollTop</code>监控这一变化,<strong>在标准模式下,所有浏览器</strong>(除safari3.1是靠document.body.scrollLeft)<strong>都会通过<code>&lt;html&gt;(document.documentElement)</code>的<code>scrollLeft</code>与<code>scrollTop</code>来反应这一变化</strong></p>
</blockquote>
<p>得到兼容代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123; <span class="comment">//标准模式</span></span><br><span class="line">    alert(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//混杂模式或旧浏览器</span></span><br><span class="line">    alert(<span class="built_in">document</span>.body.scrollTop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 <code>document.hasFocus()</code>方法及 <code>document.activeElement</code> 属性配合,可以知晓用户在页面上的行踪,有以下几个事件</p>
<ul>
<li><code>blur</code>事件：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</li>
<li><code>focus</code>事件：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</li>
<li><code>focusin</code>事件：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。</li>
<li><code>focusout</code>事件：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。</li>
</ul>
<p>当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：</p>
<ol>
<li><code>focusout</code>事件 在失去焦点的元素上触发；</li>
<li><code>focusin</code>事件 在获得焦点的元素上触发；</li>
<li><code>blur</code>事件 在失去焦点的元素上触发；</li>
<li><code>focus</code>事件 在获得焦点的元素上触发；</li>
</ol>
<blockquote>
<p>即使 <code>focus</code> 和 <code>blur</code> 不冒泡，也可以在捕获阶段侦听到它们。</p>
</blockquote>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul>
<li><code>click</code>事件：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。意味着<code>onclick</code>事件处理程序既可以通过键盘也可以通过鼠标执行。</li>
<li><code>dblclick</code>事件：在用户双击主鼠标按钮（一般是左边的按钮）时触发。</li>
<li><code>mousedown</code>事件：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</li>
<li><code>mouseenter</code>事件：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。</li>
<li><code>mouseleave</code>事件：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。</li>
<li><code>mousemove</code>事件：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</li>
<li><code>mouseout</code>事件：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</li>
<li><code>mouseover</code>事件：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。</li>
<li><code>mouseup</code>事件：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。</li>
</ul>
<blockquote>
<p>页面上的所有元素都支持鼠标事件。除了 <code>mouseenter</code> 和 <code>mouseleave</code>，所有鼠标事件都会<code>冒泡</code>，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。取消鼠标事件的默认行为还会影响其他事件<br><code>click</code> 和 <code>dblclick</code> 事件都会依赖于其他先行事件的触发<br>只有在同一个元素上相继触发 <code>mousedown</code> 和 <code>mouseup</code> 事件， 才会触发 <code>click</code> 事件<br>只有触发两次 <code>click</code> 事 件，才会触发一次 <code>dblclick</code> 事件</p>
</blockquote>
<p><code>mousedown</code>,<code>mouseup</code>,<code>click</code>,<code>dblclick</code>触发顺序</p>
<ol>
<li><code>mousedown</code></li>
<li><code>mouseup</code></li>
<li><code>click</code></li>
<li><code>mousedown</code></li>
<li><code>mouseup</code></li>
<li><code>click</code></li>
<li><code>dblclick</code></li>
</ol>
<h4 id="光标客户区坐标位置-event-clientX-event-clientY"><a href="#光标客户区坐标位置-event-clientX-event-clientY" class="headerlink" title="光标客户区坐标位置,event.clientX,event.clientY"></a>光标客户区坐标位置,event.clientX,event.clientY</h4><p><img src="https://i.loli.net/2017/12/28/5a445c9618b4d.jpg" alt=""></p>
<blockquote>
<p>鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象<code>event.clientX</code>和<code>event.clientY</code>属性中。它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。</p>
</blockquote>
<h4 id="光标页面坐标位置-event-pageX-event-pageY"><a href="#光标页面坐标位置-event-pageX-event-pageY" class="headerlink" title="光标页面坐标位置 event.pageX,event.pageY"></a>光标页面坐标位置 event.pageX,event.pageY</h4><blockquote>
<p>页面坐标通过事件对象 <code>event.pageX</code> 和 <code>event.pageY</code> 属性，能告诉你事件是在页面中的什么位置发生的<br>在页面没有滚动的情况下，<code>pageX</code> 和 <code>pageY</code> 的值与 <code>clientX</code> 和 <code>clientY</code> 的值相等。<br>IE8 及更早版本不支持事件对象上的页面坐标, 需要兼容代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> pageX = event.pageX,</span><br><span class="line">    pageY = event.pageY;</span><br><span class="line">  <span class="keyword">if</span> (pageX === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    pageX = event.clientX + (<span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pageY === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    pageY = event.clientY + (<span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">  &#125;</span><br><span class="line">  alert(<span class="string">"Page coordinates: "</span> + pageX + <span class="string">","</span> + pageY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="光标屏幕坐标位置-event-screenX-event-screenY"><a href="#光标屏幕坐标位置-event-screenX-event-screenY" class="headerlink" title="光标屏幕坐标位置 event.screenX,event.screenY"></a>光标屏幕坐标位置 event.screenX,event.screenY</h4><p><img src="https://i.loli.net/2017/12/28/5a445c9619b46.jpg" alt=""></p>
<blockquote>
<p>相对于整个电脑屏幕的位置。而通过 <code>event.screenX</code> 和 <code>event.screenY</code> 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息</p>
</blockquote>
<h4 id="modifier-key"><a href="#modifier-key" class="headerlink" title="modifier key"></a>modifier key</h4><blockquote>
<p>以下4个键都的值都是布尔值,都描述在鼠标或键盘行为中这些键是否按下了,按下返回true,否则返回false</p>
</blockquote>
<ul>
<li><code>event.shiftKey</code></li>
<li><code>event.ctrlKery</code></li>
<li><code>event.altKey</code></li>
<li><code>event.metaKey</code>,IE不支持</li>
</ul>
<h4 id="相关元素-event-relatedTarget"><a href="#相关元素-event-relatedTarget" class="headerlink" title="相关元素,event.relatedTarget"></a>相关元素,event.relatedTarget</h4><blockquote>
<p>下面的属性只涉及<code>mouseover</code>事件,<code>mouseout</code>事件,对于其他事件,属性是<code>null</code></p>
</blockquote>
<p><code>event.relatedTarget</code>属性,在<code>mouseover</code>事件中,<code>event.relatedTarget</code>是<strong>失去光标的元素</strong>,在<code>mouseout</code>事件中,<code>event.relatedTarget</code>是<strong>获得光标的元素</strong></p>
<p>IE8之前的版本不支持<code>event.relatedTarget</code>,用下面的属性代替<br><code>event.fromElement</code>代表了<code>mouseover</code>事件触发时,<strong>失去光标的元素</strong><br><code>event.toElement</code>代表了<code>mouseout</code>事件触发时,<strong>获得光标的元素</strong></p>
<p>针对相关元素得到兼容代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">//省略了其他代码</span></span><br><span class="line">  getRelatedTarget: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.fromElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//省略了其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="鼠标按钮-event-button"><a href="#鼠标按钮-event-button" class="headerlink" title="鼠标按钮 event.button"></a>鼠标按钮 event.button</h4><p><code>event.button</code>属性,只对<code>mousedown</code>事件,<code>mouseup</code>事件有效</p>
<blockquote>
<p>对于 <code>mousedown</code> 和 <code>mouseup</code> 事件来说，则在其 <code>event</code> 对象存在一个 <code>button</code> 属性，表示按下或释放的按钮。DOM 的 <code>button</code> 属性可能有如下 3 个值：<code>0</code> 表示主鼠标按钮，<code>1</code> 表示中间的鼠标按钮（鼠标滚轮按钮），<code>2</code> 表示次鼠标按钮</p>
<p>IE8及之前版本也提供<code>event.button</code>属性,但与<code>DOM</code>提供的值有很大差异</p>
</blockquote>
<ul>
<li><code>0</code>：表示没有按下按钮。</li>
<li><code>1</code>：表示按下了主鼠标按钮。</li>
<li><code>2</code>：表示按下了次鼠标按钮。</li>
<li><code>3</code>：表示同时按下了主、次鼠标按钮。</li>
<li><code>4</code>：表示按下了中间的鼠标按钮。</li>
<li><code>5</code>：表示同时按下了主鼠标按钮和中间的鼠标按钮。</li>
<li><code>6</code>：表示同时按下了次鼠标按钮和中间的鼠标按钮。</li>
<li><code>7</code>：表示同时按下了三个鼠标按钮。</li>
</ul>
<blockquote>
<p>将IE的规范转化为DOM规范,得到兼容函数,并加入<code>EventUtil</code>中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 获取鼠标键值</span></span><br><span class="line">  getButton: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.button;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (event.button) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">EventUtil.addHandler(div, <span class="string">"mousedown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  alert(EventUtil.getButton(event));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用 <code>onmouseup</code> 事件处理程序时，<code>event.button</code> 的值表示释放的是哪个按钮</p>
</blockquote>
<h4 id="更多事件信息-event-detail"><a href="#更多事件信息-event-detail" class="headerlink" title="更多事件信息,event.detail"></a>更多事件信息,event.detail</h4><blockquote>
<p>“DOM2 级事件”规范在 event 对象中还提供了 <code>event.detail</code> 属性，用于给出有关事件的更多信息</p>
</blockquote>
<p><code>event.detail</code>属性, 对于鼠标事件来说,表示给定位置上发生了多少次单机(一次<code>mousedown</code>与<code>mouseup</code>),<code>event.detail</code>从1开始计数,每次都会++,如果鼠标移动了位置,会置0</p>
<blockquote>
<p>这个属性不光表现元素某点上的点击数, 也会在鼠标滚轮滚动时以<code>+3</code>,<code>-3</code>两个值表示鼠标滚轮的滚动方向, 具体往后看一节</p>
<p>IE通过下列属性为鼠标提供了更多信息 </p>
</blockquote>
<ul>
<li><code>offsetX</code>：光标相对于目标元素边界的x坐标。</li>
<li><code>offsetY</code>：光标相对于目标元素边界的y坐标。</li>
<li><code>altLeft</code>：布尔值，表示是否按下了Alt键。如果altLeft的值为true，则altKey的值也为true。</li>
<li><code>ctrlLeft</code>：布尔值，表示是否按下了Ctrl键。如果ctrlLeft的值为true，则ctrlKey的值也为true。</li>
<li><code>shiftLeft</code>：布尔值，表示是否按下了Shift键。如果shiftLeft的值为true，则shiftKey的值也为true。</li>
</ul>
<h4 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h4><p><code>mousewheel</code> 事件。这个事件可以在任何元素上面触发，最终会冒泡到 <code>document</code>（IE8）或 <code>window</code>（IE9、Opera、 Chrome 及 Safari）</p>
<p><code>mousewheel</code> 事件的 <code>event</code> 对象, 除包含鼠标事件的所有标准信息外, 包含一个特殊的 <code>wheelDelta</code> 属性。当用户向前滚动鼠标滚轮时，<code>wheelDelta</code> 是 <code>120</code> 的倍数；当用 户向后滚动鼠标滚轮时，wheelDelta 是 <code>-120</code>的倍数</p>
<p><img src="https://i.loli.net/2017/12/28/5a445c95cea89.jpg" alt=""></p>
<blockquote>
<p>将 mousewheel 事件处理程序指定给页面中的任何元素或 <code>document</code> 对象，即可处理鼠标滚轮的交互操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  alert(event.wheelDelta);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子会在发生 <code>mousewheel</code> 事件时显示 <code>wheelDelta</code> 的值。多数情况下，只要知道鼠标滚轮滚动的方向就够了，而这通过检测 <code>wheelDelta</code> 的正负号就可以确定<br>在 Opera 9.5 之前的版本中，<code>wheelDelta</code> 值的正负号是颠倒的</p>
</blockquote>
<p><code>Firefox</code>支持一个名为<code>DomouseScroll</code>的类似事件,也实在鼠标滚轮滚动时触发.<code>DOMMouseScroll</code> 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性,有关鼠标滚轮的信息则保存在 <code>event.detail</code> 属性中，当向前滚动鼠标滚轮时，这个属性的值是<code>-3</code> 的倍数，当向后滚动 鼠标滚轮时，这个属性的值是 <code>3</code> 的倍数</p>
<p>可以将 <code>DOMMouseScroll</code> 事件添加到页面中的任何元素，而且该事件会冒泡到 <code>window</code> 对象。因此，可以像下面这样针对这个事件来添加事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"DOMMouseScroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  alert(event.detail);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/28/5a445c95e17df.jpg" alt=""></p>
<blockquote>
<p>综合两种滚动事件的特性,得到兼容代码,并放入<code>EventUtil</code>中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 得到鼠标滚动事件的event.wheelData的兼容代码</span></span><br><span class="line">  getWheelDelta: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">      <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -event.detail * <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleMouseWheel</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> delta = EventUtil.getWheelDelta(event);</span><br><span class="line">    alert(delta);</span><br><span class="line">  &#125;</span><br><span class="line">  EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, handleMouseWheel);</span><br><span class="line">  EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMMouseScroll"</span>, handleMouseWheel);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="触摸设备"><a href="#触摸设备" class="headerlink" title="触摸设备"></a>触摸设备</h4><blockquote>
<p>iOS和Android设备没有鼠标,在面向iPhone,iPod中的safari开发时,有以下几点注意</p>
</blockquote>
<ul>
<li>不支持dblclick事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。</li>
<li>轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生mousedown、mouseup和click事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了onclick事件处理程序的元素。</li>
<li>mousemove事件也会触发mouseover和mouseout事件。</li>
<li>两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件</li>
</ul>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul>
<li><code>keydown</code>事件：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</li>
<li><code>keypress</code>事件：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。Safari3.1之前的版本也会在用户按下非字符键时触发keypress事件。</li>
<li><code>keyup</code>事件：当用户释放键盘上的键时触发。</li>
</ul>
<blockquote>
<p>所有元素都支持以上 3 个事件，但只有在文本框中才常用到。<br>只有一个文本事件 <code>textInput</code>。这个事件是对 keypress 的补充，用意是在将文本显示给用户之 前更容易拦截文本。在文本插入文本框之前会触发 textInput 事件</p>
</blockquote>
<p>用户按下字符键, 事件触发顺序, 非字符键从中忽略<code>keypress</code></p>
<ol>
<li><code>keydown</code></li>
<li><code>keypress</code></li>
<li>文本框内容发生变化</li>
<li>(若此时按住了键没放,将重复触发<code>keydown</code>,<code>keypress</code>)</li>
<li><code>keyup</code></li>
</ol>
<blockquote>
<p>键盘事件与鼠标事件一样,都支持<code>event</code>对象中的<code>modifier key</code>特性. 它们分别是<code>event.shiftKey</code>,<code>event.ctrlKey</code>,<code>event.altKey</code>,<code>event.metaKey</code>(IE不支持metaKey)</p>
</blockquote>
<h4 id="键码-event-keyCode"><a href="#键码-event-keyCode" class="headerlink" title="键码 event.keyCode"></a>键码 event.keyCode</h4><p><code>event.keyCode</code>属性,发生 <code>keydown</code> 和 <code>keyup</code> 事件时，<code>event</code> 对象的 <code>keyCode</code> 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，<code>keyCode</code> 属性的值与 ASCII 码中对应小写字母或数字的编码相同, 与<code>shift</code>键状态无关</p>
<p><img src="https://i.loli.net/2017/12/28/5a445c964a1dd.jpg" alt=""><br><img src="https://i.loli.net/2017/12/28/5a445c9613f5d.jpg" alt=""></p>
<blockquote>
<p>。在 Firefox 和 Opera 中，按分号键时 keyCode 值为 59，也就是 ASCII 中分号的编码；但 IE 和 Safari 返回 186，即键盘中按键的键码。</p>
</blockquote>
<h4 id="字符编码-event-charCode"><a href="#字符编码-event-charCode" class="headerlink" title="字符编码 event.charCode"></a>字符编码 event.charCode</h4><p>发生 <code>keypress</code> 事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入或删除字符的键都会触发 keypress 事件；IE9、Firefox、Chrome 和 Safari 的 event 对象都支持一个 <code>event.charCode</code> 属性，这个属性只有在发生 <code>keypress</code> 事件时才包含值，而且这个值是按下的那个键所代表字符的 ASCII 编码。此时的 <code>event.keyCode</code> 通常等于 0 或者也可能等于所按键的键码。IE8及之前版本和 Opera则是在 <code>event.keyCode</code> 中保存字符的 ASCII 编码。</p>
<p>综上,得到兼容代码,放入<code>EventUtil</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">//省略的代码</span></span><br><span class="line">  getCharCode: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.charCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//省略的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在取得了字符编码之后，就可以使用 <code>String.fromCharCode()</code>将其转换成实际的字符</p>
</blockquote>
<h4 id="DOM-3级的变化"><a href="#DOM-3级的变化" class="headerlink" title="DOM 3级的变化"></a>DOM 3级的变化</h4><blockquote>
<p>先说结论,本章介绍的属性和防范都不建议使用</p>
</blockquote>
<p><code>event.key</code>,<code>event.char</code>属性, DOM3 级事件中的键盘事件，不再包含 <code>event.charCode</code> 属性，而是包含两个新属性：<code>event.key</code> 和 <code>event.char</code>。其中，<code>event.key</code> 属性是为了取代 <code>event.keyCode</code> 而新增的，它的值是一个字符串。在按下某个字符键时，<code>event.key</code> 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， <code>event.key</code> 的值是相应键的名（如“Shift” 或“Down”）。而 <code>event.char</code> 属性在按下字符键时的行为与 <code>event.key</code> 相同，但在按下非字符键时值为 null。</p>
<p>IE9 支持 <code>event.key</code> 属性，但不支持 <code>event.char</code> 属性。Safari 5 和 Chrome 支持名为 <code>event.keyIdentifier</code> 的类似属性， 在按下非字符键（例如 <code>Shift</code>）的情况下与 <code>event.key</code> 的值相同。对于字符键，<code>event.keyIdentifier</code> 返回一个格式 类似“U+0000”的字符串，表示 Unicode 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> identifier = event.key || event.keyIdentifier;</span><br><span class="line">  <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">    alert(identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于存在跨浏览器问题，因此本书不推荐使用 <code>event.key</code>、<code>event.keyIdentifier</code> 或 <code>event.char</code>。</p>
</blockquote>
<p><code>event.location</code> 属性，这是一个数值，表示按下了什么位置上的键, IE9 支持这个属性</p>
<ul>
<li><code>0</code> 表示默认键盘</li>
<li><code>1</code> 表示左侧位置（例如左位的 Alt 键）</li>
<li><code>2</code> 表示右侧位置（例如右侧的 Shift 键）</li>
<li><code>3</code> 表示数字小键盘</li>
<li><code>4</code> 表示移动设备键盘（也就是虚拟键盘）</li>
<li><code>5</code> 表示手柄（如任天堂 Wii 控制器）</li>
</ul>
<p>Safari 和 Chrome 支持名为 <code>event.keyLocation</code> 的等价属性，但即有 bug——值始终是 0，除非按下了数字键盘（此时，值 为 3）；否则，不会是 1、2、4、5。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> loc = event.location || event.keyLocation;</span><br><span class="line">  <span class="keyword">if</span> (loc) &#123;</span><br><span class="line">    alert(loc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与 key 属性一样，支持 <code>event.location</code> 的浏览器也不多，所以在跨浏览器开发中不推荐使用。</p>
</blockquote>
<p><code>event.getModifierState(&#39;Shift&#39;/&#39;Control&#39;/&#39;AltGraph&#39;/&#39;Meta&#39;) return boolean</code>,如果被检测的键按下了,返回true,否则返回false</p>
<blockquote>
<p>不推荐使用, 因为<code>modifier key</code>系列可以取得类似属性,且IE9是唯一支持该方法的浏览器</p>
</blockquote>
<h4 id="textInput事件"><a href="#textInput事件" class="headerlink" title="textInput事件"></a>textInput事件</h4><p><code>textInput</code>事件, 根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。</p>
<blockquote>
<p>与<code>keypress</code>事件的不同: </p>
</blockquote>
<ol>
<li>任何可以获得焦点的元素都可以触发<code>keypress</code>事件，但只有可编辑区域才能触发<code>textInput</code>事件。</li>
<li><code>textInput``事件只会在用户按下能够输入实际字符的键时才会被触发，而</code>keypress`事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）</li>
</ol>
<p><code>event.data</code>属性, 值是用户输入的字符（而非字符编码）。换句话说，用户在没有按上档键的情况下按下了 S 键，<code>event.data</code> 的值就是”s”，而如果在按住上档键时按下该键，<code>event.data</code> 的值就是”S”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"textInput"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  alert(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>event.inputMethod</code>属性，表示把文本输入到文本框中的方式,只有IE支持</p>
<ul>
<li>0，表示浏览器不确定是怎么输入的。</li>
<li>1，表示是使用键盘输入的。</li>
<li>2，表示文本是粘贴进来的。</li>
<li>3，表示文本是拖放进来的。</li>
<li>4，表示文本是使用IME输入的。</li>
<li>5，表示文本是通过在表单中选择某一项输入的。</li>
<li>6，表示文本是通过手写输入的（比如使用手写笔）。</li>
<li>7，表示文本是通过语音输入的。</li>
<li>8，表示文本是通过几种方法组合输入的。</li>
<li>9，表示文本是通过脚本输入的。</li>
</ul>
<h3 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h3><blockquote>
<p>复合事件（compositionevent）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（InputMethodEditor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。例如，使用拉丁文键盘的用户通过IME照样能输入日文字符<br>IE9+是唯一支持的浏览器,开发中用处不大,若需要深入查阅高程p384</p>
</blockquote>
<h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><blockquote>
<p> DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML或HTMLDOM设计的，并不特定于某种语言。DOM2级定义了如下变动事件。</p>
</blockquote>
<ul>
<li><code>DOMSubtreeModified</code>：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</li>
<li><code>DOMNodeInserted</code>：在一个节点作为子节点被插入到另一个节点中时触发。</li>
<li><code>DOMNodeRemoved</code>：在节点从其父节点中被移除时触发。</li>
<li><code>DOMNodeInsertedIntoDocument</code>：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发。</li>
<li><code>DOMNodeRemovedFromDocument</code>：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。</li>
<li><code>DOMAttrModified</code>：在特性被修改之后触发。</li>
<li><code>DOMCharacterDataModified</code>：在文本节点的值发生变化时触发。</li>
</ul>
<blockquote>
<p>浏览器中很少使用变动事件和 HTML 事件，因为使用它们会受到一些限制, 详情查阅p385-13.4.6</p>
</blockquote>
<h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><h4 id="contextmenu-事件"><a href="#contextmenu-事件" class="headerlink" title="contextmenu 事件"></a>contextmenu 事件</h4><blockquote>
<p>此事件表示何时应该显示右键菜单, 以便取消默认的右键菜单提供自定义菜单<br><code>contextmenu</code> 事件是冒泡的，因此可以为 <code>document</code> 指定一个事件处理程序，用以处理页面中发生的所有此类事件。这个事件的目标是发生用户操作的元素<br>在所有浏览器中都可以取消这个事件： 在兼容 DOM 的浏览器中，使用 <code>event.preventDefalut()</code>；在 IE 中，将 <code>event.returnValue</code> 的值 设置为 false。<br>因为 <code>contextmenu</code> 事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。通常使用 <code>contextmenu</code> 事件来显示自定义的上下文菜单，而使用 <code>onclick</code> 事件处理程序来隐藏该菜单。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Right click or Ctrl+click me to get a custom context menu. Click anywhere else to get the default context menu.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myMenu"</span> <span class="attr">style</span>=<span class="string">"position:absolute;visibility:hidden;background-color:silver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.nczonline.net"</span>&gt;</span>Nicholas' site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wrox.com"</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.yahoo.com"</span>&gt;</span>Yahoo!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">                </span><br><span class="line">    EventUtil.addHandler(div, <span class="string">"contextmenu"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        event = EventUtil.getEvent(event);</span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>);</span><br><span class="line">        menu.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">        menu.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">        menu.style.visibility = <span class="string">"visible"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>).style.visibility = <span class="string">"hidden"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h4><blockquote>
<p>页面关闭前弹出个对话框确认关闭,请按下面固定套路组织代码</p>
<p>为了显示这个弹出对话框，必须将 <code>event.returnValue</code> 的值设置为要显示给用户的字符串（对 IE 及 Fiefox 而言），同时作为函数的值返回（对 Safari 和 Chrome 而言）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"beforeunload"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">"I'm really going to miss you if you go."</span>;</span><br><span class="line">  event.returnValue = message;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a>DOMContentLoaded 事件</h4><blockquote>
<p><code>DOMContentLoaded</code> 事件在形成完整的 DOM 树之后就会触发， 不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕, 与<code>onload</code>事件区分<br>要处理 <code>DOMContentLoaded</code> 事件，可以为 <code>document</code> 或 <code>window</code> 添加相应的事件处理程序（尽管这个事件会冒泡到 <code>window</code>，但它的目标实际上是 <code>document</code>）。<br><code>DOMContentLoaded</code> 事件对象不会提供任何额外的信息（其 <code>target</code> 属性是 <code>document</code>）。<br>这个事件既可以添加事件处理程序，也可以执行其他 DOM 操作。这个事件始终都会在 <code>load</code> 事件之前触发。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Content loaded"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于不支持此事件的polyfill,无法保证在所有环境中该超时调用一定会早于 <code>load</code> 事件被触发。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h4><p>DOM文档中的某些部分提供了<code>readystatechange</code>事件。这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持<code>readystatechange</code>事件的每个对象都有一个<code>readyState</code>属性</p>
<ul>
<li><code>uninitialized（未初始化）</code>：对象存在但尚未初始化。</li>
<li><code>loading（正在加载）</code>：对象正在加载数据。</li>
<li><code>loaded（加载完毕）</code>：对象加载数据完成。</li>
<li><code>interactive（交互）</code>：可以操作对象了，但还没有完全加载。</li>
<li><code>complete（完成）</code>：对象已经加载完毕。</li>
</ul>
<blockquote>
<p>并非所有对象都会经历<code>readyState</code>的这几个阶段。换句话说，如果某个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。显然，这意味着<code>readystatechange</code>事件经常会少于4次，而<code>readyState</code>属性的值也不总是连续的。</p>
</blockquote>
<p>对于 <code>document</code> 而言，值为<code>interactive</code>的 <code>readyState</code> 会在与 <code>DOMContentLoaded</code> 大致相同的时刻触发 <code>readystatechange</code> 事件。此时，DOM 树已经加载完毕，可以安全地操作它了，因此就会进入交互<code>interactive</code>阶段。 但与此同时，图像及其他外部文件不一定可用</p>
<ul>
<li><code>uninitialized（未初始化）</code>：对象存在但尚未初始化。</li>
<li><code>loading（正在加载）</code>：对象正在加载数据。</li>
<li><code>loaded（加载完毕）</code>：对象加载数据完成。</li>
<li><code>interactive（交互）</code>：可以操作对象了，但还没有完全加载。</li>
<li><code>complete（完成）</code>：对象已经加载完毕。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"interactive"</span>) &#123;</span><br><span class="line">    alert(<span class="string">"Content loaded"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个事件的<code>event</code>对象不会提供任何信息，也没有目标对象。在与<code>load</code>事件一起使用时，无法预测两个事件触发的先后顺序。让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。<br>因此，为了尽可能抢到先机，有必要<strong>同时检测交互和完成阶段</strong>，如下面的例子所示。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"interactive"</span> || <span class="built_in">document</span>.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">    EventUtil.removeHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>.callee);</span><br><span class="line">    alert(<span class="string">"Content loaded"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然使用<code>readystatechange</code>可以十分近似地模拟<code>DOMContentLoaded</code>事件，但它们本质上还是不同的。在不同页面中，<code>load</code>事件与<code>readystatechange</code>事件并不能保证以相同的顺序触发。</p>
</blockquote>
<p><code>&lt;script&gt;</code>（在IE和Opera中）和<code>&lt;link&gt;</code>（仅IE中）元素也会触发<code>readystatechange</code>事件，可以用来确定外部的JavaScript和CSS文件是否已经加载完成。与在其他浏览器中一样，除非把动态创建的元素添加到页面中，否则浏览器不会开始下载外部资源。基于元素触发的<code>readystatechange</code>事件也存在同样的问题，即<code>readyState</code>属性无论等于<code>loaded</code>还是<code>complete</code>都可以表示资源已经可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// script标签添加readystatechange事件</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  EventUtil.addHandler(script, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">if</span> (target.readyState == <span class="string">"loaded"</span> || target.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">      EventUtil.removeHandler(target, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>.callee);</span><br><span class="line">      alert(<span class="string">"Script Loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  script.src = <span class="string">"example.js"</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// link标签添加readystatechange事件</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">  link.type = <span class="string">"text/css"</span>;</span><br><span class="line">  link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(link, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target.readyState == <span class="string">"loaded"</span> || target.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">      EventUtil.removeHandler(target, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>.callee);</span><br><span class="line">      alert(<span class="string">"CSS Loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  link.href = <span class="string">"example.css"</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(link);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子为新创建的<code>&lt;script&gt;</code>节点指定了一个事件处理程序。事件的目标是该节点本身，因此当触发<code>readystatechange</code>事件时，要检测目标的<code>readyState</code>属性是不是等于<code>loaded</code>或<code>complete</code>。如果进入了其中任何一个阶段，则移除事件处理程序（以防止被执行两次），并显示一个警告框。与此同时，就可以执行已经加载完毕的外部文件中的函数了。同样的编码方式也适用于通过<code>&lt;link&gt;</code>元素加载CSS文件的情况</p>
<p>支持readystatechange事件的浏览器有IE、Firfox4+和Opera。</p>
</blockquote>
<h4 id="pageshow-和-pagehide-事件"><a href="#pageshow-和-pagehide-事件" class="headerlink" title="pageshow 和 pagehide 事件"></a>pageshow 和 pagehide 事件</h4><p>Firefox和Opera有一个特性，名叫<code>往返缓存</code>（back-forwardcache，或bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存保存了DOM和JavaScript的状态实际上是将整个页面都保存在了内存里。如果页面位于bfcache中，那么再次打开该页面时就不会触发<code>load</code>事件。</p>
<blockquote>
<p>尽管由于内存中保存了整个页面的状态，不触发load事件也不应该会导致什么问题，但为了更形象地说明<code>bfcache</code>的行为，Firefox还是提供了一些新事件。<br>第一个事件就是<code>pageshow</code>事件，在页面显示时触发，无论该页面是否来自<code>bfcache</code>。在重新加载的页面中，<code>pageshow</code>会在<code>load</code>事件触发后触发；而对于<code>bfcache</code>中的页面，<code>pageshow</code>会在页面状态完全恢复的那一刻触发。另外要注意的是，虽然这个事件的目标是<code>document</code>，但必须将其事件处理程序添加到<code>window</code>。<br><code>pageshow</code> 事件的 <code>event</code> 对象还包含一个名为 <code>event.persisted</code> 的布尔值属性。 如果页面被保存在了 <code>bfcache</code> 中，则这个属性的值为 true；否则，这个属性的值为 false。通过检测 <code>event.persisted</code> 属性，就可以根据页面在 bfcache 中的状态来确定是否需要采取其他操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> showCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Load fired"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"pageshow"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    showCount++;</span><br><span class="line">    alert(<span class="string">"Show has been fired "</span> + showCount + <span class="string">" times. Persisted? "</span> + event.persisted);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每当触发<code>pageshow</code>事件，showCount的值就会递增并通过警告框显示出来。如果你在离开包含以上代码的页面之后，又单击“后退”按钮返回该页面，就会看到showCount每次递增的值。这是因为该变量的状态，乃至整个页面的状态，都被保存在了内存中，当你返回这个页面时，它们的状态得到了恢复。如果你单击了浏览器的“刷新”按钮，那么showCount的值就会被重置为0，因为页面已经完全重新加载了。</p>
</blockquote>
<p>同时又<code>pagehide</code> 事件，会在浏览器卸载页面的时候触发，而且是在 <code>unload</code> 事件之前触发。与 <code>pageshow</code> 事件一样，<code>pagehide</code> 在 <code>document</code> 上面触发，但其事件处理程序必须要添加到 <code>window</code> 对象。这个事件的 <code>event</code> 对象也包含 <code>event.persisted</code> 属性.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"pagehide"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hiding. Persisted? "</span> + event.persisted);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能需要在<code>pagehide</code>事件触发时根据<code>event.persisted</code>的值采取不同的操作。对于<code>pageshow</code>事件，如果页面是从<code>bfcache</code>中加载的，那么<code>event.persisted</code>的值就是true；对于<code>pagehide</code>事件，如果页面在卸载之后会被保存在<code>bfcache</code>中，那么<code>event.persisted</code>的值也会被设置为true。因此，当第一次触发<code>pageshow</code>时，<code>event.persisted</code>的值一定是false，而在第一次触发<code>pagehide</code>时，<code>event.persisted</code>就会变成true（除非页面不会被保存在<code>bfcache</code>中）。<br>指定了 <code>onunload</code> 事件处理程序的页面会被自动排除在 <code>bfcache</code> 之外，即使事件处理程序是空的。<br>IE9及之前版本不支持这两个事件。指定了onunload事件处理程序的页面会被自动排除在bfcache之外，即使事件处理程序是空的。</p>
</blockquote>
<h4 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange()事件"></a>hashchange()事件</h4><blockquote>
<p><code>URL</code>的<code>hash</code>值变化时触发<br><code>hashchange</code>应该添加给<code>window</code>对象, <code>event</code>对象包含两个属性<code>event.oldURL</code>与<code>event.newURL</code>,分别表示变化前后完整的URL，因为<code>event.oldURL</code>与<code>event.newURL</code>有兼容问题, 所以最好使用<code>location.hash</code>来确定当前的<code>hash</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(location.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><p>都是一些特定移动设备的事件,用处较少,详情查阅p395-13.4.8</p>
<h3 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h3><h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><ul>
<li><code>touchstart</code>：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</li>
<li><code>touchmove</code>：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，**调用<code>event.preventDefault()</code>可以阻止滚动。</li>
<li><code>touchend</code>：当手指从屏幕上移开时触发。</li>
<li><code>touchcancel</code>：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。</li>
</ul>
<blockquote>
<p>上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但它们却是以兼容DOM的方式实现的。因此，每个触摸事件的<code>event</code>对象都提供了在鼠标事件中常见的属性：<code>event.bubbles</code>、<code>event.cancelable</code>、<code>event.view</code>、<code>event.clientX</code>、<code>event.clientY</code>、<code>event.screenX</code>、<code>event.screenY</code>、<code>event.detail</code>、<code>event.altKey</code>、<code>event.shiftKey</code>、<code>event.ctrlKey</code>和<code>event.metaKey</code></p>
</blockquote>
<p>触摸事件的<code>event</code>对象除常见的DOM属性外, 触摸事件还包含下列三个用于跟踪触摸的属性:</p>
<ul>
<li><code>touches</code>：表示当前跟踪的触摸操作的<code>Touch对象</code>的数组。</li>
<li><code>targetTouchs</code>：特定于事件目标的<code>Touch对象</code>的数组。</li>
<li><code>changeTouches</code>：表示自上次触摸以来发生了什么改变的<code>Touch对象</code>的数组。</li>
</ul>
<p>每个<code>Touch对象</code>包含下列属性:</p>
<ul>
<li><code>clientX</code>：触摸目标在视口中的x坐标。</li>
<li><code>clientY</code>：触摸目标在视口中的y坐标。</li>
<li><code>identifier</code>：标识触摸的唯一ID。</li>
<li><code>pageX</code>：触摸目标在页面中的x坐标。</li>
<li><code>pageY</code>：触摸目标在页面中的y坐标。</li>
<li><code>screenX</code>：触摸目标在屏幕中的x坐标。</li>
<li><code>screenY</code>：触摸目标在屏幕中的y坐标。</li>
<li><code>target</code>：触摸的DOM节点目标。</li>
</ul>
<blockquote>
<p>使用这些属性可以跟踪用户对屏幕的触摸操作。来看下面的例子。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTouchEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//只跟踪一次触摸 </span></span><br><span class="line">  <span class="keyword">if</span> (event.touches.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"touchstart"</span>:</span><br><span class="line">        output.innerHTML = <span class="string">"Touch started ("</span> + event.touches[<span class="number">0</span>].clientX + <span class="string">","</span> + event.touches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"touchend"</span>:</span><br><span class="line">        output.innerHTML += <span class="string">"&lt;br&gt;Touch ended ("</span> + event.changedTouches[<span class="number">0</span>].clientX + <span class="string">","</span> + event.changedTouches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"touchmove"</span>:</span><br><span class="line">        event.preventDefault(); <span class="comment">//阻止滚动</span></span><br><span class="line">        output.innerHTML += <span class="string">"&lt;br&gt;Touch moved ("</span> + event.changedTouches[<span class="number">0</span>].clientX + <span class="string">","</span> + event.changedTouches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchstart"</span>, handleTouchEvent);</span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchend"</span>, handleTouchEvent);</span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchmove"</span>, handleTouchEvent);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码会跟踪屏幕上发生的一次触摸操作。为简单起见，只会在有一次活动触摸操作的情况下输出信息。当<code>touchstart</code>事件发生时，会将触摸的位置信息输出到<code>&lt;div&gt;</code>元素中。当<code>touchmove</code>事件发生时，会取消其默认行为，阻止滚动（触摸移动的默认行为是滚动页面），然后输出触摸操作的变化信息。而<code>touchend</code>事件则会输出有关触摸操作的最终信息。注意，在<code>touchend</code>事件发生时，<code>touches</code>集合中就没有任何<code>Touch对象</code>了，因为不存在活动的触摸操作；此时，就必须转而使用<code>changeTouchs</code>集合。</p>
<p>这些事件会在文档的所有元素上面触发，因而可以分别操作页面的不同部分。在触摸屏幕上的元素时，这些事件（包括鼠标事件）发生的顺序如下：</p>
</blockquote>
<ol>
<li>touchstart</li>
<li>mouseover</li>
<li>mousemove（一次）</li>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>touchend</li>
</ol>
<h4 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h4><p>Safari还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件:</p>
<ul>
<li><code>gesturestart</code>：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。</li>
<li><code>gesturechange</code>：当触摸屏幕的任何一个手指的位置发生变化时触发。</li>
<li><code>gestureend</code>：当任何一个手指从屏幕上面移开时触发。</li>
</ul>
<blockquote>
<p>只有两个手指都触摸到事件的接收容器时才会触发这些事件。由于这些事件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都位于其范围内的那个元素。</p>
</blockquote>
<p>触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发touchstart事件。如果另一个手指又放在了屏幕上，则会先触发gesturestart事件，随后触发基于该手指的touchstart事件。如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件。但只要有一个手指移开，就会触发gestureend事件，紧接着又会触发基于该手指的touchend事件。</p>
<p>与触摸事件一样，每个手势事件的<code>event</code>对象都包含着标准的鼠标事件属性：<code>event.bubbles</code>、<code>event.cancelable</code>、<code>event.view</code>、<code>event.clientX</code>、<code>event.clientY</code>、<code>event.screenX</code>、<code>event.screenY</code>、<code>event.detail</code>、<code>event.altKey</code>、<code>event.shiftKey</code>、<code>event.ctrlKey</code>和<code>event.metaKey</code>。</p>
<p>此外，还包含两个额外的属性：</p>
<ul>
<li><code>event.rotation</code>属性，表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。</li>
<li><code>event.scale</code>属性,而<code>event.scale</code>属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从1开始，并随距离拉大而增长，随距离缩短而减小。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleGestureEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</span><br><span class="line">  <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"gesturestart"</span>:</span><br><span class="line">      output.innerHTML = <span class="string">"Gesture started (rotation="</span> + event.rotation + <span class="string">",scale="</span> + event.scale + <span class="string">")"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"gestureend"</span>:</span><br><span class="line">      output.innerHTML += <span class="string">"&lt;br&gt;Gesture ended (rotation="</span> + event.rotation + <span class="string">",scale="</span> + event.scale + <span class="string">")"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"gesturechange"</span>:</span><br><span class="line">      output.innerHTML += <span class="string">"&lt;br&gt;Gesture changed (rotation="</span> + event.rotation + <span class="string">",scale="</span> + event.scale + <span class="string">")"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"gesturestart"</span>, handleGestureEvent, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"gestureend"</span>, handleGestureEvent, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"gesturechange"</span>, handleGestureEvent, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>触摸事件也会返回 <code>event.rotation</code> 和 <code>event.scale</code> 属性，但这两个属性只会在两个手指与 屏幕保持接触时才会发生变化。</p>
</blockquote>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>直接看代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;ul id="myLinks"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;li id="goSomewhere"&gt;Go somewhere&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;li id="doSomething"&gt;Do something&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;li id="sayHi"&gt;Say hi&lt;/li&gt;</span></span><br><span class="line"><span class="comment">// &lt;/ul&gt;</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"myLinks"</span>);</span><br><span class="line">  EventUtil.addHandler(list, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (target.id) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"doSomething"</span>:</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</span><br><span class="line">        location.href = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">"sayHi"</span>:</span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码性能更好, 适合事件维脱的事件包括<code>click</code>,<code>mousedown</code>,<code>mouseup</code>,<code>keyup</code>,<code>keydown</code>,<code>keypress</code>, 虽然<code>mouseover</code>和<code>mouseout</code>不适合委托</p>
</blockquote>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>内存中留有那些过时不用的“空事件处理程序”（danglingeventhandler），也是造成Web应用程序内存与性能问题的主要原因。</p>
<p>在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的DOM操作，例如使用<code>element.removeChild()</code>和<code>element.replaceChild()</code>方法，但更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被<code>innerHTML</code>删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。</p>
<blockquote>
<p>在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。</p>
<p>采用<code>事件委托</code>也有助于解决这个问题。如果事先知道将来有可能使用<code>innerHTML</code>替换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素中。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* &lt;div id="myDiv"&gt;</span></span><br><span class="line"><span class="comment">  &lt;input type="button" value="Click Me" id="myBtn"&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;   */</span>&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//先执行某些操作 </span></span><br><span class="line">  btn.onclick = <span class="literal">null</span>; <span class="comment">//移除事件处理程序 </span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"Processing..."</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><blockquote>
<p>可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是说，这些事件该冒泡还会冒泡，而且照样能够导致浏览器执行已经指定的处理它们的事件处理程序。在测试Web应用程序，模拟触发事件是一种极其有用的技术。</p>
</blockquote>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><ul>
<li><code>document.createEvent(string) return event</code> 返回的<code>event</code>是模拟事件的事件对象, 参数<code>string</code>是固定的字符串,可取值如下<ul>
<li><code>UIEvents</code>：一般化的UI事件。鼠标事件和键盘事件都继承自UI事件。DOM3级中是UIEvent。</li>
<li><code>MouseEvents</code>：一般化的鼠标事件。DOM3级中是MouseEvent。</li>
<li><code>MutationEvents</code>：一般化的DOM变动事件。DOM3级中是MutationEvent。</li>
<li><code>HTMLEvents</code>：一般化的HTML事件。没有对应的DOM3级事件（HTML事件被分散到其他类别中）。</li>
<li><code>KeyboardEvent</code>: 键盘事件</li>
<li><code>Event</code>: 通用事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>IE9是目前唯一支持DOM3级键盘事件的浏览器。不过，在其他浏览器中，在现有方法的基础上，可以通过几种方式来模拟键盘事件。</p>
</blockquote>
<ul>
<li><p><code>event.initMouseEvent(...args)</code> 在创建了event对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的event对象都有一个特殊的方法，为它传入适当的数据就可以初始化该<code>event</code>对象。不同类型的这个方法的名字也不相同，具体要取决于<code>document.createEvent()</code>中使用的参数。</p>
</li>
<li><p><code>element.dispatchEvent(event)</code> 所有支持事件的DOM节点都支持这个方法。调用<code>element.dispatchEvent()</code>方法时，需要传入一个参数，即表示要触发事件的event对象。触发事件之后，该事件就跻身“官方事件”之列了，因而能够照样冒泡并引发相应事件处理程序的执行。</p>
</li>
</ul>
<h4 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a>模拟鼠标事件</h4><p>创建鼠标事件对象的方法是 为 <code>document.createEvent()</code>传入字符串<code>MouseEvents</code>。返回的<code>event</code>对象有一个名为 <code>event.initMouseEvent()</code>方法， 用于指定与该鼠标事件有关的信息。这个方法接收 15 个参数，</p>
<ul>
<li><code>type（字符串）</code>：表示要触发的事件类型，例如<code>click</code>。</li>
<li><code>bubbles（布尔值）</code>：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true。</li>
<li><code>cancelable（布尔值）</code>：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为true。</li>
<li><code>view（AbstractView）</code>：与事件关联的视图。这个参数几乎总是要设置为<code>document.defaultView</code>。</li>
<li><code>detail（整数）</code>：与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0。</li>
<li><code>screenX（整数）</code>：事件相对于屏幕的X坐标。</li>
<li><code>screenY（整数）</code>：事件相对于屏幕的Y坐标。</li>
<li><code>clientX（整数）</code>：事件相对于视口的X坐标。</li>
<li><code>clientY（整数）</code>：事件想对于视口的Y坐标。</li>
<li><code>ctrlKey（布尔值）</code>：表示是否按下了Ctrl键。默认值为false。</li>
<li><code>altKey（布尔值）</code>：表示是否按下了Alt键。默认值为false。</li>
<li><code>shiftKey（布尔值）</code>：表示是否按下了Shift键。默认值为false。</li>
<li><code>metaKey（布尔值）</code>：表示是否按下了Meta键。默认值为false。</li>
<li><code>button（整数）</code>：表示按下了哪一个鼠标键。默认值为0。</li>
<li><code>relatedTarget（对象）</code>：表示与事件相关的对象。这个参数只在模拟<code>mouseover</code>事件或<code>mouseout</code>事件时使用。</li>
</ul>
<blockquote>
<p><code>event.initMouseEvent()</code>方法的这些参数是与鼠标事件的<code>event</code>对象所包含的属性一一对应的。其中，前4个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数只有在事件处理程序中才会用到。当把<code>event</code>对象传给<code>element.dispatchEvent(event)</code>方法时，这个对象的<code>event.target</code>属性会自动设置。下面，我们就通过一个例子来了解如何模拟对按钮的单击事件。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件对象 </span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化事件对象 </span></span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件 </span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<h4 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a>模拟键盘事件</h4><p>DOM3级规定，调用<code>document.createEvent()</code>并传入<code>KeyboardEvent</code>就可以创建一个键盘事件。返回的<code>event</code>事件对象会包含一个<code>event.initKeyEvent()</code>方法，这个方法接收下列参数。</p>
<ul>
<li><code>type（字符串）</code>：表示要触发的事件类型，如”keydown”。</li>
<li><code>bubbles（布尔值）</code>：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。</li>
<li><code>cancelable（布尔值）</code>：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。</li>
<li><code>view（AbstractView）</code>：与事件关联的视图。这个参数几乎总是要设置为<code>document.defaultView</code>。</li>
<li><code>key</code>：表示按下的键的键码。</li>
<li><code>location（整数）</code>：表示按下了哪里的键。0表示默认的主键盘，1表示左，2表示右，3表示数字键盘，4表示移动设备（即虚拟键盘），5表示手柄。</li>
<li><code>modifiers（字符串）</code>：空格分隔的修改键列表，如”Shift”。</li>
<li><code>repeat（整数）</code>：在一行中按了这个键多少次。由于DOM3级不提倡使用<code>keypress</code>事件，因此只能利用这种技术来模拟<code>keydown</code>和<code>keyup</code>事件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>),event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以 DOM3 级方式创建事件对象 </span></span><br><span class="line"><span class="comment">//先检测浏览器是否支持 DOM3 级事件；其他浏览器返回一个非标准的 KeyboardEvent 对象。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"KeyboardEvents"</span>, <span class="string">"3.0"</span>)) &#123;</span><br><span class="line">  event = <span class="built_in">document</span>.createEvent(<span class="string">"KeyboardEvent"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化事件对象 </span></span><br><span class="line">  event.initKeyboardEvent(<span class="string">"keydown"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="string">"a"</span>, <span class="number">0</span>, <span class="string">"Shift"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件 </span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<h4 id="在Firefox模拟键盘事件"><a href="#在Firefox模拟键盘事件" class="headerlink" title="在Firefox模拟键盘事件"></a>在Firefox模拟键盘事件</h4><p>在Firefox中，调用<code>document.createEvent()</code>并传入<code>KeyEvents</code>就可以创建一个键盘事件。返回的<code>event</code>事件对象会包含一个<code>event.initKeyEvent()</code>方法，这个方法接受下列10个参数。</p>
<ul>
<li><code>type（字符串）</code>：表示要触发的事件类型，如”keydown”。</li>
<li><code>bubbles（布尔值）</code>：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。</li>
<li><code>cancelable（布尔值）</code>：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。</li>
<li><code>view（AbstractView）</code>：与事件关联的视图。这个参数几乎总是要设置为document.defaultView。</li>
<li><code>ctrlKey（布尔值）</code>：表示是否按下了Ctrl键。默认值为false。</li>
<li><code>altKey（布尔值）</code>：表示是否按下了Alt键。默认值为false。</li>
<li><code>shiftKey（布尔值）</code>：表示是否按下了Shift键。默认值为false。</li>
<li><code>metaKey（布尔值）</code>：表示是否按下了Meta键。默认值为false。</li>
<li><code>keyCode（整数）</code>：被按下或释放的键的键码。这个参数对keydown和keyup事件有用，默认值为0。</li>
<li><code>charCode（整数）</code>：通过按键生成的字符的ASCII编码。这个参数对keypress事件有用，默认值为0。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只适用于 Firefox </span></span><br><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件对象 </span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"KeyEvents"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化事件对象 </span></span><br><span class="line">event.initKeyEvent(<span class="string">"keypress"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件 </span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<h4 id="在其他浏览器中模拟键盘事件"><a href="#在其他浏览器中模拟键盘事件" class="headerlink" title="在其他浏览器中模拟键盘事件"></a>在其他浏览器中模拟键盘事件</h4><p>在其他浏览器中，则需要创建一个通用的事件，然后再向事件对象中添加键盘事件特有的信息。在此必须要使用通用事件，而不能使用UI事件，因为UI事件不允许向event对象中再添加新属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在不支持DOM3的浏览器中模拟键盘事件</span></span><br><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件对象 </span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"Events"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化事件对象 </span></span><br><span class="line">event.initEvent(type, bubbles, cancelable);</span><br><span class="line">event.view = <span class="built_in">document</span>.defaultView;</span><br><span class="line">event.altKey = <span class="literal">false</span>;</span><br><span class="line">event.ctrlKey = <span class="literal">false</span>;</span><br><span class="line">event.shiftKey = <span class="literal">false</span>;</span><br><span class="line">event.metaKey = <span class="literal">false</span>;</span><br><span class="line">event.keyCode = <span class="number">65</span>;</span><br><span class="line">event.charCode = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发事件 </span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<h4 id="模拟其他事件"><a href="#模拟其他事件" class="headerlink" title="模拟其他事件"></a>模拟其他事件</h4><ul>
<li>模拟HTML事件</li>
</ul>
<blockquote>
<p>要模拟HTML事件，同样需要先创建一个<code>event</code>对象——通过<code>document.createEvent(&quot;HTMLEvents&quot;)</code>，然后再使用这个对象的<code>event.initEvent()</code>方法来初始化它即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"HTMLEvents"</span>);</span><br><span class="line">event.initEvent(<span class="string">"focus"</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">target.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟变动事件: 变动事件应用太少,详情查阅高程p409</li>
</ul>
<blockquote>
<p>浏览器中很少使用变动事件和 HTML 事件，因为使用它们会受到一些限制。</p>
</blockquote>
<h4 id="自定义DOM事件"><a href="#自定义DOM事件" class="headerlink" title="自定义DOM事件"></a>自定义DOM事件</h4><p>DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用<code>document.createEvent(&quot;CustomEvent&quot;)</code>。返回的<code>event</code>对象有一个名为<code>event.initCustomEvent()</code>的方法，接收如下4个参数。</p>
<ul>
<li><code>type（字符串）</code>：触发的事件类型，例如”keydown”。</li>
<li><code>bubbles（布尔值）</code>：表示事件是否应该冒泡。</li>
<li><code>cancelable（布尔值）</code>：表示事件是否可以取消。</li>
<li><code>detail（对象）</code>：任意值，保存在event对象的detail属性中。</li>
</ul>
<blockquote>
<p>可以像分派其他事件一样在 DOM 中分派创建的自定义事件对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>),</span><br><span class="line">  event;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(div, <span class="string">"myevent"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"DIV: "</span> + event.detail);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"myevent"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  alert(<span class="string">"DOCUMENT: "</span> + event.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CustomEvents"</span>, <span class="string">"3.0"</span>)) &#123;</span><br><span class="line">  event = <span class="built_in">document</span>.createEvent(<span class="string">"CustomEvent"</span>);</span><br><span class="line">  event.initCustomEvent(<span class="string">"myevent"</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"Hello world!"</span>);</span><br><span class="line">  div.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子创建了一个冒泡事件<code>myevent</code>。而<code>event.detail</code>的值被设置成了一个简单的字符串，然后在<code>&lt;div&gt;</code>元素和<code>document</code>上侦听这个事件。因为<code>event.initCustomEvent()</code>方法已经指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到<code>document</code>。<br>支持自定义DOM事件的浏览器有IE9+和Firefox6+。</p>
</blockquote>
<h3 id="IE中的事件模拟"><a href="#IE中的事件模拟" class="headerlink" title="IE中的事件模拟"></a>IE中的事件模拟</h3><p>在IE8及之前版本中模拟事件有类似但不一样的方式,这部分内容应用较少,详情查看高程p410</p>
<h2 id="EventUtil代码"><a href="#EventUtil代码" class="headerlink" title="EventUtil代码"></a>EventUtil代码</h2><blockquote>
<p>附上本章总结的EventUtil代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 事件绑定</span></span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 事件解绑</span></span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得事件对象</span></span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件触发对象</span></span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 阻止浏览器默认事件</span></span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件流</span></span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取鼠标键值</span></span><br><span class="line">  getButton: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.button;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (event.button) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获得mouseover,mouseout的相关元素</span></span><br><span class="line">  getRelatedTarget: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.fromElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 得到鼠标滚动事件的event.wheelData的兼容代码</span></span><br><span class="line">  getWheelDelta: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">      <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -event.detail * <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获得按键字符编码</span></span><br><span class="line">  getCharCode: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.charCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 剪贴板内容获取和赋值</span></span><br><span class="line">  getClipboardText: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setClipboardText: <span class="function"><span class="keyword">function</span> (<span class="params">event, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.clipboardData) &#123;</span><br><span class="line">      event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData) &#123;</span><br><span class="line">      <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/24/高程vol7-dom2-dom3/" class="next">上一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>