<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正反馈系列:《JavaScript高级程序设计》DOM2 & DOM3 · choteewang</title><meta name="description" content="正反馈系列:《JavaScript高级程序设计》DOM2 &amp; DOM3 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li><li class="nav-list-item"><a href="https://github.com/choteewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">正反馈系列:《JavaScript高级程序设计》DOM2 & DOM3</h1><div class="post-info">2017年12月24日</div><div class="post-content"><h2 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h2><h3 id="node-isSameNode-node-isEqualNode"><a href="#node-isSameNode-node-isEqualNode" class="headerlink" title="node.isSameNode,node.isEqualNode"></a>node.isSameNode,node.isEqualNode</h3><ul>
<li><code>node.isSameNode(node1) return boolean</code> node与node1引用的是同一个对象,返回true</li>
<li><code>node.isEqualNode(node1) return boolean</code> node与node1两个节点是相同的类型,具有相等的属性(nodeName,nodeValue灯灯),且它们的attribute与childNodes属性也相等(相同位置包含相同的值),返回true</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); </span><br><span class="line">div1.setAttribute(<span class="string">"class"</span>, <span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); </span><br><span class="line">div2.setAttribute(<span class="string">"class"</span>, <span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line">alert(div1.isSameNode(div1)); <span class="comment">//true </span></span><br><span class="line">alert(div1.isEqualNode(div2)); <span class="comment">//true </span></span><br><span class="line">alert(div1.isSameNode(div2)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="element-setUserData-element-getUserData"><a href="#element-setUserData-element-getUserData" class="headerlink" title="element.setUserData(),element.getUserData()"></a>element.setUserData(),element.getUserData()</h3><ul>
<li><p><code>element.setUserData(key,value,callback(operation,key,value,src,dest))</code></p>
<ul>
<li><code>operation</code> 表示操作类型的数值(1复制,2导入,3删除,4重命名)</li>
<li><code>key</code> 数据键</li>
<li><code>value</code> 数据值</li>
<li><code>src</code> 源节点,删除节点时,src == null</li>
<li><code>dest</code> 目标节点, 除复制节点时, dest == null</li>
</ul>
</li>
</ul>
<blockquote>
<p>此方法针对DOM节点添加额外数据引入了新方法. <code>setUserData()</code>会将数据指定给节点<br><code>callback</code>将在带有数据的节点被复制,删除,重命名,或引入一个文档时被调用,用callback事先决定在上述操作发生时如何处理用户数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.setUserData(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">operation, key, value, src, dest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (operation == <span class="number">1</span>) &#123;</span><br><span class="line">    dest.setUserData(key, value, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newDiv = div.cloneNode(<span class="literal">true</span>);</span><br><span class="line">alert(newDiv.getUserData(<span class="string">"name"</span>)); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，先创建了一个<code>&lt;div&gt;</code>元素，然后又为它添加了一些数据（用户数据）。在使用 cloneNode() 复制这个元素时，就会调用处理函数，从而将数据自动复制到了副本节点。结果在通过副本节点调用 getUserData()时，就会返回与原始节点中包含的相同的值。</p>
</blockquote>
<ul>
<li><code>element.getUserData(key)</code> 取得<code>setUserData</code>输入的对应<code>value</code>值</li>
</ul>
<h3 id="frame-contentDocument-frame-contentWindow-document"><a href="#frame-contentDocument-frame-contentWindow-document" class="headerlink" title="frame.contentDocument,frame.contentWindow.document"></a>frame.contentDocument,frame.contentWindow.document</h3><p>框架和内嵌框架分别用 <code>HTMLFrameElement</code> 和 <code>HTMLIFrameElement</code> 表示，它们在 DOM2 级中都有 了一个新属性，名叫 <code>contentDocument</code>。这个属性包含一个指针，指向表示框架内容的文档对象。</p>
<p>由于 <code>contentDocument</code> 属性是 Document 类型的实例，因此可以像使用<code>document对象</code>一样使用它，包括所有属性和方法</p>
<p>IE8之前不支持<code>contentDocument</code>,用<code>contentWindow.document</code>代替(所有浏览器都支持contentWindow属性)</p>
<blockquote>
<p>兼容代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>); </span><br><span class="line"><span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br></pre></td></tr></table></figure>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="element-style特性"><a href="#element-style特性" class="headerlink" title="element.style特性"></a>element.style特性</h3><p>既可以按照css名访问css特性,也可以调用下面的属性和方法</p>
<ul>
<li><code>cssText</code>：通过它能够访问到 style 特性中的 CSS 代码,重新赋值将重写元素行内css </li>
<li><code>length</code>：应用给元素的 CSS 属性的数量。 </li>
<li><code>parentRule</code>：表示 CSS 信息的 CSSRule 对象。本节后面将讨论 CSSRule 类型。 </li>
<li><code>getPropertyCSSValue(propertyName)</code>：返回包含给定属性值的 CSSValue 对象。此对象两个属性分别为<code>cssText</code>,该属性与<code>getPropertyValue()</code>方法返回值相同,<code>cssValueType</code>是一个数值常量,表示值类型:0表示继承的值,1表示基本的值,2表示值列表,3表示自定义的值, </li>
<li><code>getPropertyPriority(propertyName)</code>：如果给定的属性使用了!important 设置，则返回 “important”；否则，返回空字符串。 </li>
<li><code>getPropertyValue(propertyName)</code>：返回给定属性的字符串值。 </li>
<li><code>item(index)</code>：返回给定位置的 CSS 属性的名称,也可以用方括号语法<code>style[i]</code>。 </li>
<li><code>removeProperty(propertyName)</code>：从样式中删除给定属性。 </li>
<li><code>setProperty(propertyName,value,priority)</code>：将给定属性设置为相应的值，并加上优先 权标志（”important”或者一个空字符串）。</li>
</ul>
<blockquote>
<p>CSSStyleDeclaration实例,只包含行内style定义的信息,短划线转驼峰,<code>float</code>转<code>cssFloat</code>,键值对,值是css对应的字符串,可读可写</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置背景颜色 </span></span><br><span class="line">myDiv.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变大小 </span></span><br><span class="line">myDiv.style.width = <span class="string">"100px"</span>; </span><br><span class="line">myDiv.style.height = <span class="string">"200px"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定边框 </span></span><br><span class="line">myDiv.style.border = <span class="string">"1px solid black"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可读</span></span><br><span class="line">alert(myDiv.style.backgroundColor); </span><br><span class="line">alert(myDiv.style.width); </span><br><span class="line">alert(myDiv.style.height);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop, value, i, len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = myDiv.style.length; i &lt; len; i++) &#123;</span><br><span class="line">  prop = myDiv.style[i]; <span class="comment">//或者 myDiv.style.item(i)</span></span><br><span class="line">  value = myDiv.style.getPropertyValue(prop);</span><br><span class="line">  alert(prop + <span class="string">" : "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop, value, i, len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = myDiv.style.length; i &lt; len; i++) &#123;</span><br><span class="line">  prop = myDiv.style[i]; <span class="comment">//或者 myDiv.style.item(i)</span></span><br><span class="line">  value = myDiv.style.getPropertyCSSValue(prop);</span><br><span class="line">  alert(prop + <span class="string">" : "</span> + value.cssText + <span class="string">" ("</span> + value.cssValueType + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际开发中,<code>getPropertyCSSValue()</code>使用得比 <code>getPropertyValue()</code>少得多</p>
</blockquote>
<h3 id="document-defaultView-getComputedStyle"><a href="#document-defaultView-getComputedStyle" class="headerlink" title="document.defaultView.getComputedStyle()"></a>document.defaultView.getComputedStyle()</h3><p><code>document.defaultView.getComputedStyle(element,null/:after/:before) return CSSStyleDeclaration</code></p>
<blockquote>
<p>该方法将各种引入的css经一并计算,返回一个element元素的css属性键值对.只读,若要设置应通过<code>element.style</code>属性设置.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">alert(computedStyle.backgroundColor); <span class="comment">// "red"</span></span><br><span class="line">alert(computedStyle.width); <span class="comment">// "100px"</span></span><br><span class="line">alert(computedStyle.height); <span class="comment">// "200px"</span></span><br><span class="line">alert(computedStyle.border); <span class="comment">//"1px solid black"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IE不支持<code>getComputedStyle</code>方法,有一个类似概念,每个具有<code>style</code>属性的元素还有一个<code>currentStyle</code>属性</p>
</blockquote>
<p><code>element.currentStyle</code>属性,是一个与<code>getComputedStyle</code>返回值一个套路的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> computedStyle = myDiv.currentStyle;</span><br><span class="line">alert(computedStyle.backgroundColor); <span class="comment">//"red"</span></span><br><span class="line">alert(computedStyle.width); <span class="comment">//"100px"</span></span><br><span class="line">alert(computedStyle.height); <span class="comment">//"200px"</span></span><br><span class="line">alert(computedStyle.border); <span class="comment">//undefined</span></span><br><span class="line">alert(computedStyle.borderLeftWidth); <span class="comment">//"1px"</span></span><br></pre></td></tr></table></figure>
<h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><blockquote>
<p>js除了提供了上述元素的css读写api,还提供了api可以直接操作样式表<br>这部分知识简单而又凌乱,且在开发过程中应用不广泛, 这里只做结构性介绍, 详情查阅高程p317</p>
</blockquote>
<p><code>CssStyleSheet</code>类型表示样式表,继承自<code>StyleSheet</code>,应用于文档的样式表示通过<code>document.styleSheets</code>集合表示,这是一个伪数组,有<code>length</code>属性,可以使用<code>方括号</code>语法或<code>.item(index)</code>方法来访问每一项,每一项的值都是一个<code>CssStyleSheet</code>.</p>
<p><code>CssRule</code>对象表示样式表中的每条规则,最常见的<code>CssRule</code>类型就是<code>CssStyleRule</code>类型(其他规则还有@import,@font-face,@page,@charset等),代表<code>css样式语句</code>,<code>CssRule</code>中的<code>style</code>属性像<code>element.style</code>属性一样存放着css键值对.</p>
<p><code>sheet.insertRule()</code>方法可以创建<code>css规则</code>(css语句),<code>sheet.deleteRule()</code>方法可以删除<code>css规则</code>(css语句), <strong>上述说的都不推荐在开发中使用</strong>,请替换为第10章中的<code>动态加载样式表</code>技术.</p>
<h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h3 id="offset-dimension"><a href="#offset-dimension" class="headerlink" title="offset dimension"></a>offset dimension</h3><ul>
<li><code>element.offsetParent</code>属性,是一个<strong>只读</strong>属性.<ol>
<li>返回一个指向最近的（closest，指包含层级上的最近）包含该元素的<code>定位元素</code>。</li>
<li>如果没有定位的元素，则 offsetParent 为最近的 <code>table</code>, <code>table cell</code> 或<code>根元素</code>（标准模式下为 <code>html</code>；quirks 模式下为 <code>body</code>）。当元素的 style.display 设置为 <code>none</code> 时，offsetParent 返回 <code>null</code></li>
</ol>
</li>
<li><p><code>element.offsetWidth</code>,<code>element.offsetHeight</code>,元素水平或垂直方向上占用空间的大笑,以像素计,包括元素的高度,(可见的)水平滚动条的高度,上下边框的高度</p>
</li>
<li><p><code>element.offsetLeft</code>,<code>element.offsetTop</code>, 元素边框外部至<code>offsetParent</code>属性指向的元素<code>内边框</code>间的距离</p>
</li>
</ul>
<p><img src="https://i.loli.net/2017/12/24/5a3eff151e43d.jpg" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到元素在页面上的左偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualLeft += current.offsetLeft;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到元素在页面上的上偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualTop += current.offsetTop;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。</p>
</blockquote>
<h3 id="client-dimension"><a href="#client-dimension" class="headerlink" title="client dimension"></a>client dimension</h3><ul>
<li><code>element.clientWidth</code>,<code>element.clientHeight</code>: 元素的内边距+内容所占尺寸(不带边框,不带滚动条的大小)</li>
</ul>
<p><img src="https://i.loli.net/2017/12/24/5a3eff15ac240.jpg" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回浏览器视口大小(Viewport:html或body的大小)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">      height: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户区大小只读,每次访问要重新计算</p>
</blockquote>
<h3 id="scroll-dimention"><a href="#scroll-dimention" class="headerlink" title="scroll dimention"></a>scroll dimention</h3><blockquote>
<p>有些元素(例如html元素)即使没有执行任何代码,也嫩自动的添加滚动条,但另外一些元素,则需要通过css overflow属性进行设置才能滚动</p>
</blockquote>
<ul>
<li><code>element.scrollHeight</code>, 在没有滚动条的情况下,元素内容的实际高度</li>
<li><code>element.scrollWidth</code>, 在没有滚动条的情况下,元素内容的实际宽度</li>
<li><code>element.scrollLeft</code>, 被隐藏在内容区域左侧的像素数,通过设置此属性可改变滚动位置</li>
<li><code>element.scrollTop</code>, 被隐藏在内容区域上方的像素数,通过设置此属性可改变滚动位置</li>
</ul>
<p><img src="https://i.loli.net/2017/12/24/5a3eff1601793.jpg" alt=""><br><img src="media/15139250934130/15139549207969.jpg" alt=""></p>
<blockquote>
<p><code>&lt;html&gt;</code>元素是在Web浏览器的视口中滚动的元素(IE6之前运行在混杂模式下是<code>&lt;body&gt;</code>元素),因此,带有垂直滚动条的页面总高度是<code>document.documentElement.scrollHeight</code><br>对于不包含滚动条的视口或页面而言,<code>scrollWidth,scrollHeight</code>与<code>clientWidth,clientHeight</code>之间的关系十分不清晰,基于document.documentElement查看这些属性会发生不同浏览器的不一致性</p>
</blockquote>
<ul>
<li>Firefox 中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。 </li>
<li>Opera、Safari 3.1 及更高版本、Chrome 中的这两组属性是有差别的，其中 scrollWidth 和 scrollHeight 等于视口大小，而 clientWidth 和 clientHeight 等于文档内容区域的大小。</li>
<li>IE（在标准模式）中的这两组属性不相等，其中 scrollWidth 和 scrollHeight 等于文档内容区域的大小，而 clientWidth 和 clientHeight 等于视口大小。</li>
</ul>
<blockquote>
<p>所以,在确定文档的总高度时（包括基于视口的最小高度时），必须取得 scrollWidth/clientWidth 和scrollHeight/clientHeight 中的最大值，才能保证在跨浏览器的环境下得到精确的结果。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档总高度</span></span><br><span class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight, <span class="built_in">document</span>.documentElement.clientHeight);</span><br><span class="line"><span class="comment">// 文档总宽度</span></span><br><span class="line"><span class="keyword">var</span> docWidth = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollWidth, <span class="built_in">document</span>.documentElement.clientWidth);</span><br><span class="line"><span class="comment">// 如果是ie,上面代码需要用document.body代替document.documentElement</span></span><br></pre></td></tr></table></figure>
<h3 id="element-getBoundingClientRect"><a href="#element-getBoundingClientRect" class="headerlink" title="element.getBoundingClientRect()"></a>element.getBoundingClientRect()</h3><p><code>element.getBoundingClientRect() return rectObj</code></p>
<blockquote>
<p>rectObj包含4个属性, <code>left</code>,<code>top</code>,<code>right</code>,<code>bottom</code>,分别表示了下图的距离</p>
</blockquote>
<p><img src="https://i.loli.net/2017/12/24/5a3eff15e39d5.png" alt="rect"></p>
<blockquote>
<p>IE8以及更早版本中,位于(0,0)处元素的位置会返回(2,2),需要做浏览器兼容,当浏览器是IE时,要从测量值里<code>-2</code>,再减去视口(html标签)的<code>scrollTop</code>,防止调用这个函数时窗口被滚动了.</p>
<p>完整兼容代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualLeft += current.offsetLeft;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    actualTop += current.offsetTop;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actualTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBoundingClientRect兼容代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  <span class="keyword">var</span> scrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.getBoundingClientRect) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">      temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(temp);</span><br><span class="line">      <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(temp);</span><br><span class="line">      temp = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rect = element.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      left: rect.left + offset,</span><br><span class="line">      right: rect.right + offset,</span><br><span class="line">      top: rect.top + offset,</span><br><span class="line">      bottom: rect.bottom + offset</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> actualLeft = getElementLeft(element);</span><br><span class="line">    <span class="keyword">var</span> actualTop = getElementTop(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      left: actualLeft - scrollLeft,</span><br><span class="line">      right: actualLeft + element.offsetWidth - scrollLeft,</span><br><span class="line">      top: actualTop - scrollTop,</span><br><span class="line">      bottom: actualTop + element.offsetHeight - scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><blockquote>
<p>下面两个遍历方法不用深入,因为ES6的Iterator方法已经很成熟了,若要深入详情查询高程p328</p>
</blockquote>
<h3 id="NodeIterator类型"><a href="#NodeIterator类型" class="headerlink" title="NodeIterator类型"></a>NodeIterator类型</h3><p><code>document.createNodeIterator(root,whatToshow,filter,entityReferenceExpansion) return nodeIterator</code></p>
<ul>
<li><code>root</code>,搜索起始节点</li>
<li><code>whatToShow</code> 可以用按位或操作符来组合多个选项,比如<code>NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT</code><ul>
<li><code>NodeFilter.SHOW_ALL</code>：显示所有类型的节点。</li>
<li><code>NodeFilter.SHOW_ELEMENT</code>：显示元素节点。</li>
<li><code>NodeFilter.SHOW_TEXT</code>：显示文本节点。</li>
<li><code>NodeFilter.SHOW_COMMENT</code>：显示注释节点。</li>
<li><code>NodeFilter.SHOW_DOCUMENT_TYPE</code>：显示文档类型节点。</li>
</ul>
</li>
<li><code>filter</code> 是一个只有一个方法<code>acceptNode()</code>的对象,或一个类似<code>acceptNode()</code>的匿名函数,或 <code>null</code><ul>
<li><code>acceptNode(node)</code>,若返回需要的节点,该方法返回<code>NodeFilter.FILTER_ACCEPT</code>,否则返回<code>NodeFilter.FILTER_SKIP</code></li>
</ul>
</li>
<li><code>entityReferExpansion</code>, false即可,这个参数在html页面中没有用</li>
<li><code>nodeIterator</code>,主要有两个方法,用于前进一步或后退一步<ul>
<li><code>nodeIterator.nextNode()</code> 前进一步,前进到方向上最后一个节点返回<code>null</code></li>
<li><code>nodeIterator.previousNode()</code> 后退一步,后退到方向上最后一个节点返回<code>null</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>两个例子</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历div中所有元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> node = iterator.nextNode();</span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">  alert(node.tagName); <span class="comment">//输出标签名</span></span><br><span class="line">  node = iterator.nextNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> filter = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"li"</span> ?</span><br><span class="line">    NodeFilter.FILTER_ACCEPT :</span><br><span class="line">    NodeFilter.FILTER_SKIP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> node = iterator.nextNode();</span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">  alert(node.tagName);<span class="comment">//输出标签名</span></span><br><span class="line">  node = iterator.nextNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeWalker类型"><a href="#TreeWalker类型" class="headerlink" title="TreeWalker类型"></a>TreeWalker类型</h3><blockquote>
<p><code>NodeIterator</code>更高级的版本,返回的实例除了<code>nextNode()</code>和<code>previousNode()</code>外,还提供了不同方向上遍历DOM结构的方法</p>
</blockquote>
<p><code>document.createTreeWalker(root,whatToshow,filter,entityReferenceExpansion) return treeWalker</code>,四个参数与<code>NodeIterator</code>中相同,返回值<code>treeWalker</code>还扩展下面的方法</p>
<ul>
<li><code>parentNode()</code>：遍历到当前节点的父节点； </li>
<li><code>firstChild()</code>：遍历到当前节点的第一个子节点； </li>
<li><code>lastChild()</code>：遍历到当前节点的最后一个子节点； </li>
<li><code>nextSibling()</code>：遍历到当前节点的下一个同辈节点； </li>
<li><code>previousSibling()</code>：遍历到当前节点的上一个同辈节点。</li>
</ul>
<blockquote>
<p><code>filter</code>与<code>NodeIterator</code>有些小差异,增加了返回值<code>NodeFilter.FILTER_REJECT</code>,返回这个值代表跳过整个相应节点及该节点整个子树,而<code>NodeFilter.FILTER_SKIP</code>则只跳过相应节点<br>返回对象<code>treeWalker</code>还有一个属性<code>currentNode</code>,表示任何遍历方法在上一次便利中返回的节点,通过这个属性可以修改遍历继续进行的起点,如下例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;div id="div1"&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;</span></span><br><span class="line"><span class="comment">      &lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;ul&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;List item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;List item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;List item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt; */</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> walker = <span class="built_in">document</span>.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">walker.firstChild();<span class="comment">//转到&lt;p&gt;</span></span><br><span class="line">walker.nextSibling(); <span class="comment">//转到&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> node = walker.firstChild();</span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//转到第一个&lt;li&gt;</span></span><br><span class="line">  alert(node.tagName);</span><br><span class="line">  node = walker.nextSibling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = walker.nextNode();</span><br><span class="line">alert(node === walker.currentNode);<span class="comment">//true </span></span><br><span class="line">walker.currentNode = <span class="built_in">document</span>.body;<span class="comment">//修改起点</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IE不支持<code>TreeWalker</code></p>
</blockquote>
<h2 id="范围-富文本编辑器基础"><a href="#范围-富文本编辑器基础" class="headerlink" title="范围(富文本编辑器基础)"></a>范围(富文本编辑器基础)</h2><h3 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h3><p>DOM2 级在 Document 类型中定义了 <code>createRange()</code>方法。在兼容 DOM 的浏览器中，这个方法属于 <code>document对象</code></p>
<h3 id="document-createRange"><a href="#document-createRange" class="headerlink" title="document.createRange()"></a>document.createRange()</h3><p><code>document.createRange() return range</code> ,返回的<code>range</code>对象代表一个DOM选中范围,有如下属性</p>
<ul>
<li><code>startContainer</code>：包含范围起点的节点（即选区中第一个节点的父节点）。 </li>
<li><code>startOffset</code>：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，startOffset 就是范围中第一个子节点的索引。 </li>
<li><code>endContainer</code>：包含范围终点的节点（即选区中最后一个节点的父节点）。 </li>
<li><code>endOffset</code>：范围在 endContainer 中终点的偏移量（与 startOffset 遵循相同的取值规则)。 </li>
<li><code>commonAncestorContainer</code>：startContainer 和 endContainer 共同的祖先节点在文档树 中位置最深的那个。</li>
</ul>
<h3 id="range对象-基础方法"><a href="#range对象-基础方法" class="headerlink" title="range对象,基础方法"></a>range对象,基础方法</h3><ul>
<li><code>range.selectNode(node)</code>,选择整个节点，包括其子节点；</li>
<li><code>range.selectNodeContents(node)</code>,只选择节点的子节点</li>
</ul>
<blockquote>
<p>下面几个方法用的比较少</p>
</blockquote>
<ul>
<li><code>setStartBefore(refNode)</code>：将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。</li>
<li><code>setStartAfter(refNode)</code>：将范围的起点设置在refNode之后，因此refNode也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引加1。</li>
<li><code>setEndBefore(refNode)</code>：将范围的终点设置在refNode之前，因此refNode也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引。</li>
<li><code>setEndAfter(refNode)</code>：将范围的终点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引加1。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例通用HTML代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</span><br><span class="line">range2 = <span class="built_in">document</span>.createRange();</span><br><span class="line">p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">range1.selectNode(p1);</span><br><span class="line">range2.selectNodeContents(p1);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/24/5a3eff15e74db.jpg" alt=""></p>
<blockquote>
<p>在调用selectNode()时，startContainer、endContainer和commonAncestorContainer都等于传入节点的父节点，也就是这个例子中的document.body。而startOffset属性等于给定节点在其父节点的childNodes集合中的索引（在这个例子中是1——因为兼容DOM的浏览器将空格算作一个文本节点），endOffset等于startOffset加1（因为只选择了一个节点）。<br>在调用selectNodeContents()时，startContainer、endContainer和commonAncestorContainer等于传入的节点，即这个例子中的</p><p>元素。而startOffset属性始终等于0，因为范围从给定节点的第一个子节点开始。最后，endOffset等于子节点的数量（node.childNodes.length），在这个例子中是2。</p>
</blockquote>
<h3 id="range-setStart-range-setEnd-实现DOM复杂选择"><a href="#range-setStart-range-setEnd-实现DOM复杂选择" class="headerlink" title="range.setStart(),range.setEnd()实现DOM复杂选择"></a>range.setStart(),range.setEnd()实现DOM复杂选择</h3><ul>
<li><code>range.setStart(node,offset)</code>,<code>range.setEnd(node,offset)</code></li>
</ul>
<blockquote>
<p>对<code>setStart()</code>来说，参照节点会变成<code>startContainer</code>，而偏移量值会变成<code>startOffset</code>。对于<code>setEnd()</code>来说，参照节点会变成<code>endContainer</code>，而偏移量值会变成<code>endOffset</code>。<br>使用这两个方法来模仿 <code>selectNode()</code>和 <code>selectNodeContents()</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</span><br><span class="line">range2 = <span class="built_in">document</span>.createRange();</span><br><span class="line">p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">p1Index = <span class="number">-1</span>;</span><br><span class="line">i, len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = p1.parentNode.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p1.parentNode.childNodes[i] == p1) &#123;</span><br><span class="line">    p1Index = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range1.setStart(p1.parentNode, p1Index);</span><br><span class="line">range1.setEnd(p1.parentNode, p1Index + <span class="number">1</span>);</span><br><span class="line">range2.setStart(p1, <span class="number">0</span>);</span><br><span class="line">range2.setEnd(p1, p1.childNodes.length);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模仿 selectNode()和 selectNodeContents()并不是 setStart() 和 setEnd()的主要用途，它们更胜一筹的地方在于能够选择节点的一部分。<br>假设你只想选择前面 HTML 示例代码中从”Hello”的”llo”到”world!”的”o”</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">helloNode = p1.firstChild.firstChild;</span><br><span class="line">worldNode = p1.lastChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/24/5a3eff15d4607.jpg" alt=""></p>
<h3 id="操作DOM范围中的内容"><a href="#操作DOM范围中的内容" class="headerlink" title="操作DOM范围中的内容"></a>操作DOM范围中的内容</h3><blockquote>
<p>在创建范围时，内部会为这个范围创建一个文档片段，范围所属的全部节点都在这个文档片段中。文档片段中范围内容的格式必须正确有效。在前面的例子中，创建的选区分别开始和结束于两个文本节点的内部(标签不闭合)，因此不能算是格式良好的DOM结构，也就无法通过DOM来表示。范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的DOM结构</p>
<p>范围经过计算知道选区中缺少一个开始的<code>&lt;b&gt;</code>标签，因此就会在后台动态加 入一个该标签，同时还会在前面加入一个表示结束的<code>&lt;/b&gt;</code>标签以结束”He”,文本节点”world!”也被拆分为两个文本节点，一个包含”wo”，另一个包含”rld!”<br>创建了范围之后，就可以使用方法对范围的内容进行操作了（表示范围的内部文档片段中的所有节点，都只是指向文档中相应节点的指针）</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改后的dom如下所示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/24/5a3eff15be6c8.jpg" alt=""></p>
<h3 id="range-deleteContents"><a href="#range-deleteContents" class="headerlink" title="range.deleteContents()"></a>range.deleteContents()</h3><p><code>range.deleteContents()</code> 删除文档范围中包含的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">helloNode = p1.firstChild.firstChild;</span><br><span class="line">worldNode = p1.lastChild;</span><br><span class="line">range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">range.deleteContents();</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- deleteContents()执行前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- deleteContents()执行后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>范围选区在修改底层 DOM 结构时能够保证格式良好，因此即使内容被删除了，最终的 DOM 结构依旧是格式良好的</p>
</blockquote>
<h3 id="range-extractContents"><a href="#range-extractContents" class="headerlink" title="range.extractContents()"></a>range.extractContents()</h3><p><code>range.extractContents() return rangeFragment</code></p>
<blockquote>
<p>与<code>range.deleteContents()</code>的区别是<code>range.extractContents()</code>会返回范围的文档片段,利用这个返回值可以实现再插入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line"></span><br><span class="line">helloNode = p1.firstChild.firstChild;</span><br><span class="line">worldNode = p1.lastChild;</span><br><span class="line">range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = range.extractContents();</span><br><span class="line">p1.parentNode.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们将提取出来的文档片段添加到了文档<body>元素的末尾。（记住，在将文档片段传入 appendChild()方法中时，添加到文档中的只是片段的子节点，而非片段本身</body></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p1.parentNode.appendChild(range.extarctContents())后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure>
<h3 id="range-cloneContents"><a href="#range-cloneContents" class="headerlink" title="range.cloneContents()"></a>range.cloneContents()</h3><p><code>range.cloneConents() return rangeFragment</code> </p>
<blockquote>
<p> <code>range.cloneContents()</code>创建范围对象的一个副本，然后在文档的其他地方插入该副本。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</span><br><span class="line">  helloNode = p1.firstChild.firstChild,</span><br><span class="line">  worldNode = p1.lastChild,</span><br><span class="line">  range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = range.cloneContents();</span><br><span class="line">p1.parentNode.appendChild(fragment);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p1.parentNode.appendChild(range.cloneContents())后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在调用上面介绍的方法之前，拆分的节点并不会产生格式良好的文档片段(只创建<code>range</code>后,html结构不会改变,调用改变dom的这三个方法后才会变)。换句话说，原始的 HTML 在 DOM 被修改之前会始终保持不变</p>
</blockquote>
<h3 id="插入DOM范围中的内容"><a href="#插入DOM范围中的内容" class="headerlink" title="插入DOM范围中的内容"></a>插入DOM范围中的内容</h3><h3 id="range-insertNode"><a href="#range-insertNode" class="headerlink" title="range.insertNode()"></a>range.insertNode()</h3><p><code>range.insertNode(node)</code> 向范围选区的开始出插入一个节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要插入的html &lt;span style="color: red"&gt;Inserted text&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</span><br><span class="line">helloNode = p1.firstChild.firstChild,</span><br><span class="line">worldNode = p1.lastChild,</span><br><span class="line">range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line">range.setStart(helloNode, <span class="number">2</span>);</span><br><span class="line">range.setEnd(worldNode, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</span><br><span class="line">span.style.color = <span class="string">"red"</span>;</span><br><span class="line">span.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Inserted text"</span>));</span><br><span class="line">range.insertNode(span);</span><br><span class="line"><span class="comment">// &lt;p id="p1"&gt;&lt;b&gt;He&lt;span style="color: red"&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt; world&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;span&gt;</code>正好被插入到了”Hello”中的”llo”前面，而该位置就是范围选区的开始位置。还要注意的是，由于这里没有使用上一节介绍的方法，结果原始的 HTML 并没有添加或删除<code>&lt;b&gt;</code>元素</p>
</blockquote>
<h3 id="range-surroundContents"><a href="#range-surroundContents" class="headerlink" title="range.surroundContents()"></a>range.surroundContents()</h3><p><code>range.surroundContents(node)</code> <code>node</code>即环绕范围内容的节点,在环绕范围插入内容时， 后台会执行下列步骤</p>
<ol>
<li>提取出范围中的内容（类似执行 <code>range.extractContent()</code>） </li>
<li>将给定节点插入到文档中原来范围所在的位置上</li>
<li>将文档片段的内容添加到给定节点中</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line"></span><br><span class="line">helloNode = p1.firstChild.firstChild;</span><br><span class="line">worldNode = p1.lastChild;</span><br><span class="line">range = <span class="built_in">document</span>.createRange();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了插入&lt;span&gt;，范围必须包含整个 DOM 选区（不能仅仅包含选中的 DOM 节点）</span></span><br><span class="line">range.selectNode(helloNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</span><br><span class="line">span.style.backgroundColor = <span class="string">"yellow"</span>;</span><br><span class="line">range.surroundContents(span);</span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;b&gt;&lt;span style="background-color:yellow"&gt;Hello&lt;/span&gt;&lt;/b&gt; world!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="折叠DOM范围"><a href="#折叠DOM范围" class="headerlink" title="折叠DOM范围"></a>折叠DOM范围</h3><p><code>折叠范围</code>，就是指范围中未选择文档的任何部分,其位置会落在文档中的两个部分之间，可能是范围选区的开始位置，也可能是结束位置</p>
<h3 id="range-collapse"><a href="#range-collapse" class="headerlink" title="range.collapse()"></a>range.collapse()</h3><p><code>range.collapse(boolean) return boolean</code>,<code>boolean</code>为ture时,折叠到起点,<code>boolean</code>为false时,折叠刀终点,并在操作后返回对应的boolean值.</p>
<p><img src="https://i.loli.net/2017/12/24/5a3eff16429ca.jpg" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.collapse(<span class="literal">true</span>); <span class="comment">//折叠到起点 </span></span><br><span class="line">alert(range.collapsed); <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。例如，对于下面的 HTML 代码</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</span><br><span class="line">  p2 = <span class="built_in">document</span>.getElementById(<span class="string">"p2"</span>),</span><br><span class="line">  range = <span class="built_in">document</span>.createRange();</span><br><span class="line">range.setStartAfter(p1);</span><br><span class="line">range.setEndBefore(p2);</span><br><span class="line">alert(range.collapsed); <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>
<h3 id="range-compareBoundaryPoints-比较DOM范围"><a href="#range-compareBoundaryPoints-比较DOM范围" class="headerlink" title="range.compareBoundaryPoints() 比较DOM范围"></a>range.compareBoundaryPoints() 比较DOM范围</h3><p><code>range.compareBoundaryPoting(value,range1) return -1/0/1</code></p>
<blockquote>
<p>确定这些范围是否有公共的边界（起点或终点）。这个方法接受两个参数：表示比较方式的常量值<code>value</code>和要比较的范围,常量<code>value</code>可取值如下</p>
</blockquote>
<ul>
<li><code>Range.START_TO_START(0)</code>：比较第一个范围和第二个范围的起点；</li>
<li><code>Range.START_TO_END(1)</code>：比较第一个范围的起点和第二个范围的终点；</li>
<li><code>Range.END_TO_END(2)</code>：比较第一个范围和第二个范围的终点；</li>
<li><code>Range.END_TO_START(3)</code>：比较第一个范围的终点和第一个范围的起点。</li>
</ul>
<blockquote>
<p><code>compareBoundaryPoints()</code>方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的点之前，返回<code>-1</code>；如果两个点相等，返回 <code>0</code>；如果第一个范围中的点位于第二个范围中的点之后，返回<code>1</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</span><br><span class="line"><span class="keyword">var</span> range2 = <span class="built_in">document</span>.createRange();</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line"></span><br><span class="line">range1.selectNodeContents(p1);</span><br><span class="line">range2.selectNodeContents(p1);</span><br><span class="line">range2.setEndBefore(p1.lastChild);</span><br><span class="line"></span><br><span class="line">alert(range1.compareBoundaryPoints(Range.START_TO_START, range2));<span class="comment">//0</span></span><br><span class="line">alert(range1.compareBoundaryPoints(Range.END_TO_END, range2));<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/24/5a3eff1672113.jpg" alt=""></p>
<h3 id="range-cloneRange-复制DOM范围"><a href="#range-cloneRange-复制DOM范围" class="headerlink" title="range.cloneRange() 复制DOM范围"></a>range.cloneRange() 复制DOM范围</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.cloneRange() <span class="keyword">return</span> newRange;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新创建的范围与原来的范围包含相同的属性,而修改它的端点不会影响原来的范围</p>
</blockquote>
<h3 id="range-detach-清理DOM范围"><a href="#range-detach-清理DOM范围" class="headerlink" title="range.detach() 清理DOM范围"></a>range.detach() 清理DOM范围</h3><p><code>range.detach()</code> 接触对<code>range</code>的引用,从创建范围的文档中分离,进行回收.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.detach() <span class="comment">//从文档中分离</span></span><br><span class="line">range = <span class="literal">null</span> <span class="comment">//不主动调用,垃圾机制也会回收内存</span></span><br></pre></td></tr></table></figure>
<h3 id="IE8及更早版本中的范围"><a href="#IE8及更早版本中的范围" class="headerlink" title="IE8及更早版本中的范围"></a>IE8及更早版本中的范围</h3><blockquote>
<p>此部分内容由于IE8及之前更早版本的IE浏览器的逐步淘汰有些过时,毕竟IE9之后的版本都支持DOM范围,需要用到时再去翻阅高程p340</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/23/javascript-与-发布订阅设计模式/" class="next">上一篇</a><a href="/2017/12/28/高程vol8-事件/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>