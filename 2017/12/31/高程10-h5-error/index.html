<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正反馈系列:《JavaScript高级程序设计》HTML5脚本编程,错误处理 · choteewang</title><meta name="description" content="正反馈系列:《JavaScript高级程序设计》HTML5脚本编程,错误处理 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li><li class="nav-list-item"><a href="https://github.com/choteewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">正反馈系列:《JavaScript高级程序设计》HTML5脚本编程,错误处理</h1><div class="post-info">2017年12月31日</div><div class="post-content"><h1 id="HTML5-脚本编程-第16章"><a href="#HTML5-脚本编程-第16章" class="headerlink" title="HTML5 脚本编程 (第16章)"></a>HTML5 脚本编程 (第16章)</h1><h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><blockquote>
<p><code>element</code>元素开始被拖放时:</p>
</blockquote>
<ol>
<li><code>element.dragstart</code></li>
<li><code>element.drag</code> 持续发生</li>
<li><code>element.dragend</code></li>
</ol>
<blockquote>
<p>拖动到一个有效放置目标<code>target</code>上时:</p>
</blockquote>
<ol>
<li><code>target.dragenter</code></li>
<li><code>target.dragover</code> 持续发生</li>
<li><code>target.dragleave</code> 或 <code>drop</code> 不会同时触发</li>
</ol>
<h3 id="自定义配置目标"><a href="#自定义配置目标" class="headerlink" title="自定义配置目标"></a>自定义配置目标</h3><p>如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生<code>drop</code>事件。不过，你可以把任何元素变成有效的放置目标，方法是重写<code>dragenter</code>和<code>dragover</code>事件的默认行为。例如，假设有一个ID为”droptarget”的<code>&lt;div&gt;</code>元素，可以用如下代码将它变成一个放置目标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">"droptarget"</span>);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Firefox3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。换句话说，如果是把图像拖放到放置目标上，页面就会转向图像文件；而如果是把文本拖放到放置目标上，则会导致无效URL错误。因此，为了让Firefox支持正常的拖放，还要取消drop事件的默认行为，阻止它打开URL：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消drop事件原生行为(新窗口打开图片等)</span></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"drop"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="dataTransfer对象"><a href="#dataTransfer对象" class="headerlink" title="dataTransfer对象"></a>dataTransfer对象</h3><p>HTML5引入了<code>dataTransfer对象</code>,它是<code>event</code>事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。只能在拖放事件的事件处理程序中访问dataTransfer对象。</p>
<p>dataTransfer对象有两个主要方法：<code>event.dataTransfer.getData()</code>和<code>event.dataTransfer.setData()</code>。<code>getData()</code>可以取得由<code>setData()</code>保存的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置和接收文本数据 </span></span><br><span class="line">event.dataTransfer.setData(<span class="string">"text"</span>, <span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> text = event.dataTransfer.getData(<span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和接收 URL </span></span><br><span class="line">event.dataTransfer.setData(<span class="string">"URL"</span>, <span class="string">"http://www.wrox.com/"</span>);</span><br><span class="line"><span class="keyword">var</span> url = event.dataTransfer.getData(<span class="string">"URL"</span>);</span><br></pre></td></tr></table></figure>
<p>IE只定义了”text”和”URL”两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持”text”和”URL”，但这两种类型会被映射为”text/plain”和”text/uri-list”。</p>
<p>实际上，<code>dataTransfer对象</code>可以为每种MIME类型都保存一个值。换句话说，同时在这个对象中保存一段文本和一个URL不会有任何问题。不过，保存在<code>dataTransfer对象</code>中的数据只能在<code>drop</code>事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是<code>dataTransfer对象</code>已经被销毁，数据也丢失了。</p>
<p>在拖动<strong>文本框</strong>中的文本时，浏览器会调用<code>event.dataTransfer.setData()</code>方法，将拖动的文本以”text”格式保存在dataTransfer对象中。类似地，在拖放<strong>链接</strong>或<strong>图像</strong>时，会调用<code>event.dataTransfer.setData()</code>方法并保存URL。然后，在这些元素被拖放到放置目标时，就可以通过<code>event.dataTransfer.getData()</code>读到这些数据。当然，作为开发人员，你也可以在<code>dragstart</code>事件处理程序中调用<code>event.dataTransfer.setData()</code>，手工保存自己要传输的数据</p>
<h3 id="dropEffect与effectAllowed"><a href="#dropEffect与effectAllowed" class="headerlink" title="dropEffect与effectAllowed"></a>dropEffect与effectAllowed</h3><p>dataTransfer 对象的两个属性：<code>event.dataTransfer.dropEffect</code> 和 <code>event.dataTransfer.effectAllowed</code></p>
<p><code>event.dataTransfer.dropEffect</code> 是针对放置目标<code>target</code>的事件处理程序<code>dragenter</code>设置的.可以知道被拖动的元素能够执行哪种放置行为,可能有4个值:</p>
<ul>
<li><code>&quot;none&quot;</code>：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。</li>
<li><code>&quot;move&quot;</code>：应该把拖动的元素移动到放置目标。</li>
<li><code>&quot;copy&quot;</code>：应该把拖动的元素复制到放置目标。</li>
<li><code>&quot;link&quot;</code>：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。</li>
</ul>
<blockquote>
<p><code>dropEffect</code> 属性只有搭配 <code>effectAllowed</code> 属性才有用。</p>
</blockquote>
<p><code>event.dataTransfer.effectAllowed</code>属性表示允许拖动元素的哪种<code>dropEffect</code>，是针对被拖动目标<code>element</code>的<code>dragstart</code>事件设置的, <code>effectAllowed</code>属性可能的值如下</p>
<ul>
<li><code>&quot;uninitialized&quot;</code>：没有给被拖动的元素设置任何放置行为。</li>
<li><code>&quot;none&quot;</code>：被拖动的元素不能有任何行为。</li>
<li><code>&quot;copy&quot;</code>：只允许值为”copy”的dropEffect。</li>
<li><code>&quot;link&quot;</code>：只允许值为”link”的dropEffect。</li>
<li><code>&quot;move&quot;</code>：只允许值为”move”的dropEffect。</li>
<li><code>&quot;copyLink&quot;</code>：允许值为”copy”和”link”的dropEffect。</li>
<li><code>&quot;copyMove&quot;</code>：允许值为”copy”和”move”的dropEffect。</li>
<li><code>&quot;linkMove&quot;</code>：允许值为”link”和”move”的dropEffect。</li>
<li><code>&quot;all&quot;</code>：允许任意dropEffect。</li>
</ul>
<blockquote>
<p>假设你想允许用户把文本框中的文本拖放到一个<code>&lt;div&gt;</code>元素中。首先，必须将<strong>div元素的dragenter事件</strong>中<code>dropEffect</code>和<strong>文本框的dragstart事件</strong>中<code>effectAllowed</code>设置为”move”。但是，由于<code>&lt;div&gt;</code>元素的放置事件的默认行为是什么也不做，所以文本不可能自动移动。重写这个默认行为，就能从文本框中移走文本。然后你就可以自己编写代码将文本插入到<code>&lt;div&gt;</code>中，这样整个拖放操作就完成了。如果你将<code>dropEffect</code>和<code>effectAllowed</code>的值设置为”copy”，那就不会自动移走文本框中的文本。</p>
</blockquote>
<h3 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h3><p>默认情况下，图像、链接和文本是可以拖动的，也就是说，不用额外编写代码，用户就可以拖动它们。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。让其他元素可以拖动也是可能的。</p>
<p>HTML5为所有HTML元素规定了一个<code>draggable</code>属性，表示元素是否可以拖动。图像和链接的<code>draggable</code>属性自动被设置成了true，而其他元素这个属性的默认值都是false。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 让这个图像不可以拖动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"smile.gif"</span> <span class="attr">draggable</span>=<span class="string">"false"</span> <span class="attr">alt</span>=<span class="string">"Smiley face"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 让这个元素可以拖动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h3><blockquote>
<p>HTML5 规范规定 <code>dataTransfer对象</code>还应该包含下列方法和属性。</p>
</blockquote>
<ul>
<li><code>addElement(element)</code>：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有Firefox3.5+实现了这个方法。</li>
<li><code>clearData(format)</code>：清除以特定格式保存的数据。实现这个方法的浏览器有IE、Fireforx3.5+、Chrome和Safari4+。</li>
<li><code>setDragImage(element,x,y)</code>：指定一幅图像，当拖动发生时，显示在光标下方。这个方法接收的三个参数分别是要显示的HTML元素和光标在图像中的x、y坐标。其中，HTML元素可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。实现这个方法的浏览器有Firefox3.5+、Safari4+和Chrome。</li>
<li><code>types</code>：当前保存的数据类型。这是一个类似数组的集合，以”text”这样的字符串形式保存着数据类型。实现这个属性的浏览器有IE10+、Firefox3.5+和Chrome。</li>
</ul>
<h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌入视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"conference.mpg"</span> <span class="attr">id</span>=<span class="string">"myVideo"</span>&gt;</span>Video player not available.<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 嵌入音频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">id</span>=<span class="string">"myAudio"</span>&gt;</span>Audio player not available.<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用这两个元素时，至少要在标签中包含<code>src</code>属性，指向要加载的媒体文件。还可以设置<code>width</code>和<code>height</code>属性以指定视频播放器的大小，</p>
<p>如果标签中有<code>controls</code>特性，则意味着浏览器应该显示UI控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。</p>
<p>因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源, 使用一或多个<code>&lt;source&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌入视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"myVideo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"conference.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm; codecs='vp8, vorbis'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"conference.ogv"</span> <span class="attr">type</span>=<span class="string">"video/ogg; codecs='theora, vorbis'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"conference.mpg"</span>&gt;</span> Video player not available.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 嵌入音频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">"myAudio"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"song.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span> Audio player not available.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>元素都提供了完善的 JavaScript 接口。下表列出了这两个元素共有的属性，</p>
<p><img src="https://i.loli.net/2017/12/31/5a48b37a19ab3.jpg" alt=""></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><img src="https://i.loli.net/2017/12/31/5a48b37a3ab84.jpg" alt=""></p>
<h3 id="自定义媒体"><a href="#自定义媒体" class="headerlink" title="自定义媒体"></a>自定义媒体</h3><p>使用<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>元素的<code>element.play()</code>和<code>element.pause()</code>方法，可以手工控制媒体文件的播放。组合使用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mediaplayer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">src</span>=<span class="string">"movie.mov"</span> <span class="attr">poster</span>=<span class="string">"mymovie.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span> Video player not available.</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Play"</span> <span class="attr">id</span>=<span class="string">"video-btn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"curtime"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>/</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"duration"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">video.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get references to the elements</span></span><br><span class="line">  <span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">"player"</span>);</span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"video-btn"</span>);</span><br><span class="line">  <span class="keyword">var</span> curtime = <span class="built_in">document</span>.getElementById(<span class="string">"curtime"</span>);</span><br><span class="line">  <span class="keyword">var</span> duration = <span class="built_in">document</span>.getElementById(<span class="string">"duration"</span>);</span><br><span class="line">  duration.innerHTML = player.duration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//attach event handler to button</span></span><br><span class="line">  EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (player.paused) &#123;</span><br><span class="line">      player.play();</span><br><span class="line">      btn.value = <span class="string">"Pause"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      player.pause();</span><br><span class="line">      btn.value = <span class="string">"Play"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//update the current time periodically</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    curtime.innerHTML = player.currentTime;</span><br><span class="line">  &#125;, <span class="number">250</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="检测编解码器支持情况"><a href="#检测编解码器支持情况" class="headerlink" title="检测编解码器支持情况"></a>检测编解码器支持情况</h3><p>有一个JavaScriptAPI能够检测浏览器是否支持某种格式和编解码器</p>
<p>这两个媒体元素都有一个<code>element.canPlayType()</code>方法，该方法接收一种格式/编解码器字符串，返回”probably”、”maybe”或””（空字符串）。空字符串是假值，因此可以像下面这样在if语句中使用<code>element.canPlayType()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio.canPlayType(<span class="string">"audio/mpeg"</span>)) &#123;</span><br><span class="line">  <span class="comment">//进一步处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“probably”和”maybe”都是真值，因此在 if 语句的条件测试中可以转换成 true。<br>在同时传入MIME类型和编解码器的情况下，可能性就会增加，返回的字符串会变成”probably”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> audio = <span class="built_in">document</span>.getElementById(<span class="string">"audio-player"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//很可能"maybe" </span></span><br><span class="line"><span class="keyword">if</span> (audio.canPlayType(<span class="string">"audio/mpeg"</span>)) &#123;</span><br><span class="line">  <span class="comment">//进一步处理 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能是"probably" </span></span><br><span class="line"><span class="keyword">if</span> (audio.canPlayType(<span class="string">"audio/ogg; codecs=\"vorbis\""</span>)) &#123;</span><br><span class="line">  <span class="comment">//进一步处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编解码器必须用引号引起来才行。下表列出了已知的已得到支持的音频格式和编解码器。</p>
</blockquote>
<p><img src="https://i.loli.net/2017/12/31/5a48b37a1b202.jpg" alt=""></p>
<h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><h3 id="history-pushState"><a href="#history-pushState" class="headerlink" title="history.pushState()"></a>history.pushState()</h3><p><code>history.pushState(state,title,url)</code>方法，该方法可以接收三个参数：状态对象、新状态的标题,可选的相对 URL,能够在不加载新页面的情况下改变浏览器的URL</p>
<p>执行<code>history.pushState()</code>方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询<code>location.href</code>也会返回与地址栏中相同的地址。</p>
<p>因为pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”按钮，会触发window对象的<code>window.onpopstate</code>事件。事件的事件对象有一个<code>event.state</code>属性，这个属性就包含着当初以第一个参数传递给<code>history.pushState()</code>的状态对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>&#125;, <span class="string">"Nicholas page"</span>, <span class="string">"nicholas.html"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="history-replaceState"><a href="#history-replaceState" class="headerlink" title="history.replaceState()"></a>history.replaceState()</h3><p><code>history.replaceState(state,title,url)</code> 和<code>history.pushState</code>的区别是不是往历史记录里添加一条记录,而是更新当前记录</p>
<h3 id="window-onpopstate"><a href="#window-onpopstate" class="headerlink" title="window.onpopstate()"></a>window.onpopstate()</h3><p><code>window.onpopstate</code>是<code>popstate</code>事件在<code>window</code>对象上的事件处理程序.</p>
<p>每当处于激活状态的历史记录条目发生变化时,<code>popstate</code>事件就会在对应<code>window</code>对象上触发. 如果当前处于激活状态的历史记录条目是由<code>history.pushState()</code>方法创建,或者由<code>history.replaceState()</code>方法修改过的, 则<code>popstate</code>事件对象的<code>event.state</code>属性包含了这个历史记录条目的state对象的一个拷贝.</p>
<p>调用<code>history.pushState()</code>或者<code>history.replaceState()</code>不会触发<code>popstate</code>事件. <code>popstate</code>事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> + <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//绑定事件处理函数. </span></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>);    <span class="comment">//添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1</span></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">"title 2"</span>, <span class="string">"?page=2"</span>);    <span class="comment">//添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2</span></span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">"title 3"</span>, <span class="string">"?page=3"</span>); <span class="comment">//修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3</span></span><br><span class="line">        history.back(); <span class="comment">// 弹出 "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"</span></span><br><span class="line">history.back(); <span class="comment">// 弹出 "location: http://example.com/example.html, state: null</span></span><br><span class="line">history.go(<span class="number">2</span>);  <span class="comment">// 弹出 "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="错误处理-第17章"><a href="#错误处理-第17章" class="headerlink" title="错误处理 (第17章)"></a>错误处理 (第17章)</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try-catch语句"></a>try-catch语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会导致错误的代码 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 在错误发生时怎么处理 </span></span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>try</code>块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行<code>catch</code>块。此时，<code>catch</code>块会接收到一个包含错误信息的对象。与在其他语言中不同的是，即使你不想使用这个错误对象，也要给它起个名字。这个对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误消息的<code>error.message</code>属性,一个保存错误类型的<code>error.name</code>属性；</p>
<h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 不会执行</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 不会执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只会return 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在<code>try-catch</code>语句中是可选的，但<code>finally</code>子句一经使用，其代码无论如何都会执行。换句话说，<code>try</code>语句块中的代码全部正常执行，<code>finally</code>子句会执行；如果因为出错而执行了<code>catch</code>语句块，<code>finally</code>子句照样还会执行。只要代码中包含<code>finally</code>子句，则无论try或catch语句块中包含什么代码——甚至<code>return</code>语句，都不会阻止<code>finally</code>子句的执行。来看下面这个函数。</p>
<blockquote>
<p>如果提供finally子句，则catch子句就成了可选的（catch或finally有一个即可）。<br>请读者务必要记住，只要代码中包含finally子句，那么无论try还是catch语句块中的return语句都将被忽略。</p>
</blockquote>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>7种错误类型:</p>
<ul>
<li><code>Error</code></li>
<li><code>EvalError</code></li>
<li><code>RangeError</code></li>
<li><code>ReferenceError</code></li>
<li><code>SyntaxError</code></li>
<li><code>TypeError</code></li>
<li><code>URIError</code></li>
</ul>
<blockquote>
<p>针对错误类型的编程处理</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  someFunction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">    <span class="comment">//处理类型错误 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>) &#123;</span><br><span class="line">    <span class="comment">//处理引用错误 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//处理其他类型的错误 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>try-catch</code>最适合处理那些我们无法控制的错误。假设你在使用一个大型<code>JavaScript库</code>中的函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函数的调用放在<code>try-catch</code>语句当中，万一有什么错误发生，也好恰当地处理它们。<br>在明明白白地知道自己的代码会发生错误时，再使用<code>try-catch</code>语句就不太合适了。例如，如果传递给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定如何去做。在这种情况下，不应用使用<code>try-catch</code>语句。</p>
</blockquote>
<h3 id="抛出错误-throw"><a href="#抛出错误-throw" class="headerlink" title="抛出错误 throw"></a>抛出错误 throw</h3><p>与<code>try-catch</code>语句相配的还有一个<code>throw</code>操作符，用于随时抛出自定义错误。抛出错误时，必须要给<code>throw</code>操作符指定一个值，这个值是什么类型，没有要求。下列代码都是有效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  name: <span class="string">"JavaScript"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在遇到<code>throw</code>操作符时，代码会立即停止执行。仅当有<code>try-catch</code>语句捕获到被抛出的值时，代码才会继续执行。通过使用某种内置错误类型，可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参数，即实际的错误消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Something bad happened."</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码抛出了一个通用错误，带有一条自定义错误消息。浏览器会像处理自己生成的错误一样，来处理这行代码抛出的错误。换句话说，浏览器会以常规方式报告这一错误，并且会显示这里的自定义错误消息。像下面使用其他错误类型，也可以模拟出类似的浏览器错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">"I don’t like your syntax."</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"What type of variable do you take me for?"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">"Sorry, you just don’t have the range."</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EvalError</span>(<span class="string">"That doesn’t evaluate."</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">URIError</span>(<span class="string">"Uri, is that you?"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"You didn’t cite your references properly."</span>);</span><br></pre></td></tr></table></figure>
<p>另外，利用原型链还可以通过继承Error来创建自定义错误类型（原型链在第6章中介绍）。此时，需要为新创建的错误类型指定name和message属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"CustomError"</span>;</span><br><span class="line">  <span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">"My message"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="错误事件-error"><a href="#错误事件-error" class="headerlink" title="错误事件 error"></a>错误事件 error</h3><p>任何没有通过try-catch处理的错误都会触发<code>window</code>对象的<code>window.onerror(message,url,line)</code>事件。在任何Web浏览器中，<code>onerror</code>事件处理程序都不会创建<code>event</code>事件参数对象，但它可以接收三个参数：错误消息<code>message</code>、错误所在的URL<code>url</code>, 行号<code>line</code>。多数情况下，只有错误消息有用，因为URL只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的JavaScript代码，也可能出自外部的文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line</span>) </span>&#123;</span><br><span class="line">  alert(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只要发生错误，无论是不是浏览器生成的，都会触发<code>error</code>事件，并执行这个事件处理程序。然后，浏览器默认的机制发挥作用，像往常一样显示出错误消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line</span>) </span>&#123;</span><br><span class="line">  alert(message);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过return false，这个函数实际上就充当了整个文档中的<code>try-catch</code>语句，可以捕获所有无代码处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线，理想情况下，只要可能就不应该使用它。只要能够适当地使用<code>try-catch</code>语句，就不会有错误交给浏览器，也就不会触发<code>error</code>事件。</p>
<p>图像也支持<code>error</code>事件。只要图像的<code>src</code>特性中的URL不能返回可以被识别的图像格式，就会触发<code>error</code>事件。此时的<code>error</code>事件遵循DOM格式，会返回一个以图像为目标的<code>event</code>对象。下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Image loaded!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(image, <span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Image not loaded!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">image.src = <span class="string">"smilex.gif"</span>; <span class="comment">//指定不存在的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="添加查询字符串工具函数"><a href="#添加查询字符串工具函数" class="headerlink" title="添加查询字符串工具函数"></a>添加查询字符串工具函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addQueryStringArg</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    url += <span class="string">"?"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url += <span class="string">"&amp;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把错误记录到服务器"><a href="#把错误记录到服务器" class="headerlink" title="把错误记录到服务器"></a>把错误记录到服务器</h3><p>要建立这样一种JavaScript错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入口点），用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错误日志中。这个页面可能会使用如下所示的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">sev, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.src = <span class="string">"log.php?sev="</span> + <span class="built_in">encodeURIComponent</span>(sev) + <span class="string">"&amp;msg="</span> + <span class="built_in">encodeURIComponent</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>logError()</code>函数接收两个参数：表示严重程度的数值或字符串（视所用系统而异）及错误消息。其中，使用了Image对象来发送请求，这样做非常灵活，主要表现如下几方面。</p>
<ul>
<li>所有浏览器都支持Image对象，包括那些不支持XMLHttpRequest对象的浏览器。</li>
<li>可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误，而这种情况下使用XMLHttpRequest是不行的。</li>
<li>在记录错误的过程中出问题的概率比较低。大多数Ajax通信都是由JavaScript库提供的包装函数来处理的，如果库代码本身有问题，而你还在依赖该库记录错误，可想而知，错误消息是不可能得到记录的。</li>
</ul>
<p>只要是使用try-catch语句，就应该把相应错误记录到日志中。来看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = mods.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mods[i].init();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    logError(<span class="string">"nonfatal"</span>, <span class="string">"Module init failed: "</span> + ex.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><ul>
<li><code>error(message)</code>：将错误消息记录到控制台</li>
<li><code>info(message)</code>：将信息性消息记录到控制台</li>
<li><code>log(message)</code>：将一般消息记录到控制台</li>
<li><code>warn(message)</code>：将警告消息记录到控制台</li>
</ul>
<h3 id="抛出错误-assert"><a href="#抛出错误-assert" class="headerlink" title="抛出错误 assert()"></a>抛出错误 assert()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 != <span class="string">"number"</span> || <span class="keyword">typeof</span> num2 != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"divide(): Both arguments must be numbers."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于大型应用程序来说，自定义的错误通常都使用<code>assert(condition,errMessage)</code>函数抛出。这个函数接受两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误信息。以下就是一个非常基本的<code>assert()</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用这个<code>assert()</code>函数代替某些函数中需要调试的if语句，以便输出错误消息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  assert(<span class="keyword">typeof</span> num1 == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">"number"</span>, <span class="string">"divide(): Both arguments must be numbers."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/30/高程vol9-表单脚本/" class="next">上一篇</a><a href="/2018/01/02/高程11-ajax-json/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>