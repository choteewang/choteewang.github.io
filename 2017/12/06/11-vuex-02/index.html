<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vuex 02 : 基于Getter, Mutation, Action,继续改造Demo · choteewang</title><meta name="description" content="Vuex 02 : 基于Getter, Mutation, Action,继续改造Demo - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vuex 02 : 基于Getter, Mutation, Action,继续改造Demo</h1><div class="post-info">2017年12月6日</div><div class="post-content"><p>经过上篇的旅程, 已经可以做出一个有Vuex基本功能的Counter了. 为了让Counter的逻辑更完善, 今天引入Getter, Mutation, Action 来继续优化代码</p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>在本例中,将count是奇书还是偶数的逻辑写在getter中.</p>
<p>Getter接收<code>state</code>作为第一个参数,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">  <span class="comment">// getter方法的第一个参数是state,第二个参数是getters对象</span></span><br><span class="line">  oddOrEven(state)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组件内部的写法,这里getter会暴露为Store.getters对象, 同时getter也接收getters对象本身作为第二个参数, 这样可以接受其他getter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  count()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">  &#125;,</span><br><span class="line">  oddOrEven()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.oddOrEven</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>在Vuex里,提交状态需要用到<code>mutation</code>与<code>action</code>,<code>action</code>更像在mutation外面包了一层, 类似Redux中的<code>action creater</code>产生<code>action</code>一样, 在Vuex里, <code>mutation</code>只保留最原始的逻辑, 操作state中的数据, 其他commit mutation的逻辑和异步操作交给<code>action</code>去处理.</p>
<p>所以,异步和其他逻辑处理交给<code>action</code>,所以<code>mutation</code>必须是同步的</p>
<p><code>mutation</code>的类型最好用常量去代替, 这点也与Redux等Flux架构相统一, 可以使用ES6的计算属性优化常量作为函数名的写法.</p>
<p>提交mutation的唯一方式是<code>store.commit(mutation)</code>,这里可以在<code>commit mutation</code>时附加提交数据<code>payload</code>,习惯写成对象的提交方式如<code>{type:INCREMENT,step:1}</code>,这个对象在store定义时的<code>mutation</code>方法中是第二个参数, 写成<code>payload</code>是很好的社区规范.这里用step来定义 counter 加减的跨度</p>
<p>总结一下,如下改写mutation:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations:&#123;</span><br><span class="line">  <span class="comment">// ES6计算属性写法,来命名函数名,payload是组件内部提交的&#123;type:string,step:string&#125;的对象</span></span><br><span class="line">  [INCREMENT](state,payload)&#123;</span><br><span class="line">    state.count += payload.step</span><br><span class="line">  &#125;,</span><br><span class="line">  [DECREMENT](state,payload)&#123;</span><br><span class="line">    state.count -= payload.step</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件内提交时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>action</code>是在<code>mutation</code>外包的一层方法, 用来定义触发<code>commit mutation</code>的逻辑, 更主要的是异步逻辑.</p>
<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p>
<p>实践中，我们会经常用到 ES6的解构赋值来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Action 通过 store.dispatch 方法触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>
<p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以现在在dispatch时可以:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在另一个action内也可以:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到本例,将提交mutation的逻辑全部移入action,将做减法的逻辑改成异步,1秒以后执行,代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store配置内</span></span><br><span class="line">actions:&#123;</span><br><span class="line">    <span class="comment">// 用action将mutation包一层,把触发mutation的逻辑写在action中</span></span><br><span class="line">    [INCREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="comment">// 对象风格提交方式提交mutation, 与Redux统一</span></span><br><span class="line">      commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// action可以是异步的,可以用Promise包装</span></span><br><span class="line">    [DECREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          commit(&#123;<span class="attr">type</span>:DECREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 组件methods内</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  increment()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(INCREMENT) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//store.dispatch可以处理被触发的action的处理函数返回的promiste,dispatch仍旧返回Promise</span></span><br><span class="line">  decrement()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(DECREMENT).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Async deduct works!'</span>)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://i.loli.net/2017/12/06/5a27a4aade6b2.jpg" alt=""></p>
<h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用常量替代字符串</span></span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    count:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    <span class="comment">// getter方法的第一个参数是state,第二个参数是getters对象</span></span><br><span class="line">    oddOrEven(state)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    <span class="comment">// ES6计算属性写法,来命名函数名,payload是组件内部提交的&#123;type:string,step:string&#125;的对象</span></span><br><span class="line">    [INCREMENT](state,payload)&#123;</span><br><span class="line">      state.count += payload.step</span><br><span class="line">    &#125;,</span><br><span class="line">    [DECREMENT](state,payload)&#123;</span><br><span class="line">      state.count -= payload.step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">    <span class="comment">// 用action将mutation包一层,把触发mutation的逻辑写在action中</span></span><br><span class="line">    [INCREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="comment">// 对象风格提交方式提交mutation, 与Redux统一</span></span><br><span class="line">      commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// action可以是异步的,可以用Promise包装</span></span><br><span class="line">    [DECREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          commit(&#123;<span class="attr">type</span>:DECREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="increment"&gt; + &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="decrement"&gt; - (Async) &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    oddOrEven()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.oddOrEven</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(INCREMENT) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//store.dispatch可以处理被触发的action的处理函数返回的promiste,dispatch仍旧返回Promise</span></span><br><span class="line">    decrement()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(DECREMENT).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Async deduct works!'</span>)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">  components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在, 我们已经完成了一个符合Vuex规范的Counter, 其可以完美的运行和异步处理数据, 下一次将会对代码进行拆分解耦, 并在组件内部优化action与getter的部署代码</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/05/10-vuex-01/" class="next">上一篇</a><a href="/2017/12/06/12-Vuex-03/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>