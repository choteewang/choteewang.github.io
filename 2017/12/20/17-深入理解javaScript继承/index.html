<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入理解javaScript继承机制 · choteewang</title><meta name="description" content="深入理解javaScript继承机制 - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入理解javaScript继承机制</h1><div class="post-info">2017年12月20日</div><div class="post-content"><h3 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么?"></a>这是什么?</h3><p>自己在学习《JavaScript高级程序设计》 和《ES6 标准教程》 中的一些体会. 主要关注<code>javascript</code>继承的组织模式, 自己的一些心得体会.</p>
<p>写博客的目的是为了学习的正反馈, 帮助自己理解.</p>
<blockquote>
<p>这篇博客会直接上最终结论, 后面再放上推导最终结论的过程.<br>这样做的理由是, 如果直接能理解最终结论, 就不太用看推导过程了</p>
</blockquote>
<h2 id="最佳实践-寄生组合式继承"><a href="#最佳实践-寄生组合式继承" class="headerlink" title="最佳实践, 寄生组合式继承"></a>最佳实践, 寄生组合式继承</h2><p>不啰嗦, 直接上结论, javaScript继承的最佳实践, 最终形态, 应该如图所示</p>
<p><img src="https://i.loli.net/2017/12/20/5a399d347382c.jpg" alt=""></p>
<blockquote>
<p>解释下上面的流程图.</p>
<ol>
<li><code>[[ prototype ]]</code> 的浏览器实现是 <code>.__proto__</code></li>
<li>首字母大写的是<code>构造函数</code> 或 <code>类</code>, 首字母小写的是 <code>构造函数实例</code> 或 <code>类实例</code></li>
<li>应用上图的继承方式,<code>son</code>实例继承了<code>Father</code>构造函数中的属性,且属性变为私有, 在<code>son1</code>上修改继承后的属性, 不会影响<code>son2</code>中的属性.</li>
<li>应用上图的继承方式, <code>son</code>实例继承了<code>Father.prototype</code>原型中的公用方法, 这些方法被<code>son1</code>,<code>son2</code>所共用, 修改<code>son1</code>上继承的方法会影响<code>son2</code>中的同名方法</li>
<li>所以应该这样组织我们的代码, 将需要私有的属性放入<code>构造函数</code>中用<code>Father.call(this,...args)</code>来继承, 将需要共用的属性放入<code>Father.prototype</code>中用原型链继承.</li>
<li>这种继承之所以是最佳实践, 因为既解决了<code>共用方法复用</code>,又解决了<code>属性私有化</code>,还解决了<code>instanceof,isPrototypeOf 指向问题</code></li>
</ol>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// just 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Son, Father</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用原型式继承创建一个对象,此对象原型式继承自Father.prototype</span></span><br><span class="line">  <span class="keyword">var</span> prototype = object(Father.prototype);</span><br><span class="line">  <span class="comment">// 将此对象赋值为Son的原型对象指针Son.prototype</span></span><br><span class="line">  <span class="comment">// 相当于使Son.prototype原型式继承自Father.protottype</span></span><br><span class="line">  <span class="comment">// 从而使所有Son实例获得了Father.prototype上的公用属性和方法</span></span><br><span class="line">  prototype.constructor = Son;</span><br><span class="line">  Son.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下述方法会因寄生式继承继承给Son.prototype</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用借用构造函数式继承,继承了Father构造函数中的属性</span></span><br><span class="line">  <span class="comment">// 借用构造函数继承的属性不复用.每个Son实例中的属性都是独立的</span></span><br><span class="line">  <span class="comment">// 原理是this都不一样,所以当然是独立的</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改Son.prototype指向</span></span><br><span class="line"><span class="comment">// 使其指向我们创建的继承自Father.prototype的对象</span></span><br><span class="line">inheritPrototype(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强Son.prototype,增加的方法sayAge是father实例访问不到的.</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"Jordan"</span>, <span class="number">23</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Jordan";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"Kobe"</span>, <span class="number">24</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Kobe";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//24</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6中类的实现方式"><a href="#ES6中类的实现方式" class="headerlink" title="ES6中类的实现方式"></a>ES6中类的实现方式</h3><blockquote>
<p>ES6中,<code>类</code>的继承方式和<code>继承组合式</code>继承相吻合. 其中<code>Father.call(this,...args)</code>用<code>super(..args)</code>实现</p>
</blockquote>
<p><img src="https://i.loli.net/2017/12/20/5a399f0887a7a.jpg" alt=""></p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><blockquote>
<p>下面是最终结论的推导过程</p>
</blockquote>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote>
<p>原型链继承存在2个缺陷:<br>1.像下面代码一样,不能从<code>Father</code>构造函数中直接继承属性,还要再定义一个<code>sonName</code><br>2.像下面代码一样,steve向favorite中push了’kobe’,导致mike的favorite也发生了改变,没有做到<code>继承属性私有化</code><br>解决这个问题的方式是<code>借用构造函数</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">  <span class="keyword">this</span>.favorite = [<span class="string">'Johnson'</span>,<span class="string">'Bird'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hey,I\'m father'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sonName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hey,I\'m son'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mike = <span class="keyword">new</span> Son(<span class="string">'mike'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.name) <span class="comment">//father</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.sonName) <span class="comment">//mike</span></span><br><span class="line">mike.sayHi() <span class="comment">// hey I m son</span></span><br><span class="line"><span class="keyword">const</span> steve = <span class="keyword">new</span> Son(<span class="string">'steve'</span>)</span><br><span class="line">steve.favorite.push(<span class="string">'kobe'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.favorite); <span class="comment">//["Johnson", "Bird", "kobe"]</span></span><br></pre></td></tr></table></figure>
<h3 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h3><blockquote>
<p><code>混合继承</code> 由 <code>原型链继承</code> 添加 <code>借用构造函数</code> 修改而来<br><code>借用构造函数</code> 实现了 让每个<code>son</code>实例都有自己的name与favorite属性,且都继承自Father构造函数</p>
<p>但这还不够完美, 比如, <code>Son.prototype</code>中,永远存放着一个<code>name</code>和<code>favorite</code>属性,<code>son</code>实例每次都通过重写来覆盖这两个属性,这是不必要的<br>解决方法是在此基础上增加<code>寄生式继承</code>,而<code>寄生式继承</code>依赖于<code>原型式继承</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'father'</span></span><br><span class="line">  <span class="keyword">this</span>.favorite = [<span class="string">'Johnson'</span>,<span class="string">'Bird'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hey,I\'m father'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="comment">// 每个实例都有自己私有的name和favorite,且都继承自Father构造函数</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>,name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hey,I\'m son'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mike = <span class="keyword">new</span> Son(<span class="string">'mike'</span>,<span class="number">23</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.name) <span class="comment">//father</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.sonName) <span class="comment">//mike</span></span><br><span class="line">mike.sayHi() <span class="comment">//"hey I m son"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> steve = <span class="keyword">new</span> Son(<span class="string">'steve'</span>,<span class="number">24</span>)</span><br><span class="line">steve.favorite.push(<span class="string">'kobe'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(steve.favorite); <span class="comment">//["Johnson", "Bird", "kobe"]</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.favorite); <span class="comment">//["Johnson", "Bird"]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/20/5a399d3498b67.jpg" alt=""></p>
<h3 id="原型式继承的原理"><a href="#原型式继承的原理" class="headerlink" title="原型式继承的原理"></a>原型式继承的原理</h3><blockquote>
<p>原型式继承就是让o1的原型对象是o,当然这其中有一些tricks</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用这种方法的目的是return的new F()是一个新对象</span></span><br><span class="line"><span class="comment">// 给new F()增加新的方法,并不会增加到o上.</span></span><br><span class="line"><span class="keyword">const</span> o1 = object(o)</span><br></pre></td></tr></table></figure>
<h3 id="ES5规范的原型式继承-Object-create"><a href="#ES5规范的原型式继承-Object-create" class="headerlink" title="ES5规范的原型式继承,Object.create()"></a>ES5规范的原型式继承,Object.create()</h3><p><code>Object.create(prototypeObj[,descriptorsObj]) return obj</code></p>
<blockquote>
<p>es5用<code>Object.create()</code>方法规范了原型式继承<br>创建一个obj对象,原型是prototypeObj(obj.<strong>proto</strong> === prototypeObj),同时用descriptorsObj(与Object.defineProperties()中的第二个参数相同)定义obj上自己的属性.<br>适用场景: 只是想让一个对象与另一个对象保持类似的情况下,用此方法简单粗暴</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> father = &#123;  <span class="attr">name</span>: <span class="string">'Father'</span>,&#125;;<span class="keyword">var</span> son = <span class="built_in">Object</span>.create(father, &#123;  <span class="attr">name</span>: &#123;    <span class="attr">value</span>: <span class="string">"son"</span>  &#125;&#125;);alert(son.name); <span class="comment">//"son"</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote>
<p>理解<code>寄生式继承</code>的目的是理解最终的<code>寄生组合式</code>继承. </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() </span><br><span class="line">  <span class="comment">//这里返回的事一个新对象,不是obj的浅拷贝,而是obj的原型继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inHeritance</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里创建出的o1,原型继承自o</span></span><br><span class="line">  <span class="keyword">var</span> o1 = object(o)</span><br><span class="line">  <span class="comment">//增强o1,添加sayHi()方法</span></span><br><span class="line">  <span class="comment">//且这个方法不会添加到o上</span></span><br><span class="line">  o1.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'choteewang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个newObj,寄生继承自obj,比obj多一个方法sayHi()</span></span><br><span class="line"><span class="keyword">var</span> newObj = inHeritance(obj)</span><br><span class="line">newObj.sayHi() <span class="comment">//hey</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name) <span class="comment">//choteewang,继承自原型对象</span></span><br><span class="line">obj.sayHi() <span class="comment">//报错,obj没有这个属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>推导过程完毕, 请跳跃到顶部理解<code>最佳实践,寄生组合式继承</code></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/19/16-高程vol2-第六章/" class="next">上一篇</a><a href="/2017/12/20/高程vol3-第七章/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>