<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正反馈系列:《JavaScript高级程序设计》OOP · choteewang</title><meta name="description" content="正反馈系列:《JavaScript高级程序设计》OOP - choteewang@qq.com"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="choteewang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">CHOTEE'S BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">LIST</a></li><li class="nav-list-item"><a href="https://github.com/choteewang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">正反馈系列:《JavaScript高级程序设计》OOP</h1><div class="post-info">2017年12月19日</div><div class="post-content"><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="对象的底层attribute"><a href="#对象的底层attribute" class="headerlink" title="对象的底层attribute"></a>对象的底层attribute</h3><p>放在了两对儿方括号中，例如<code>[[Enumerable]]</code>,JavaScript不能直接访问他们,是为了实现引擎而实现的.</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性就是不用<code>get</code>和<code>set</code>描述的属性,包含一个数据值的位置, 可以读取或写入值, 值的位置是<code>[[value]]</code>,同时被下列属性限制着.</p>
<ul>
<li><code>[[Configurable]]</code> 表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true</li>
<li><code>[[Enumerable]]</code> 表示能否通过 for-in 循环返回属性,是否可枚举,对象上的属性默认true</li>
<li><code>[[Writable]]</code>：能否修改属性的值。</li>
<li><code>[[Value]]</code>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。默认值undefined</li>
</ul>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p><code>Object.defineProperty(obj,propName,descriptorObj) return obj</code></p>
<p>在调用<code>obj.defineProperty()</code>方法时,如果不指定,<code>configurable, enumerable, writable</code>属性的默认值都变为false.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">//'Nicholas'</span></span><br><span class="line">person.name = <span class="string">"Michael"</span>;</span><br><span class="line">alert(person.name); <span class="comment">//'Nicholas'</span></span><br></pre></td></tr></table></figure>
<h3 id="configurable属性"><a href="#configurable属性" class="headerlink" title="configurable属性"></a>configurable属性</h3><p>把<code>configurable</code>设置为false,表示不能用<code>delete</code>运算符从对象中删除属性. 且不能再将此属性变为’可配置’,且此时再调用<code>obj.defineProperty()</code>方法修改除<code>writable</code>之外的特性,都会导致错误.</p>
<p>也就是说,可以多次调用<code>obj.defineProperty()</code>方法修改同一个属性,但在把<code>configurable</code>设置为false之后,就会有了很大限制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'</span></span><br></pre></td></tr></table></figure>
<h3 id="访问器属性-get-set"><a href="#访问器属性-get-set" class="headerlink" title="访问器属性 get,set"></a>访问器属性 get,set</h3><p><code>访问器属性</code>这个概念相对于<code>数据属性</code>,它们包含一对<code>getter</code>和<code>setter</code>函数(都不必须),读取属性时调用<code>getter</code>,赋值时调用<code>setter</code>, 它们被下列属性限制</p>
<ul>
<li><code>[[Configurable]]</code> 表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true</li>
<li><code>[[Enumerable]]</code> 表示能否通过 for-in 循环返回属性,是否可枚举,对象上的属性默认true</li>
<li><code>[[get]]</code> 默认undefined</li>
<li><code>[[set]]</code> 默认undefined</li>
</ul>
<blockquote>
<p>访问器属性不能直接定义,必须通过Object.defineProperty()定义.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;<span class="keyword">var</span> book = &#123;    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,    &#125;,    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="comment">// 访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化</span></span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不一定非要同时指定 <code>getter</code> 和 <code>setter</code>。只指定 <code>getter</code> 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 <code>getter</code> 函数的属性会抛出错误。<br>类似地，只指定 <code>setter</code> 函数的属性不能读<br>旧方法obj.<strong>defineGetter</strong>与__defineSetter已经被废弃</p>
</blockquote>
<h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p><code>Object.defineProperties(obj,descriptorsObj) return obj</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p><code>Object.getOwnPropertyDescriptor(obj, propName) return DescriptorsObj</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//undefined</span></span><br><span class="line">alert(descriptor.enumerable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 <code>Object.getOwnPropertyDescriptor()</code>方法</p>
</blockquote>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="Object-obj"><a href="#Object-obj" class="headerlink" title="Object(obj)"></a>Object(obj)</h3><p><code>Object(obj) return obj1</code></p>
<p><code>Object()</code>方法可以作为传入对象的包装器,生成一个obj1对象,obj1是obj的浅拷贝</p>
<pre><code class="js"><span class="keyword">var</span> obj = {
  name:<span class="string">'choteewang'</span>,
}
<span class="keyword">var</span> obj1 = <span class="built_in">Object</span>(obj)
<span class="built_in">console</span>.log(obj1); 
<span class="built_in">console</span>.log(obj1.name); <span class="comment">// choteewang</span>
obj1.name=<span class="string">'jordan'</span>
<span class="built_in">console</span>.log(obj.name); <span class="comment">// jordan</span>
</code></pre>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.job=job;</span><br><span class="line">  <span class="keyword">this</span>.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行了下面步骤:</p>
<ol>
<li>创建一个对象</li>
<li>将构造函数this指向此对象</li>
<li>执行构造函数中的代码</li>
<li>不用return,但返回新对象</li>
</ol>
</blockquote>
<h4 id="构造函数当做普通函数"><a href="#构造函数当做普通函数" class="headerlink" title="构造函数当做普通函数"></a>构造函数当做普通函数</h4><blockquote>
<p>不调用new运算符,构造函数与普通函数无异,this指向全局global对象,在浏览器中是window.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当做构造函数调用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);  <span class="comment">//adds to window</span></span><br><span class="line"><span class="built_in">window</span>.sayName();   <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域内被调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName();    <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure>
<h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj instanceOf <span class="built_in">Object</span> <span class="comment">// 判断Object.prototype是否在obj的原型链上</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>检测类型用 instanceof 好过typeof(可以检测构造函数名,类型更具体) 与 obj.constructor(原型指向后期可改,返回不了正确值)</p>
</blockquote>
<h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>为每个类似的实例都创建了相似的方法和属性,所以需要引进<code>原型模式</code>,将公用方法和属性放在原型上.</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><img src="https://i.loli.net/2017/12/19/5a390f498339e.jpg" alt=""></p>
<blockquote>
<p><code>[[Prototype]]</code> 的实现就是浏览器里的 <code>__proto__</code></p>
</blockquote>
<h4 id="Prototype-isPrototypeOf-obj"><a href="#Prototype-isPrototypeOf-obj" class="headerlink" title="Prototype.isPrototypeOf(obj)"></a>Prototype.isPrototypeOf(obj)</h4><p><code>Prototype.isPrototypeOf(obj) return boolean</code></p>
<blockquote>
<p>类似instanceOf运算符的逆方法,只要<code>Prototype</code>在<code>obj</code>的原型链上,就返回true</p>
</blockquote>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p><code>Object.getPrototypeOf(obj) return obj.__proto__</code></p>
<p>ECMAScript 5 增加了一个新方法，叫 <code>Object.getPrototypeOf()</code>，在所有支持的实现中，这个 方法返回<code>[[Prototype]]</code>的值</p>
<h4 id="obj-hasOwnProperty-propName"><a href="#obj-hasOwnProperty-propName" class="headerlink" title="obj.hasOwnProperty(propName)"></a>obj.hasOwnProperty(propName)</h4><p><code>obj.hasOwnProperty(propName) return boolean</code></p>
<blockquote>
<p>用来判断propName属性是处于obj中还是继承自obj的原型链.这个方法是从Object.prototype中继承来的</p>
</blockquote>
<p>列举下从Object.prototype继承来的方法</p>
<ul>
<li><code>obj.hasOwnProperty(propertyName)</code> 用于检测给定属性在当前实例中(不包含原型链中)是否存在</li>
<li><code>obj.isPrototypeOf(obj2)</code> 用于检查obj是否在obj2的原型链上</li>
<li><code>obj.propertyIsEnumerable(propertyName)</code> 用于检查给定属性是否可枚举</li>
<li><code>obj.toLocaleString()</code> </li>
<li><code>obj.toString()</code></li>
<li><code>obj.valueOf()</code> 返回对象的字符串,数值,或布尔值表示,通常与toString()返回值相同</li>
</ul>
<blockquote>
<p>ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属 性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。</p>
</blockquote>
<h4 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h4><ul>
<li>用于for-in循环</li>
<li><code>(&quot;propName&quot; in obj)</code> // true or false</li>
</ul>
<blockquote>
<p>只要obj可以访问到propName,就返回true,无论propName部署在对象实例上还是其原型链上</p>
<p>只要用in操作符返回true &amp;&amp; 调用hasOwnProperty()返回false, 就能确定属性部署在原型链上</p>
</blockquote>
<h4 id="for-in-循环的范围"><a href="#for-in-循环的范围" class="headerlink" title="for-in 循环的范围"></a>for-in 循环的范围</h4><blockquote>
<p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性， 也包括存在于原型中的属性。 屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的</p>
</blockquote>
<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p><code>Object.keys(obj) return arr</code></p>
<blockquote>
<p>该方法可以取得参数对象上所有<code>可枚举</code>的属性,并将属性名组合为一个数组返回</p>
</blockquote>
<h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames(obj) return arr</code></p>
<blockquote>
<p>该方法取得所有obj实例上的属性,枚举不枚举的都算,并将属性名组合为一个数组返回</p>
</blockquote>
<h4 id="修改原型的同时修改constructor属性"><a href="#修改原型的同时修改constructor属性" class="headerlink" title="修改原型的同时修改constructor属性"></a>修改原型的同时修改constructor属性</h4><blockquote>
<p>修改构造函数的prototype会让新设置的prototype对象的constructor指向不准确,如下例,新prototype对象的constructor指向Object.prototype.<br>所以需要手动给新prototype对象添加constructor属性<br>constructor属性默认不可枚举,所以要用<code>Object.defineProperty()</code>修改.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.protoype = &#123; <span class="attr">new</span>: <span class="string">"new"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">'constructor'</span>,&#123;</span><br><span class="line">  enumerable:<span class="literal">false</span>;</span><br><span class="line">  value:Person;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote>
<p>下面的例子模拟了javaScript代码内部的原型链继承部署模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line">alert(instance.getSuperValue()) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType) <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/12/19/5a390f4a02d8c.jpg" alt=""></p>
<h4 id="重写超类型的方法"><a href="#重写超类型的方法" class="headerlink" title="重写超类型的方法"></a>重写超类型的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.property = <span class="literal">true</span>;&#125;SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.property;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;&#125;<span class="comment">//inherit from SuperType</span>SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//new method</span>SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;&#125;;<span class="comment">//override existing method</span>SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;;<span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();alert(instance.getSuperValue());   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType 中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。</p>
</blockquote>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;            &#125;<span class="comment">//inherit from SuperType</span>SubType.prototype = <span class="keyword">new</span> SuperType();<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors);    <span class="comment">//"red,blue,green,black"</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();alert(instance2.colors);    <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子中的 SuperType 构造函数定义了一个 colors 属性，该属性包含一个数组（引用类型值）。SuperType 的每个实例都会有各自包含自己数组的 colors 属性。当 SubType 通过原型链继承了 SuperType 之后, SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。而我们对 instance1.colors 的修改 能够通过 instance2.colors 反映出来，就已经充分证实了这一点。</p>
</blockquote>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><blockquote>
<p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数，如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//inherit from SuperType</span>  SuperType.call(<span class="keyword">this</span>);&#125;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码中加粗的那一行代码“借调”了超类型的构造函数。通过使用 call()方法（或 apply()方法也可以），我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p>
</blockquote>
<h4 id="借用构造函数-向超类型构造函数传递参数"><a href="#借用构造函数-向超类型构造函数传递参数" class="headerlink" title="借用构造函数 - 向超类型构造函数传递参数"></a>借用构造函数 - 向超类型构造函数传递参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//inherit from SuperType passing in an argument</span>  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);  <span class="comment">//instance property</span>  <span class="keyword">this</span>.age = <span class="number">29</span>;&#125;<span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();alert(instance.name); <span class="comment">//"Nicholas";</span>alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote>
<p>最简单高效的继承模式,用<code>原型链继承</code>原型属性和方法,用<code>借用构造函数</code>方式实现对原型属性和方法的集成.<br>既通过<code>原型链继承</code>实现了方法复用,又通过<code>借用构造函数</code>保证了每个实例都有自己的属性.</p>
<p>弊端: 调用两次SuperType()构造函数, 使得SubType.prototype里有两个无用变量name,colors.<br>每次new Subtype()时,subtype实例内部自带name与colors,自带的属性覆盖掉了SubType.prototype中的name与colors,所以SubType.prototype中的name与colors没用.<br>解决方法直接看本章最后一节寄生混合式继承的笔记</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.name);&#125;;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;  SuperType.call(<span class="keyword">this</span>, name);  <span class="keyword">this</span>.age = age;&#125;SubType.prototype = <span class="keyword">new</span> SuperType();SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.age);&#125;;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="comment">//"Nicholas";</span>instance1.sayAge(); <span class="comment">//29</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);alert(instance2.colors); <span class="comment">//"red,blue,green"</span>instance2.sayName(); <span class="comment">//"Greg";</span>instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-create-原型式继承"><a href="#Object-create-原型式继承" class="headerlink" title="Object.create() - 原型式继承"></a>Object.create() - 原型式继承</h3><p><code>Object.create(prototypeObj[,descriptorsObj]) return obj</code></p>
<blockquote>
<p>创建一个obj对象,原型是prototypeObj(obj.<strong>proto</strong> === prototypeObj),同时用descriptorsObj(与Object.defineProperties()中的第二个参数相同)定义obj上自己的属性.<br>适用场景: 只是想让一个对象与另一个对象保持类似的情况下,用此方法简单粗暴</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;  <span class="attr">name</span>: <span class="string">"Nicholas"</span>,  <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;<span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;  <span class="attr">name</span>: &#123;    <span class="attr">value</span>: <span class="string">"Greg"</span>  &#125;&#125;);alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生式继承-只是下述寄生组合式继承的原理"><a href="#寄生式继承-只是下述寄生组合式继承的原理" class="headerlink" title="寄生式继承(只是下述寄生组合式继承的原理)"></a>寄生式继承(只是下述寄生组合式继承的原理)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() </span><br><span class="line">  <span class="comment">//这里返回的事一个新对象,不是obj的浅拷贝,而是obj的原型继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inHeritance</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = object(o)</span><br><span class="line">  <span class="comment">//增强o1,添加sayHi()方法</span></span><br><span class="line">  o1.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'choteewang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = inHeritance(obj)</span><br><span class="line">newObj.sayHi() <span class="comment">//hey</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name) <span class="comment">//choteewang,继承自原型对象</span></span><br><span class="line">obj.sayHi() <span class="comment">//报错,obj没有这个属性</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote>
<p>本章的终结,改善了<code>组合式继承</code>的缺点,是最成熟的js继承方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// just 原型式继承</span><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  F.prototype = o;  <span class="keyword">return</span> <span class="keyword">new</span> F();&#125;<span class="comment">// 寄生式继承</span><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用原型式继承创建一个对象,此对象原型式继承自superType.prototype</span>  <span class="keyword">var</span> prototype = object(superType.prototype); </span><br><span class="line">  <span class="comment">// 将此对象赋值为subType的原型对象指针subType.prototype</span></span><br><span class="line">  <span class="comment">// 相当于使subType.prototype原型式继承自superType.protottype</span></span><br><span class="line">  <span class="comment">// 从而使所有subtype实例获得了superType.prototype上的公用属性和方法</span>  prototype.constructor = subType;   subType.prototype = prototype; &#125;<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="comment">// 下述方法会因寄生式继承继承给subType.prototype</span>SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.name);&#125;;<span class="comment">// 借用构造函数继承</span><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用借用构造函数式继承,继承了SuperType构造函数中的属性</span></span><br><span class="line">  <span class="comment">// 借用构造函数继承的属性不复用.每个subType实例中的属性都是独立的</span></span><br><span class="line">  <span class="comment">// 原理是this都不一样,所以当然是独立的</span>  SuperType.call(<span class="keyword">this</span>, name);  <span class="keyword">this</span>.age = age;&#125;<span class="comment">// 修改subType.prototype指向</span></span><br><span class="line"><span class="comment">// 使其指向我们创建的继承自superType.prototype的对象</span>inheritPrototype(SubType, SuperType);<span class="comment">// 增强SubType.prototype,增加的方法sayAge是supertype实例访问不到的.</span>SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.age);&#125;;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="comment">//"Nicholas";</span>instance1.sayAge(); <span class="comment">//29</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);alert(instance2.colors); <span class="comment">//"red,blue,green"</span>instance2.sayName(); <span class="comment">//"Greg";</span>instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/19/15-高程1-5章/" class="next">上一篇</a><a href="/2017/12/20/17-深入理解javaScript继承/" class="prev">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">choteewang@qq.com</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>