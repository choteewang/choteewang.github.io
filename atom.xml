<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>choteewang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-22T06:20:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>choteewang@qq.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》DOM 扩展</title>
    <link href="http://yoursite.com/2017/12/22/%E9%AB%98%E7%A8%8Bvol6-11%E7%AB%A0-dom%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/12/22/高程vol6-11章-dom扩展/</id>
    <published>2017-12-22T06:20:00.000Z</published>
    <updated>2017-12-22T06:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><ul><li><code>document/element.querySelector() return node</code></li><li><code>document/element.querySelectorAll() return NodeListSnapShot</code></li></ul><blockquote><p>返回的NodeList可以调用.item(index)方法,或使用方括号法,访问伪数组中的元素<br>第一个方法在没找到匹配元素时会 return null,第二个会return一个空NodeList<br>返回的数据只是NodeList<code>快照</code>,不会动态更新,性能好,看下面例子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;div&gt;1&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//&lt;div&gt;2&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//&lt;div&gt;3&lt;/div&gt;</span></span><br><span class="line">&lt;script id=<span class="string">"tag"</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(divs); <span class="comment">//3个元素</span></span><br><span class="line">  <span class="keyword">var</span> tag = <span class="built_in">document</span>.getElementById(<span class="string">'tag'</span>)</span><br><span class="line">  <span class="keyword">var</span> insert = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  insert.innerHTML = <span class="number">4</span></span><br><span class="line">  <span class="built_in">document</span>.body.insertBefore(insert,tag) </span><br><span class="line">  <span class="built_in">console</span>.log(divs); <span class="comment">//3个元素</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>element.matchesSelector(selector) return boolean</code> </li></ul><blockquote><p>测试某个元素是否会被<code>querySelector,querySelectorAll</code>选中,截止到2011年,大多数的浏览器中都没有支持中国方法,如果要使用,先能力检测</p></blockquote><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p><code>element</code>增加了5个新属性</p><pre><code>* `childElementCount`：返回子元素（不包括文本节点和注释）的个数。* `firstElementChild`：指向第一个子元素；firstChild 的元素版。* `lastElementChild`：指向最后一个子元素；lastChild 的元素版。* `previousElementSibling`：指向前一个同辈元素；previousSibling 的元素版。* `nextElementSibling`：指向后一个同辈元素；nextSibling 的元素版。</code></pre><blockquote><p>遍历子元素代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, len, child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span>(child != element.lastElementChild)&#123; </span><br><span class="line">    processChild(child); <span class="comment">//已知其是元素 </span></span><br><span class="line">    child = child.nextElementSibling; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="element-getElementsByClassName"><a href="#element-getElementsByClassName" class="headerlink" title="element.getElementsByClassName()"></a>element.getElementsByClassName()</h3><p><code>document/element.getElementsByClassName(classString) return NodeList</code></p><blockquote><p><code>classString</code>可以是<code>&quot;username current&quot;</code>这种格式, 顺序无所谓</p></blockquote><h3 id="element-classList属性"><a href="#element-classList属性" class="headerlink" title="element.classList属性"></a>element.classList属性</h3><blockquote><p>演示传统的js操作element的class特性的方式:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classNames = element.className.split(<span class="regexp">/\s+/</span>)</span><br><span class="line"></span><br><span class="line">classNames = classNames.some(<span class="function"><span class="keyword">function</span> (<span class="params">v,i,arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v === <span class="string">'deleteValue'</span>)&#123;</span><br><span class="line">    arr.splice(i,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">element.className = classNames.join(<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上述方法太麻烦,所以HTML5给每个元素新增了<code>classList</code>属性,该属性是新集合类型<code>DOMTokenList</code>实例,与其他DOM集合类似,<code>DOMTokenList</code>有<code>length</code>属性,可以使用<code>.item()</code>方法和方括号语法,还增加了下列方法</p><pre><code>* `add(value)`：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 * `contains(value) return boolean`：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 * `remove(value)`：从列表中删除给定的字符串。 * `toggle(value)`：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。</code></pre></blockquote><p>至此,前面那些代码一行代码搞定<code>element.classList.remove(&quot;deleteValue&quot;)</code>    </p><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><blockquote><p>一个元素若想获得焦点,有两种方式</p><ol><li>被用户tab键切中</li><li>调用<code>element.focus()</code>方法</li><li>页面加载后<code>document.body</code>默认获得焦点</li></ol></blockquote><ul><li><code>document.activeElement</code>属性,始终会引用DOM中获得了焦点的元素</li><li><code>document.hasFocus() return boolean</code> 这个方法用于确认文档是否获得了焦点(文档内的元素获得了焦点,文档也算获得了焦点)</li></ul><h3 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h3><ul><li><code>document.readyState</code>属性,两个可能的值<code>loading,complete</code>,分别表示正在加载,和加载完成</li><li><code>document.compatMode</code>属性,标准模式时值为<code>CSS1Compat</code>,混杂模式时值为<code>BackCompat</code></li><li><code>document.head</code>属性,引用<code>&lt;head&gt;</code>标签</li></ul><h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><ul><li><code>document.charset</code>属性, 表示文档中实际可使用字符集,可直接设置以修改</li><li><code>document.defaultCharset</code>属性, ，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么</li></ul><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><blockquote><p>HTML5规定可以给元素添加自定义特性,格式是<code>data-attrName</code><br>同时元素上添加<code>element.dataset</code>属性,属性的值是<code>DOMStringMap</code> 的一个实例，也就是一个名值对儿的映射。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;div id="ctw" data-chotee="choteewang"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> ctw = <span class="built_in">document</span>.getElementById(<span class="string">'ctw'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ctw.dataset.chotee); <span class="comment">// choteewang</span></span><br><span class="line">ctw.dataset.chotee = <span class="string">'another chotee'</span></span><br><span class="line"><span class="built_in">console</span>.log(ctw.dataset.chotee); <span class="comment">// another chotee</span></span><br></pre></td></tr></table></figure><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li><code>element.innerHTML</code>属性. 关于用innerHTML在DOM结构中插入新的Script标签,可能达不到预期效果,详情见高程p298</li><li><code>element.outerHTML</code>属性. 连同调用元素(自己)的HTML代码一同返回或设置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">  &lt;p&gt;This is a</span><br><span class="line">    &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt; with a list following it.&lt;/</span>p&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item 2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;input type="button" value="Get OuterHtml" onclick="getOuterHTML()"&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  function getOuterHTML() &#123;</span></span><br><span class="line"><span class="string">    var div = document.getElementById("</span>content<span class="string">");</span></span><br><span class="line"><span class="string">    console.log(div.outerHTML); //works in IE, Safari, and Opera</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 返回结果</span></span><br><span class="line"><span class="string">&lt;div id="</span>content<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;This is a</span></span><br><span class="line"><span class="string">    &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;Item 1&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;Item 2&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;Item 3&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>element.insertAdjacentHTML(description,innerHTML)</code>方法,<code>description</code>有以下几种形式</p></li><li><p><code>beforebegin</code>，作为前一个同辈元素插入； </p></li><li><code>afterbegin</code>，作为第一个子元素插入； </li><li><code>beforeend</code>，作为最后一个子元素插入； </li><li><code>afterend</code>，作为后一个同辈元素插入;</li></ul><blockquote><p>调用本节的方法,有性能问题,原理是用<code>innerHTML</code>将元素移动出DOM结构并没有让该元素的js对象从内存中释放.<br>所以最好减少<code>innerHTML</code>的读写次数,比如先对一个字符串进行反复操作,最后一次性将字符串赋值给<code>innerHTML</code></p></blockquote><h3 id="element-scrollIntoView"><a href="#element-scrollIntoView" class="headerlink" title="element.scrollIntoView()"></a>element.scrollIntoView()</h3><p><code>element.scrollIntoView(true/false)</code></p><blockquote><p>scrollIntoView()可以在所有 HTML 元素上调用, 参数为<code>true</code>或<code>空</code>时,窗口滚动 之后会让调用元素的顶部与视口顶部尽可能平齐<br>参数为<code>false</code>时,调用元素会尽可能全部 出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐<br>为元素设置焦点也会导致浏览器滚动并显示出元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让元素可见 </span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView();</span><br></pre></td></tr></table></figure><h2 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h2><h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><blockquote><p>IE8引入了”文档模式(document mode)”概念, 页面的文档模式决定了可以使用什么js api或css,或怎样对待文档类型doctype<br>要强制浏览器以某种模式渲染页面，可以使用 HTTP 头部信息 X-UA-Compatible，或通过等价的 <code>&lt;meta&gt;</code>标签来设置：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里的IEVersion是被替换掉的不同的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=IEVersion"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体文档模式取值详情查阅高程p289</p><h3 id="element-children属性"><a href="#element-children属性" class="headerlink" title="element.children属性"></a>element.children属性</h3><blockquote><p>这个属性是<code>HTMLCollection</code>实例, 与<code>element.childNodes</code>的区别是只有元素节点.</p></blockquote><h3 id="element-contains"><a href="#element-contains" class="headerlink" title="element.contains()"></a>element.contains()</h3><p><code>element.contains(node) return boolean</code> </p><blockquote><p>如果node是element的后代节点,return true</p></blockquote><h3 id="element-compareDocumentPosition"><a href="#element-compareDocumentPosition" class="headerlink" title="element.compareDocumentPosition()"></a>element.compareDocumentPosition()</h3><p><code>element.compareDocumentPostion(node) return number</code></p><blockquote><p>number 如下定义,由于16的二进制形式是’10000’,与’1,2,4,8’任意一个数字进行<code>按位与</code>操作得到的数字都是0,但与自身<code>按位与</code>得到的数字不是0,所以用<code>!!(number &amp; 16)</code>可以获得与<code>element.contains()</code>方法一样的真值.</p></blockquote><table><thead><tr><th>number</th><th>node相对于element的节点关系</th></tr></thead><tbody><tr><td>1</td><td>无关</td></tr><tr><td>2</td><td>居前</td></tr><tr><td>4</td><td>居后</td></tr><tr><td>8</td><td>包含</td></tr><tr><td>16</td><td>被包含</td></tr></tbody></table><blockquote><p>所以得到一个兼容函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">refNode, otherNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> refNode.contains == <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">    (!client.engine.webkit || client.engine.webkit &gt;= <span class="number">522</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> refNode.contains(otherNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> refNode.compareDocumentPosition == <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(refNode.compareDocumentPosition(otherNode) &amp; <span class="number">16</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = otherNode.parentNode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node === refNode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = node.parentNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><ul><li><code>element.innerText</code>属性.</li></ul><blockquote><p>读取时由浅入深,将文档树的文本拼接,在写入时,删除所有子节点,插入包含相应文本值的文本节点,只会生成一个文本节点<br>设置<code>innerText</code>属性时会对HTML语法字符(小于号,大于号,引号,句号)进行编码</p></blockquote><ul><li><code>element.textContent</code>属性</li></ul><blockquote><p>与innerText的区别是,<code>textContent</code>会返回行内样式和脚本的代码,不过也不一定,浏览器不统一</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) ? </span><br><span class="line">        element.textContent : element.innerText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element, text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>)&#123;</span><br><span class="line">        element.textContent = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element.innerText = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>element.outerText</code>属性,不建议使用<blockquote><p>读取时与innerText返回值相同,写入时用文本节点替换掉调用它的元素节点(自己)</p></blockquote></li></ul><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul><li><code>element.scrollIntoViewIfNeeded(boolean)</code>：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的 <code>boolean</code> 参数设置为 true，则表示尽量将元素显示在视口中部（垂直方向）。Safari 和 Chrome 实现了这个方法。 </li><li><code>element.scrollByLines(lineCount)</code>：将元素的内容滚动指定的行高，lineCount 值可以是正值，也可以是负值。Safari 和 Chrome 实现了这个方法。 </li><li><code>element.scrollByPages(pageCount)</code>：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari 和 Chrome 实现了这个方法。</li></ul><blockquote><p>希望大家要注意的是，<code>scrollIntoView()</code>和 <code>scrollIntoViewIfNeeded()</code>的作用对象是元素的 容器，而 <code>scrollByLines()</code>和 <code>scrollByPages()</code>影响的则是元素自身<br>由于 <code>element.scrollIntoView()</code>是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用</p></blockquote><p>``` js<br>//在当前元素不可见的时候，让它进入浏览器的视口<br>document.images[0].scrollIntoViewIfNeeded();</p><p>//将页面主体往回滚动 1 页<br>document.body.scrollByPages(-1);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择符API&quot;&gt;&lt;a href=&quot;#选择符API&quot; class=&quot;headerlink&quot; title=&quot;选择符API&quot;&gt;&lt;/a&gt;选择符API&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;document/element.querySelector() return no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》DOM 1级</title>
    <link href="http://yoursite.com/2017/12/22/%E9%AB%98%E7%A8%8Bvol5-10%E7%AB%A0-dom1/"/>
    <id>http://yoursite.com/2017/12/22/高程vol5-10章-dom1/</id>
    <published>2017-12-21T20:50:41.000Z</published>
    <updated>2017-12-21T21:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要讨论<code>DOM 1级规范</code></p><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><blockquote><p>javascript中所有的节点都继承自<code>Node</code>类型,因此所有节点类型都共享着相同的基本属性和方法</p><p>节点类型由在Node类型中定义的12个数值常量来表示,任何节点类型必居其一</p></blockquote><ul><li>Node.ELEMENT_NODE(1)； //元素节点,1</li><li>Node.ATTRIBUTE_NODE(2)； //特性节点,2</li><li>Node.TEXT_NODE(3)； //文本节点3</li><li>Node.CDATA_SECTION_NODE(4)；</li><li>Node.ENTITY_REFERENCE_NODE(5)； </li><li>Node.ENTITY_NODE(6)； </li><li>Node.PROCESSING_INSTRUCTION_NODE(7)； </li><li>Node.COMMENT_NODE(8)；</li><li>Node.DOCUMENT_NODE(9)； </li><li>Node.DOCUMENT_TYPE_NODE(10)； </li><li>Node.DOCUMENT_FRAGMENT_NODE(11)； </li><li>Node.NOTATION_NODE(12)。</li></ul><h3 id="node-nodeType-node-nodeName-node-nodeValue"><a href="#node-nodeType-node-nodeName-node-nodeValue" class="headerlink" title="node.nodeType,node.nodeName,node.nodeValue"></a>node.nodeType,node.nodeName,node.nodeValue</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE的节点是COM实现的,所以在IE中无效</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE) &#123;</span><br><span class="line">  alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123; </span><br><span class="line">  <span class="comment">//适用于所有浏览器 alert("Node is an element."); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>nodeType</th><th>nodeName</th><th>nodeValue</th></tr></thead><tbody><tr><td>element</td><td>1</td><td>标签名</td><td>null</td></tr><tr><td>attribute</td><td>2</td><td>特性名</td><td>特性值</td></tr><tr><td>text</td><td>3</td><td>#text</td><td>文本值</td></tr></tbody></table><h3 id="node-childNodes属性-NodeList对象"><a href="#node-childNodes属性-NodeList对象" class="headerlink" title="node.childNodes属性,NodeList对象"></a>node.childNodes属性,NodeList对象</h3><p><img src="https://i.loli.net/2017/12/22/5a3c1e6eacf0d.jpg" alt=""></p><blockquote><p>每个节点都有一个<code>childNodes</code>属性,其中保存着一个<code>NodeList</code>对象,对象里面装着node的子节点, <code>NodeList</code>是伪数组,用于保存一组有序节点,可以通过为止来访问这些节点,有<code>length</code>属性.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以通过方括号,或item()方法访问childNodes中保存的NodeList对象(伪数组)</span></span><br><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将NodeList转化为数组</span></span><br><span class="line"><span class="keyword">var</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//IE浏览器将NodeList(IE中是一个COM对象)转化为数组</span></span><br><span class="line"><span class="comment">//导致错误后手动转化数组,怪癖检测</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    array = <span class="built_in">Array</span>.prototype.slice.call(nodes, <span class="number">0</span>); <span class="comment">//针对非 IE 浏览器 </span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      array.push(nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="node-parentNode属性"><a href="#node-parentNode属性" class="headerlink" title="node.parentNode属性"></a>node.parentNode属性</h3><blockquote><p>指向父节点,一个childNodes列表中的所有节点都有相同的父节点</p></blockquote><h3 id="node-previousSibling-node-nextSibling"><a href="#node-previousSibling-node-nextSibling" class="headerlink" title="node.previousSibling,node.nextSibling"></a>node.previousSibling,node.nextSibling</h3><blockquote><p>childNodes列表中的每个节点相互之间是同胞节点,列表第一个节点的previousSibling和列表最后一个节点的nextSibling的值是null</p></blockquote><h3 id="node-firstChild-node-lastChild"><a href="#node-firstChild-node-lastChild" class="headerlink" title="node.firstChild,node.lastChild"></a>node.firstChild,node.lastChild</h3><blockquote><p>分别指向childNodes列表的第一个子节点和最后一个子节点,没有则为null</p></blockquote><h3 id="node-hasChildNodes"><a href="#node-hasChildNodes" class="headerlink" title="node.hasChildNodes()"></a>node.hasChildNodes()</h3><p><code>node.hasChildNodes() return boolean</code></p><blockquote><p>此方法在node包含1到多个子节点的情况下返回true</p></blockquote><h3 id="node-ownerDocument属性"><a href="#node-ownerDocument属性" class="headerlink" title="node.ownerDocument属性"></a>node.ownerDocument属性</h3><blockquote><p>该属性指向node所在文档的文档节点<code>&lt;html&gt;</code></p></blockquote><h3 id="node-appendChild"><a href="#node-appendChild" class="headerlink" title="node.appendChild()"></a>node.appendChild()</h3><p><code>node.appendChild(node1),return node1</code></p><blockquote><p>在node节点的childNodes列表最后增加一个节点node1,并返回node1<br>若node1已经是文档的一部分了,则变为剪切</p></blockquote><h3 id="node-insertBefore"><a href="#node-insertBefore" class="headerlink" title="node.insertBefore()"></a>node.insertBefore()</h3><p><code>node.insertBefore(node1[,node2]) return node1</code></p><blockquote><p>将node1插入到node的childNodes子节点列表的node2之前,作为node2的previousSibiling,若node2为null,则和appendChild()执行同样操作,插入到childNodes尾部</p></blockquote><h3 id="node-replaceChild"><a href="#node-replaceChild" class="headerlink" title="node.replaceChild()"></a>node.replaceChild()</h3><p><code>node.replaceChild(node1,node2) return node2</code></p><blockquote><p>将node1放入到node的childNotes列表中的note2处替换掉node2,将node2返回</p></blockquote><h3 id="node-removeChild"><a href="#node-removeChild" class="headerlink" title="node.removeChild()"></a>node.removeChild()</h3><p><code>node.removeChild(node1) return node1</code></p><blockquote><p>将node1从node的childNotes列表中移除,并返回</p></blockquote><h3 id="node-cloneNode"><a href="#node-cloneNode" class="headerlink" title="node.cloneNode()"></a>node.cloneNode()</h3><p><code>node.cloneNode(boolean) return nodeCopy</code></p><blockquote><p>复制node节点,并返回复制的节点副本<br>boolean为true深复制(复制节点以及整个子节点树),为false浅复制(只复制节点本身),复制后返回的节点副本没有被插入文档,需手动将其插入文档某个位置<br>不复制事件,只复制特性</p></blockquote><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><blockquote><p>JavaScript 通过 Document 类型表示文档.<br>document 对象是 HTMLDocument（继承 自 Document 类型）的一个实例，表示整个 HTML 页面。<br>document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问</p></blockquote><h3 id="document对象的基本属性"><a href="#document对象的基本属性" class="headerlink" title="document对象的基本属性"></a>document对象的基本属性</h3><ul><li><code>nodeType</code> : 9</li><li><code>nodeName</code> : #document</li><li><code>nodeValue</code> : null</li><li><code>parentNode</code> : null</li><li><code>ownerDocument</code> : null</li><li><code>documentElement</code> : <code>&lt;html&gt;</code></li><li><code>body</code> : <code>&lt;body&gt;</code></li><li><code>childNodes</code>列表 : 包含<html>的子节点列表</html></li><li><code>doctype</code>: DocumentType_NODE(10)类型,就是&lt;!DOCTYPE&gt;</li><li>（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment</li></ul><h3 id="document-documentElement属性"><a href="#document-documentElement属性" class="headerlink" title="document.documentElement属性"></a>document.documentElement属性</h3><blockquote><p>该属性指向<html>元素</html></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">//取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="document-body"><a href="#document-body" class="headerlink" title="document.body"></a>document.body</h3><blockquote><p>该属性指向<code>&lt;body&gt;</code>元素</p></blockquote><h3 id="document-doctype"><a href="#document-doctype" class="headerlink" title="document.doctype"></a>document.doctype</h3><blockquote><p>DocumentType_NODE(10)类型<br>该属性指向<code>&lt;!DOCTYPE&gt;</code></p></blockquote><h3 id="document-title"><a href="#document-title" class="headerlink" title="document.title"></a>document.title</h3><blockquote><p>当前页面标题,修改会反应在浏览器标题栏中</p></blockquote><h3 id="document-URL-document-domain-document-referrer"><a href="#document-URL-document-domain-document-referrer" class="headerlink" title="document.URL,document.domain,document.referrer"></a>document.URL,document.domain,document.referrer</h3><blockquote><p>URL属性包含页面完整URL ‘<a href="http://www.wrox.com/WileyCDA/" target="_blank" rel="external">http://www.wrox.com/WileyCDA/</a>‘<br>domain只包含页面的域名 ‘www.wrox.com’<br>referrer保存链接到当前页面的那个页面URL,若无来源,可能是空字符串<br>这三个信息都存在于HTTP请求的头部,只不过这些属性让我们可以用js访问它们</p></blockquote><h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h3><p><code>document.getElementsByTagName() return HTMLCollection</code></p><blockquote><p>HTMLCollection对象是一个动态集合,与NodeList非常类似,可以用<code>.item(index)</code>方法来访问其中的项, 有<code>length</code>属性<br>HTMLCollection有<code>.namedItem()</code>方法,使用这个方法可以通过元素<code>name</code>特性取得集合中的项<br>对有<code>name</code>特性的项,可以用方括号语法访问,与下例<code>.namedItem()</code>作用相同.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;img src="myimage.gif" name="myImage"&gt;</span></span><br><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line">alert(images.length);</span><br><span class="line">alert(images[<span class="number">0</span>].src);</span><br><span class="line">alert(images.item(<span class="number">0</span>).src);</span><br><span class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>]; <span class="comment">//返回与下一行一样的结果</span></span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>); <span class="comment">// 返回与上一行一样的结果</span></span><br><span class="line"><span class="keyword">var</span> allElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);<span class="comment">//返回页面所有元素</span></span><br></pre></td></tr></table></figure><p>对 <code>HTMLCollection</code> 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 <code>item()</code>，而对字符串索引就会调用 <code>namedItem()</code>。</p><h3 id="document-getElementsbyName"><a href="#document-getElementsbyName" class="headerlink" title="document.getElementsbyName()"></a>document.getElementsbyName()</h3><p><code>document.getElementsbyName() return HTMLCollection</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorRed"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorRed"</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"green"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorGreen"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorGreen"</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"blue"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorBlue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorBlue"</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下述代码只能选中被选中的input单选框</span></span><br><span class="line"><span class="comment">// 因为返回的HTMLCollection调用了.namedItem('color'),只会选择第一项</span></span><br><span class="line"><span class="comment">// 因为每项name特性都相同</span></span><br><span class="line"><span class="built_in">document</span>.getElementsbyName(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure><h3 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h3><ul><li><code>document.anchors</code>，包含文档中所有带 name 特性的<code>&lt;a&gt;</code>元素； </li><li><code>document.forms</code>，包含文档中所有的<code>&lt;form&gt;</code>元素，与 document.getElementsByTagName(“form”) 得到的结果相同； </li><li><code>document.images</code>，包含文档中所有的<code>&lt;img&gt;</code>元素，与 document.getElementsByTagName (“img”)得到的结果相同； </li><li><code>document.links</code>，包含文档中所有带 href 特性的<code>&lt;a&gt;</code>元素。</li></ul><h3 id="其他简单方法"><a href="#其他简单方法" class="headerlink" title="其他简单方法"></a>其他简单方法</h3><ul><li><code>document.getElementbyId()</code></li><li><code>document.write()</code> 重写文档内容</li><li><code>document.writeln()</code> 重写文档内容,结尾加’\n’</li><li><code>document.open()</code> 打开文档输出流</li><li><code>document.close()</code> 关闭文档输出流</li></ul><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ul><li><code>nodeType</code> : 1</li><li><code>nodeName</code> : 标签名</li><li><code>nodeValue</code> : null</li><li><code>nodeName</code> : <code>tagName</code></li><li><code>tagName</code> : <code>nodeName</code></li></ul><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><blockquote><p>所有 HTML 元素都由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。</p></blockquote><h3 id="HTML元素-基本属性"><a href="#HTML元素-基本属性" class="headerlink" title="HTML元素 基本属性"></a>HTML元素 基本属性</h3><ul><li><code>id</code></li><li><code>title</code> : 附加信息说明,工具条提示</li><li><code>lang</code> : 语言编码,很少使用</li><li><code>dir</code> : 语言方向,值为<code>ltr</code>,<code>rtl</code>(left to right, right to left)</li><li><code>className</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">alert(div.id); <span class="comment">//"myDiv"" </span></span><br><span class="line">alert(div.className); <span class="comment">//"bd" </span></span><br><span class="line">alert(div.title); <span class="comment">//"Body text" </span></span><br><span class="line">alert(div.lang); <span class="comment">//"en" </span></span><br><span class="line">alert(div.dir); <span class="comment">//"ltr"</span></span><br></pre></td></tr></table></figure><h3 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h3><blockquote><p>注意:若要获得class值,attr位置应该是<code>class</code>,而不是<code>className</code><br>根据HTML5规范,自定义特性应该加上<code>data</code>前缀,以便验证<br>两类用getAttribute获取达不到预期的特性:<code>style</code>* 和<code>onclick等事件</code><br>setAttribute设置的特姓名会转为小写</p></blockquote><ul><li><code>htmlElement.getAttribute(attr) return string</code> </li><li><code>htmlElement.setAttribute(attr,value)</code> </li><li><code>htmlElement.removeAttribute(attr)</code></li></ul><p>不过，像下面这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.mycolor = <span class="string">"red"</span>; </span><br><span class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">//null（IE 除外）</span></span><br></pre></td></tr></table></figure><h3 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h3><p>Element 类型是使用 <code>attributes</code> 属性的唯一一个 DOM 节点类型。<code>attributes</code> 属性中包含一个<code>NamedNodeMap</code>，与 <code>NodeList</code> 类似，也是一个“动态”的集合。元素的每一个特性都由一个 <code>Attr 节点</code>表示，每个节点都保存在 <code>NamedNodeMap</code> 对象中。<code>NamedNodeMap</code> 对象拥有下列方法。</p><ul><li><code>getNamedItem(name) return nodeName</code>：返回 <code>nodeName</code> 属性等于 <code>name</code> 的节点； </li><li><code>removeNamedItem(name)</code>：从列表中移除 <code>nodeName</code> 属性等于 <code>name</code> 的节点； </li><li><code>setNamedItem(node)</code>：向列表中添加节点，以节点的 <code>nodeName</code> 属性为索引； </li><li><code>item(pos)</code>：返回位于数字 pos 位置处的节点。</li></ul><blockquote><p>看一些例子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于var id = element.id</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">"id"</span>].nodeValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于element.id = 'someOtherId'</span></span><br><span class="line">element.attributes[<span class="string">"id"</span>].nodeValue = <span class="string">"someOtherId"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldAttr = element.attributes.removeNamedItem(<span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setNamedItem极其没用</span></span><br><span class="line">element.attributes.setNamedItem(newAttrNode);</span><br></pre></td></tr></table></figure><h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><p><code>document.createElement(tagName) return HTMLElement</code></p><blockquote><p>创建元素的同时,也为元素设置了ownerDocument属性<br>返回的HTMLElenment未添加入文档树,需要手动添加</p></blockquote><h3 id="HTMLElement-getElementsByTagName"><a href="#HTMLElement-getElementsByTagName" class="headerlink" title="HTMLElement.getElementsByTagName()"></a>HTMLElement.getElementsByTagName()</h3><blockquote><p>像Document一样,HTMLElement同样支持此方法</p></blockquote><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><h3 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h3><ul><li><code>nodeType</code> : 3</li><li><code>nodeName</code> : “#text”</li><li><code>nodeValue</code> : 节点所包含文本</li><li><code>parentNode</code> : 一个Element</li><li>没有子节点</li><li><code>data</code> : == <code>nodeValue</code></li><li><code>appendData(text)</code>：将 text 添加到节点的末尾。</li><li><code>deleteData(offset, count)</code>：从 offset 指定的位置开始删除 count 个字符。</li><li><code>insertData(offset, text)</code>：在 offset 指定的位置插入 text。</li><li><code>replaceData(offset, count, text)</code>：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。</li><li><code>splitText(offset)</code>：从 offset 指定的位置将当前文本节点分成两个文本节点。</li><li><code>substringData(offset, count)</code>：提取从 offset 指定的位置开始到 offset+count 为止 处的字符串。</li><li><code>length</code>: nodeValue.length 或 data.length中也保存着同样的值</li></ul><blockquote><p>用js修改文本节点的值后,其会经过html或xml编码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message" </span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</span><br></pre></td></tr></table></figure><h3 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h3><p><code>document.createTextNode() return textNode</code> </p><blockquote><p>创建文本节点,要经过html编码,未插入文档,需要手动插入</p></blockquote><h3 id="node-normalize"><a href="#node-normalize" class="headerlink" title="node.normalize()"></a>node.normalize()</h3><blockquote><p>这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点<br>结果节点的 nodeValue 等于将合并前每个文本节点的 nodeValue 值拼接起来的值。</p></blockquote><h3 id="textNode-splitText"><a href="#textNode-splitText" class="headerlink" title="textNode.splitText()"></a>textNode.splitText()</h3><p><code>textNode.splitText(startPos) return nodeElement</code></p><blockquote><p>Text 类型提供了一个作用与 normalize()相反的方法：splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。<br>经过splitText处理的文本节点, 分离后的两个文本节点都将留在html结构中.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.firstChild.nodeValue);  <span class="comment">//"Hello"</span></span><br><span class="line">alert(newNode.nodeValue);             <span class="comment">//"world!"</span></span><br><span class="line">alert(element.childNodes.length);     <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><ul><li><code>nodeType</code> : 8</li><li><code>nodeName</code> : “#comment”</li><li><code>nodeValue</code> : 注释内容</li><li><code>parentNode</code> : 可能是Document或Element</li><li>没有子节点</li><li><code>data</code> : == <code>nodeValue</code></li><li><code>appendData(text)</code>：将 text 添加到节点的末尾。</li><li><code>deleteData(offset, count)</code>：从 offset 指定的位置开始删除 count 个字符。</li><li><code>insertData(offset, text)</code>：在 offset 指定的位置插入 text。</li><li><code>replaceData(offset, count, text)</code>：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。</li><li><code>splitText(offset)</code>：从 offset 指定的位置将当前文本节点分成两个文本节点。</li><li><code>substringData(offset, count)</code>：提取从 offset 指定的位置开始到 offset+count 为止 处的字符串。</li><li><code>length</code>: nodeValue.length 或 data.length中也保存着同样的值</li></ul><blockquote><p>与Text类型继承自同样的基类,拥有除splitText()外所有字符换操作方法. 与Text类型类似, 也可以通过nodeValue或data属性来取得注释内容</p></blockquote><ul><li><code>document.createComment(commentContent) return commentNode</code> 创建注释节点</li></ul><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><p>只针对XML文档,详情见高程P274</p><h3 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h3><p>这个对象保存在document.doctype中,只有一个name属性保存文档类型的名称(‘html’),详情见高程p274</p><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>相当于一个后备”仓库”,用来存放将来可能会用到的节点,避免浏览器反复渲染,用的不多,详情见高程p275</p><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>特性节点,但不建议用里面的api,使用getAttribute,setAttribute,removeAttribute远比其方便,详情见高程p276</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><blockquote><p>指页面加载时不存在,需要时再加载入html结构的script</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url外部引入方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  script.src = url</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递代码字符串,行内执行方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  script.appendChild(<span class="built_in">document</span>.createTextNode(code))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码会在IE中报错,原因是IE不允许DOM访问script标签的子节点,<br>解决办法是使用<code>script</code>元素的<code>text</code>属性来指定代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.text = <span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>综合上述,得到向下兼容IE7的代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        script.text = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadScriptString(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>);</span><br><span class="line">    sayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><blockquote><p>link标签最佳实践是放在head标签内,让html结构没加载时就开始加载css.若放在body标签内,可能会出现本来没样式的结构突然又有了样式的”闪屏”</p><p>动态样式基本套路和动态脚本一样,直接上代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span><br><span class="line">  link.rel=<span class="string">"stylesheet"</span></span><br><span class="line">  link.type=<span class="string">'css'</span></span><br><span class="line">  link.href=url</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(link)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解决IE的问题是访问元素的styleSheet属性的属性cssText,其接受css代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">    style.type = <span class="string">"text/css"</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">        style.styleSheet.cssText = css;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadStyleString(<span class="string">"body&#123;background-color:red&#125;"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><blockquote><p>js为表格操作添加了一些api</p></blockquote><ul><li><code>&lt;table&gt;</code><ul><li>caption：保存着对<caption>元素（如果有）的指针。 </caption></li><li>tBodies：是一个<tbody>元素的 HTMLCollection。 </tbody></li><li>tFoot：保存着对<tfoot>元素（如果有）的指针。 </tfoot></li><li>tHead：保存着对<thead>元素（如果有）的指针。 </thead></li><li>rows：是一个表格中所有行的 HTMLCollection。 </li><li>createTHead()：创建<thead>元素，将其放到表格中，返回引用。 </thead></li><li>createTFoot()：创建<tfoot>元素，将其放到表格中，返回引用。 </tfoot></li><li>createCaption()：创建<caption>元素，将其放到表格中，返回引用。 </caption></li><li>deleteTHead()：删除<thead>元素。 </thead></li><li>deleteTFoot()：删除<tfoot>元素。 </tfoot></li><li>deleteCaption()：删除<caption>元素。 </caption></li><li>deleteRow(pos)：删除指定位置的行。 </li><li>insertRow(pos)：向 rows 集合中的指定位置插入一行。 </li></ul></li><li><code>&lt;tbody&gt;</code><ul><li>rows：保存着<tbody>元素中行的 HTMLCollection。 </tbody></li><li>deleteRow(pos)：删除指定位置的行。 </li><li>insertRow(pos)：向 rows 集合中的指定位置插入一行，返回对新插入行的引用。   </li></ul></li><li><code>&lt;tr&gt;</code><ul><li>cells：保存着<tr>元素中单元格的 HTMLCollection。 </tr></li><li>deleteCell(pos)：删除指定位置的单元格。</li><li>insertCell(pos)：向 cells 集合中的指定位置插入一个单元格，返回对新插入单元格的引用。</li></ul></li></ul><h3 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h3><blockquote><p>NodeList及其近亲NamedNodeMap和HTMLCollection都是动态的,每当文档结构发生变化,它们都会得到更新</p></blockquote><p>看一个无限循环的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>), i, div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; divs.length; i++)&#123; </span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>), i, len, div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=divs.length; i &lt; len; i++)&#123; </span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章主要讨论&lt;code&gt;DOM 1级规范&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;&gt;&lt;/a&gt;节点层次&lt;/h2&gt;&lt;h2 id=&quot;Node类型&quot;&gt;&lt;a href=&quot;#Node
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》BOM &amp; 客户端检测</title>
    <link href="http://yoursite.com/2017/12/21/%E9%AB%98%E7%A8%8Bvol4-89%E7%AB%A0-bom-ua/"/>
    <id>http://yoursite.com/2017/12/21/高程vol4-89章-bom-ua/</id>
    <published>2017-12-21T03:56:09.000Z</published>
    <updated>2017-12-21T03:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BOM-第八章"><a href="#BOM-第八章" class="headerlink" title="BOM(第八章)"></a>BOM(第八章)</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>全局变量不能通过<code>delete</code>操作符删除([[Configurable]]为false),而<code>window</code>对象上的属性可以</p><p><code>location</code>与<code>naviagator</code>是<code>window</code>的属性</p><h3 id="窗口关系与框架"><a href="#窗口关系与框架" class="headerlink" title="窗口关系与框架"></a>窗口关系与框架</h3><p>涉及<code>framset</code>,<code>frame</code>标签,和<code>window</code>对象中的<code>window.top</code>,<code>window.parent</code>等,用的不多,需要用时查阅p194</p><h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><blockquote><p>不同浏览器情况杂乱特殊,建议使用时查阅高程p197<br>表示窗口相对于屏幕左边和上边的位置,但下述值所表达的位置基点有小差异,具体参阅高程p197</p></blockquote><ul><li><code>window.screenLeft</code>,<code>window.screenTop</code> IE,Safari,Opera,Chrome</li><li><code>window.screenX</code>,<code>window.screenY</code>, FireFox,Safari,Chrome</li></ul><p>兼容代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ? </span><br><span class="line">                  <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ? </span><br><span class="line">                  <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"Left: "</span> + leftPos);</span><br><span class="line">alert(<span class="string">"Top: "</span> + topPos);</span><br></pre></td></tr></table></figure></p><h4 id="window-moveTo-window-moveBy"><a href="#window-moveTo-window-moveBy" class="headerlink" title="window.moveTo(),window.moveBy()"></a>window.moveTo(),window.moveBy()</h4><blockquote><p>这两个方法不适用于框架,且只对最外层(frameset那节的概念)的window对象使用</p></blockquote><p><code>window.moveTo(newLeftPos,newTopPos),window.moveBy(leftMove,TopMove)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角 </span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将窗向下移动 100 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将窗口移动到(200,300) </span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将窗口向左移动 50 像素 </span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><blockquote><p>不同浏览器情况杂乱特殊,建议使用时查阅高程p198</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得可视区域大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClient</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width: <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth || <span class="number">0</span>,</span><br><span class="line">    height: <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者版本</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"Width: "</span> + pageWidth);</span><br><span class="line">alert(<span class="string">"Height: "</span> + pageHeight);</span><br></pre></td></tr></table></figure><h4 id="window-resizeTo-window-resizeBy"><a href="#window-resizeTo-window-resizeBy" class="headerlink" title="window.resizeTo(),window.resizeBy()"></a>window.resizeTo(),window.resizeBy()</h4><blockquote><p>这两个方法同样不适用于框架，而只能对最外层的 window 对象使用。</p></blockquote><p><code>window.resizeTo(newWidth,newHeight)</code>,<code>window.resizeBy(modifyWidth,modifyHeight)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整到 100×100 </span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整到 200×150 </span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整到 300×300 </span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open()"></a>window.open()</h4><p><code>window.open(url[,windowTarget,propString,boolean]),return newWindowObj</code></p><ul><li><code>windowTarget</code> 已有窗口或框架的名称,或特殊窗口名称<code>_self,_parent,_top,_blank</code></li><li><code>propString</code> 若windowTarget不是一个已存在窗口或框架,会根据propString打开一个新窗口或标签页.若没有第三个参数,会打开默认设置(各种栏)的新浏览器窗口或标签页,不打开新窗口时会忽略第三个参数<br><img src="https://i.loli.net/2017/12/21/5a3b3061a28de.jpg" alt=""></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等同于&lt; a href="http://www.wrox.com" target="topFrame"&gt;&lt;/a&gt; </span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"topFrame"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个新的可以调整大小的窗口，窗口初始大小为 400×400 像素，并且距屏幕上沿 和左边各 10 像素</span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>, <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br></pre></td></tr></table></figure><p>window.open()返回一个指向新窗口的引用,可以调整大小或移动位置(主浏览器窗口不被允许),也可以像操作其他窗口一样操作新打开的窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>, <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整大小 </span></span><br><span class="line">wroxWin.resizeTo(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动位置 </span></span><br><span class="line">wroxWin.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 close()方法关闭窗口。</span></span><br><span class="line">wroxWin.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭后,wroxWin的引用依然存在,可以检测其close属性</span></span><br><span class="line">alert(wroxWin.closed);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层 window 对象（top）中有定义，而且指向调用 window.open()的窗口或框架。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>, <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line"></span><br><span class="line">alert(wroxWin.opener == <span class="built_in">window</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在chrome中,将opner属性设置为null,即表示单独进程中运行新标签页(无法与打开它的window对象进行通信)</span></span><br><span class="line"><span class="comment">// 标签页之间联系一旦被切断, 没有办法恢复</span></span><br><span class="line"><span class="comment">// wroxWin.opener = null;</span></span><br></pre></td></tr></table></figure><h3 id="setTimeout-与-setInterval"><a href="#setTimeout-与-setInterval" class="headerlink" title="setTimeout() 与 setInterval"></a>setTimeout() 与 setInterval</h3><blockquote><p>time参数代表的时隔多少秒后将要执行的string或function放入js任务队列<br>function内部的this在非严格模式下指向<code>window</code>,严格模式<code>undefined</code><br>在开发中尽量使用setTimeout模拟setInterval,这是最佳实践,原因是setInterval的后一个interval有可能先于前一个Interval完成</p></blockquote><p><code>setTimeout(string/function,time),return id</code><br><code>clearTimeout(id)</code></p><p><code>setInterval(string/function,time) return id</code><br><code>clearInterval(id)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout 模拟 setInterval, 最佳实践</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the max has not been reached, set another timeout</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><h2 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h2><blockquote><p>系统对话框都是同步和模态的: 显示对话框时代码停止,关掉对话框时代码执行</p></blockquote><h4 id="alert"><a href="#alert" class="headerlink" title="alert()"></a>alert()</h4><h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a>confirm()</h4><p><code>confirm(…) return boolean</code></p><h4 id="promopt"><a href="#promopt" class="headerlink" title="promopt()"></a>promopt()</h4><p><code>prompt(hint,placeholder) return inputValue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = prompt(<span class="string">"What is your name? "</span>, <span class="string">""</span>); </span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123; </span><br><span class="line">    alert(<span class="string">"Welcome, "</span> + result); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="window-print-window-find"><a href="#window-print-window-find" class="headerlink" title="window.print(),window.find()"></a>window.print(),window.find()</h4><p>显示打印对话框,显示查找对话框</p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>既是window的属性,又是document的属性,<code>window.loacation === document.location //true</code>,</p><h3 id="location属性"><a href="#location属性" class="headerlink" title="location属性"></a>location属性</h3><p><img src="https://i.loli.net/2017/12/21/5a3b3061f2634.jpg" alt=""></p><ul><li><code>location.hash</code> ‘#contents’</li><li><code>location.host</code> ‘www.wrox.com:80’</li><li><code>location.hostname</code> ‘www.wrox.com’</li><li><code>location.protocol</code> ‘http:’</li><li><code>location.port</code> ’80’</li><li><code>location.href</code> ‘<a href="http://www.wrox.com/?q=javascripts&amp;qq=qq&amp;qqq=qqq" target="_blank" rel="external">http://www.wrox.com/?q=javascripts&amp;qq=qq&amp;qqq=qqq</a>‘ == location.toString()</li><li><code>location.pathname</code> ‘/path’</li><li><code>location.search</code> ‘?q=javascripts&amp;qq=qq&amp;qqq=qqq’</li></ul><h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get query string without the initial ?</span></span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//object to hold data</span></span><br><span class="line">    args = &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get individual items</span></span><br><span class="line">    items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">    item = <span class="literal">null</span>,</span><br><span class="line">    name = <span class="literal">null</span>,</span><br><span class="line">    value = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//used in for loop</span></span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    len = items.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//assign each item onto the args object</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">    name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">    value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><h4 id="location-assign-url"><a href="#location-assign-url" class="headerlink" title="location.assign(url)"></a>location.assign(url)</h4><blockquote><p>立刻打开url,并新增一条历史纪录<br>若给location.href或window.location赋值一个url值,也会立刻以该值为参数调用location.assign方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三行代码效果相同</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>; </span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>; <span class="comment">//最常用</span></span><br><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>修改location的其他属性也会立刻改变当前加载页面(<code>hash,search,port,hostname,pathname,port</code>)<br>每次修改location属性(<code>hash</code>除外),页面都会以新url重新加载,生成一个历史记录</p></blockquote><h4 id="location-replace-url"><a href="#location-replace-url" class="headerlink" title="location.replace(url)"></a>location.replace(url)</h4><p>按url加载页面,<strong>但不生成新的历史纪录</strong></p><h4 id="location-reload-boolean"><a href="#location-reload-boolean" class="headerlink" title="location.reload(boolean)"></a>location.reload(boolean)</h4><blockquote><p>纯刷新,boolean为false或不传boolean,允许从缓存中重载,boolean为true,从服务器重新加载</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p><img src="https://i.loli.net/2017/12/21/5a3b3084465e3.jpg" alt=""><br><img src="https://i.loli.net/2017/12/21/5a3b3062108ee.jpg" alt=""></p><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><p>非IE浏览器通过navigator.plugins数组实现,IE浏览器通过COM对象实现,简单而又有特定套路,详情查阅高程p211</p><h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>html5提供了registerContentHandler()和 registerProtocolHandler() 两个API,为指定mime类型或协议类型指定特定的网站应用程序(web application)作为处理特定资源的默认方式</p><p>简单而又套路,详情查阅高程p213</p><h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><blockquote><p>用处不大, 需要时查阅高程p214</p></blockquote><p>JavaScript 中有几个对象在编程中用处不大，而 screen 对象就是其中之一。screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的 screen 对象都包含着各不相同的属性，下表列出了所有属性及支持相应属性的浏览器。</p><p><img src="https://i.loli.net/2017/12/21/5a3b30843dffe.jpg" alt=""><br><img src="https://i.loli.net/2017/12/21/5a3b306219bdd.jpg" alt=""></p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><blockquote><p>当页面的 URL 改变时，就会生成一条历史记录</p></blockquote><h4 id="history-go"><a href="#history-go" class="headerlink" title="history.go()"></a>history.go()</h4><p><code>history.go( num / string )</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后退一页 </span></span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前进一页 </span></span><br><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前进两页 </span></span><br><span class="line">history.go(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>也可以给 go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置.可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳转到最近的 wrox.com 页面 </span></span><br><span class="line">history.go(<span class="string">"wrox.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到最近的 nczonline.net 页面 </span></span><br><span class="line">history.go(<span class="string">"nczonline.net"</span>);</span><br></pre></td></tr></table></figure><h4 id="history-back-history-foward"><a href="#history-back-history-foward" class="headerlink" title="history.back(),history.foward()"></a>history.back(),history.foward()</h4><p>相当于history.go(-1)和history.go(1)</p><h4 id="history-length"><a href="#history-length" class="headerlink" title="history.length"></a>history.length</h4><blockquote><p>除了上述几个方法外，history 对象还有一个 length 属性，保存着历史记录的数量。这个数量包括所有历史记录即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于 0。通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (history.length == <span class="number">0</span>)&#123; </span><br><span class="line">    <span class="comment">//这应该是用户打开窗口后的第一个页面 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端检测-第九章"><a href="#客户端检测-第九章" class="headerlink" title="客户端检测(第九章)"></a>客户端检测(第九章)</h1><h2 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h2><blockquote><p>基本模式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.propertyInQuestion)&#123; </span><br><span class="line">    <span class="comment">//使用 object.propertyInQuestion </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尽量使用typeof进行能力检测"><a href="#尽量使用typeof进行能力检测" class="headerlink" title="尽量使用typeof进行能力检测"></a>尽量使用typeof进行能力检测</h3><blockquote><p>因为有些需要检测的东西是<code>object</code>而不是<code>function</code>,是前者时虽然能力检测返回true,但调用就会出错.<br>所以用<code>if(typeof xxxx === &quot;function&quot;)</code>,更严谨些<br>但IE会将有些存在的方法用typeof检测后返回字符串<code>unknown</code>,所以这里推荐一个更严谨的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来检测object对象上的property特性是否存在</span></span><br><span class="line"><span class="comment">//作者：Peter Michaux </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHostMethod</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="keyword">typeof</span> object[property];</span><br><span class="line">  <span class="keyword">return</span> t==<span class="string">'function'</span> || (!!(t==<span class="string">'object'</span> &amp;&amp; object[property])) || t==<span class="string">'unknown'</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用能力检测"><a href="#如何使用能力检测" class="headerlink" title="如何使用能力检测"></a>如何使用能力检测</h3><blockquote><p>根据浏览器不同将能力组合起来是更可取的方式。如果你知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是一次性检测所有相关特性，而不要分别检测。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定浏览器是否支持 Netscape 风格的插件 </span></span><br><span class="line"><span class="keyword">var</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定浏览器是否具有 DOM1 级规定的能力 </span></span><br><span class="line"><span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp; <span class="built_in">document</span>.getElementsByTagName);</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来 判断用户使用的是什么浏览器。</p></blockquote><h2 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h2><p>与<code>能力检测</code>确认浏览器支持什么能力不同，<code>怪癖检测</code>是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测内容:IE8或更早版本中存在一个bug:</span></span><br><span class="line"><span class="comment">//是否:与[[Enumerable]]标记为false的某个原型属性同名的属性,无法forin到</span></span><br><span class="line"><span class="keyword">var</span> hasDontEnumQuirk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop == <span class="string">"toString"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测内容: safari 3之前版本的一个bug:</span></span><br><span class="line"><span class="comment">//是否会枚举[[Enumerable]]标记为false的属性</span></span><br><span class="line"><span class="keyword">var</span> hasEnumShadowsQuirk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop == <span class="string">"toString"</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (count &gt; <span class="number">1</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">alert(hasDontEnumQuirk);</span><br><span class="line">alert(hasEnumShadowsQuirk);</span><br></pre></td></tr></table></figure><h2 id="navigator-userAgent-用户代理检测"><a href="#navigator-userAgent-用户代理检测" class="headerlink" title="navigator.userAgent 用户代理检测"></a>navigator.userAgent 用户代理检测</h2><blockquote><p><code>用户代理检测</code>通过检测用户代理字符串来确定实际使用的浏览器,优先级应排在<code>能力检测</code>和<code>怪癖检测</code>之后. 因为<code>navigator.userAgent</code>字符串因为历史原因很混乱,而且还将会混乱下去.<br>。在每一次 HTTP 请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过 JavaScript 的 <code>navigator.userAgent</code> 属性访问<br>确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎,我们要编写的脚本将主要检测五大呈现引擎：IE、Gecko、WebKit、KHTML 和 Opera。<br>检测脚本模型伪代码如下所示:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义模式:</span></span><br><span class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> engine = &#123;</span><br><span class="line">    <span class="comment">//每个引擎属性默认为0,</span></span><br><span class="line">    <span class="comment">//如果检测到了哪个呈现引擎,就以浮点数值形式将该引擎版本号写入相应属性</span></span><br><span class="line">    ie:<span class="number">0</span>,</span><br><span class="line">    gecko:<span class="number">0</span>,</span><br><span class="line">    webkit:<span class="number">0</span>,</span><br><span class="line">    khtml:<span class="number">0</span>,</span><br><span class="line">    opera:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//具体版本号</span></span><br><span class="line">    ver:<span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...检测代码,用来根据检测结果改变engine对象中的属性值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    engine:engine</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用模式:</span></span><br><span class="line"><span class="keyword">if</span>(client.engine.ie)&#123;<span class="comment">//如果是IE,client.ie的值应大于0</span></span><br><span class="line">  <span class="comment">//...针对IE的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(client.engine.gecko&gt;<span class="number">1.5</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(client.engine.ver === <span class="string">"1.8.1"</span>)&#123;</span><br><span class="line">    <span class="comment">//针对某个具体版本执行某些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完善检测代码"><a href="#完善检测代码" class="headerlink" title="完善检测代码"></a>完善检测代码</h3><blockquote><p>检测代码的完善逻辑跟浏览器发展历史进程等有关,不必深入,详情见高程p230-&gt;章节结尾<br>作者给出了完整代码client.js,知道检测机制和调用方式(上述)后,应该直接拿来使用.</p></blockquote><h3 id="client-js"><a href="#client-js" class="headerlink" title="client.js"></a>client.js</h3><blockquote><p>《js高程》中用户代理检测,完整代码,使用方式见上述</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//rendering engines</span></span><br><span class="line">  <span class="keyword">var</span> engine = &#123;</span><br><span class="line">    ie: <span class="number">0</span>,</span><br><span class="line">    gecko: <span class="number">0</span>,</span><br><span class="line">    webkit: <span class="number">0</span>,</span><br><span class="line">    khtml: <span class="number">0</span>,</span><br><span class="line">    opera: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//complete version</span></span><br><span class="line">    ver: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//browsers</span></span><br><span class="line">  <span class="keyword">var</span> browser = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//browsers</span></span><br><span class="line">    ie: <span class="number">0</span>,</span><br><span class="line">    firefox: <span class="number">0</span>,</span><br><span class="line">    safari: <span class="number">0</span>,</span><br><span class="line">    konq: <span class="number">0</span>,</span><br><span class="line">    opera: <span class="number">0</span>,</span><br><span class="line">    chrome: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//specific version</span></span><br><span class="line">    ver: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//platform/device/OS</span></span><br><span class="line">  <span class="keyword">var</span> system = &#123;</span><br><span class="line">    win: <span class="literal">false</span>,</span><br><span class="line">    mac: <span class="literal">false</span>,</span><br><span class="line">    x11: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mobile devices</span></span><br><span class="line">    iphone: <span class="literal">false</span>,</span><br><span class="line">    ipod: <span class="literal">false</span>,</span><br><span class="line">    ipad: <span class="literal">false</span>,</span><br><span class="line">    ios: <span class="literal">false</span>,</span><br><span class="line">    android: <span class="literal">false</span>,</span><br><span class="line">    nokiaN: <span class="literal">false</span>,</span><br><span class="line">    winMobile: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//game systems</span></span><br><span class="line">    wii: <span class="literal">false</span>,</span><br><span class="line">    ps: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//detect rendering engines/browsers</span></span><br><span class="line">  <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.opera) &#123;</span><br><span class="line">    engine.ver = browser.ver = <span class="built_in">window</span>.opera.version();</span><br><span class="line">    engine.opera = browser.opera = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">    engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//figure out if it's Chrome or Safari</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Chrome\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">      browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">      browser.chrome = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Version\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">      browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">      browser.safari = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//approximate version</span></span><br><span class="line">      <span class="keyword">var</span> safariVersion = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (engine.webkit &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        safariVersion = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">312</span>) &#123;</span><br><span class="line">        safariVersion = <span class="number">1.2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">412</span>) &#123;</span><br><span class="line">        safariVersion = <span class="number">1.3</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safariVersion = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      browser.safari = browser.ver = safariVersion;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">    engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">    engine.khtml = browser.konq = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua)) &#123;</span><br><span class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">    engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//determine if it's Firefox</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Firefox\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">      browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">      browser.firefox = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">    engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">    engine.ie = browser.ie = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//detect browsers</span></span><br><span class="line">  browser.ie = engine.ie;</span><br><span class="line">  browser.opera = engine.opera;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//detect platform</span></span><br><span class="line">  <span class="keyword">var</span> p = navigator.platform;</span><br><span class="line">  system.win = p.indexOf(<span class="string">"Win"</span>) == <span class="number">0</span>;</span><br><span class="line">  system.mac = p.indexOf(<span class="string">"Mac"</span>) == <span class="number">0</span>;</span><br><span class="line">  system.x11 = (p == <span class="string">"X11"</span>) || (p.indexOf(<span class="string">"Linux"</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//detect windows operating systems</span></span><br><span class="line">  <span class="keyword">if</span> (system.win) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/</span>.test(ua)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"NT"</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">RegExp</span>[<span class="string">"$2"</span>]) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"5.0"</span>:</span><br><span class="line">            system.win = <span class="string">"2000"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"5.1"</span>:</span><br><span class="line">            system.win = <span class="string">"XP"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"6.0"</span>:</span><br><span class="line">            system.win = <span class="string">"Vista"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">"6.1"</span>:</span><br><span class="line">            system.win = <span class="string">"7"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            system.win = <span class="string">"NT"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"9x"</span>) &#123;</span><br><span class="line">        system.win = <span class="string">"ME"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        system.win = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//mobile devices</span></span><br><span class="line">  system.iphone = ua.indexOf(<span class="string">"iPhone"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">  system.ipod = ua.indexOf(<span class="string">"iPod"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">  system.ipad = ua.indexOf(<span class="string">"iPad"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">  system.nokiaN = ua.indexOf(<span class="string">"NokiaN"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//windows mobile</span></span><br><span class="line">  <span class="keyword">if</span> (system.win == <span class="string">"CE"</span>) &#123;</span><br><span class="line">    system.winMobile = system.win;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (system.win == <span class="string">"Ph"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Windows Phone OS (\d+.\d+)/</span>.test(ua)) &#123;;</span><br><span class="line">      system.win = <span class="string">"Phone"</span>;</span><br><span class="line">      system.winMobile = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//determine iOS version</span></span><br><span class="line">  <span class="keyword">if</span> (system.mac &amp;&amp; ua.indexOf(<span class="string">"Mobile"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/CPU (?:iPhone )?OS (\d+_\d+)/</span>.test(ua)) &#123;</span><br><span class="line">      system.ios = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1.</span>replace(<span class="string">"_"</span>, <span class="string">"."</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      system.ios = <span class="number">2</span>; <span class="comment">//can't really detect - so guess</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//determine Android version</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/Android (\d+\.\d+)/</span>.test(ua)) &#123;</span><br><span class="line">    system.android = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//gaming systems</span></span><br><span class="line">  system.wii = ua.indexOf(<span class="string">"Wii"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">  system.ps = <span class="regexp">/playstation/i</span>.test(ua);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//return it</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    engine: engine,</span><br><span class="line">    browser: browser,</span><br><span class="line">    system: system</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BOM-第八章&quot;&gt;&lt;a href=&quot;#BOM-第八章&quot; class=&quot;headerlink&quot; title=&quot;BOM(第八章)&quot;&gt;&lt;/a&gt;BOM(第八章)&lt;/h1&gt;&lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《ECMAScript 6 入门》读书笔记 - vol.1</title>
    <link href="http://yoursite.com/2017/12/21/es6-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-vol1/"/>
    <id>http://yoursite.com/2017/12/21/es6-读书笔记-vol1/</id>
    <published>2017-12-21T00:38:07.000Z</published>
    <updated>2017-12-21T00:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let-amp-const-取消全局属性挂载"><a href="#let-amp-const-取消全局属性挂载" class="headerlink" title="let &amp; const 取消全局属性挂载"></a>let &amp; const 取消全局属性挂载</h3><p><code>let</code>,<code>const</code>,<code>class</code>都不会挂载在全局属性<code>global(window)</code>下.</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="交换变量值"><a href="#交换变量值" class="headerlink" title="交换变量值"></a>交换变量值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="提取json数据"><a href="#提取json数据" class="headerlink" title="提取json数据"></a>提取json数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h3><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="string-includes-str-：返回布尔值，表示是否找到了参数字符串。"><a href="#string-includes-str-：返回布尔值，表示是否找到了参数字符串。" class="headerlink" title="string.includes(str)：返回布尔值，表示是否找到了参数字符串。"></a>string.includes(str)：返回布尔值，表示是否找到了参数字符串。</h3><h3 id="string-startsWith-str-：返回布尔值，表示参数字符串是否在原字符串的头部。"><a href="#string-startsWith-str-：返回布尔值，表示参数字符串是否在原字符串的头部。" class="headerlink" title="string.startsWith(str)：返回布尔值，表示参数字符串是否在原字符串的头部。"></a>string.startsWith(str)：返回布尔值，表示参数字符串是否在原字符串的头部。</h3><h3 id="string-endsWith-str-：返回布尔值，表示参数字符串是否在原字符串的尾部。"><a href="#string-endsWith-str-：返回布尔值，表示参数字符串是否在原字符串的尾部。" class="headerlink" title="string.endsWith(str)：返回布尔值，表示参数字符串是否在原字符串的尾部。"></a>string.endsWith(str)：返回布尔值，表示参数字符串是否在原字符串的尾部。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="string-repeat-number-return-new-str"><a href="#string-repeat-number-return-new-str" class="headerlink" title="string.repeat(number) return new str"></a>string.repeat(number) return new str</h3><p>返回一个新字符串表示将原字符串重复n次</p><h3 id="string-padStart-num-str-padEnd-return-new-str"><a href="#string-padStart-num-str-padEnd-return-new-str" class="headerlink" title="string.padStart(num,str).padEnd return new str."></a>string.padStart(num,str).padEnd return new str.</h3><p>如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串的大括号内部，就是执行 JavaScript 代码，如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法,模板字符串之中还能调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 可以嵌套</span></span><br><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h3 id="构造函数创建正则实例的改变"><a href="#构造函数创建正则实例的改变" class="headerlink" title="构造函数创建正则实例的改变"></a>构造函数创建正则实例的改变</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许第一个参数是正则时,用第二个参数添加修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">'i'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用这种方式会产生修饰符覆盖</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags <span class="comment">//i</span></span><br></pre></td></tr></table></figure><h3 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h3><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p><p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p><ul><li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li><li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li><li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li><li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li></ul><h3 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h3><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。改进方法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>作为练习，请问下面两种写法有什么差别？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure><h3 id="默认值作用域"><a href="#默认值作用域" class="headerlink" title="默认值作用域"></a>默认值作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>参数是函数时也遵守类似规则, 直接上例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><h3 id="name属性返回函数的函数名"><a href="#name属性返回函数的函数名" class="headerlink" title="name属性返回函数的函数名"></a>name属性返回函数的函数名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.name <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.name <span class="comment">// "foo(es6),空字符串(es5)"</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p><p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><h3 id="reduce函数-arr-reduce-callback-initialValue"><a href="#reduce函数-arr-reduce-callback-initialValue" class="headerlink" title="reduce函数 arr.reduce(callback[, initialValue])"></a>reduce函数 arr.reduce(callback[, initialValue])</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum + value;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// total is 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>下面是一个管道机制的例子,前一个函数的输出是最后一个函数的输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="…替代apply"><a href="#…替代apply" class="headerlink" title="…替代apply"></a>…替代apply</h3><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><h3 id="深拷贝数组"><a href="#深拷贝数组" class="headerlink" title="深拷贝数组"></a>深拷贝数组</h3><p>扩展运算符提供了复制数组的简便写法, 不引用数组地址, 真实的复制一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>返回字符串长度的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪数组或任何Iterator接口的对象转化为数组"><a href="#伪数组或任何Iterator接口的对象转化为数组" class="headerlink" title="伪数组或任何Iterator接口的对象转化为数组"></a>伪数组或任何Iterator接口的对象转化为数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><h3 id="map-amp-set-generator函数转化为数组"><a href="#map-amp-set-generator函数转化为数组" class="headerlink" title="map&amp;set,generator函数转化为数组"></a>map&amp;set,generator函数转化为数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）(伪数组)和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// ['a', 'b']</span></span><br></pre></td></tr></table></figure><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><p><code>Array.of</code>方法可以用下面的代码模拟实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arr-find-amp-findIndex"><a href="#arr-find-amp-findIndex" class="headerlink" title="arr.find() &amp; findIndex()"></a>arr.find() &amp; findIndex()</h3><p>用来代替indexOf</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="arr-fill-value-start-end"><a href="#arr-fill-value-start-end" class="headerlink" title="arr.fill(value[,start,end])"></a>arr.fill(value[,start,end])</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><h3 id="arr-entries-，keys-和values"><a href="#arr-entries-，keys-和values" class="headerlink" title="arr.entries()，keys()和values()"></a>arr.entries()，keys()和values()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。</span></span><br><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><h3 id="arr-includes"><a href="#arr-includes" class="headerlink" title="arr.includes()"></a>arr.includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p><ul><li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li><li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li></ul><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="getter与setter的简写表示"><a href="#getter与setter的简写表示" class="headerlink" title="getter与setter的简写表示"></a>getter与setter的简写表示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-is-var1-var2"><a href="#Object-is-var1-var2" class="headerlink" title="Object.is(var1,var2)"></a>Object.is(var1,var2)</h3><p><code>Object.is(var1,var2) return boolean</code></p><p><code>Object.is</code>用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致,不一致的地方见下面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure><ol><li>为对象添加属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为对象添加方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>克隆对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不保证继承链的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保持继承链的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>合并多个对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure><ol><li>为属性指定默认值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  <span class="built_in">console</span>.log(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性的可枚举和遍历"><a href="#属性的可枚举和遍历" class="headerlink" title="属性的可枚举和遍历"></a>属性的可枚举和遍历</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>前面说过，<code>Object.getOwnPropertyDescriptor</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors(多个s)</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  get bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p><h3 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj,prototype)"></a>Object.setPrototypeOf(obj,prototype)</h3><p>与obj.<strong>proto</strong>作用相同,用来设置一个对象的prototype对象(.<strong>proto</strong>,[[prototype]]),返回参数对象本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置空对象</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf-obj"><a href="#Object-getPrototypeOf-obj" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h3><p><code>Object.getPrototypeOf(obj) return prototype</code></p><p>读取一个对象的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj)</span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>指向当前对象的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure><p>super关键字表示原型对象时,只能用在es6简写法里,其他都会报错</p><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure><h3 id="Object-keys-obj-Object-values-obj-Object-entries-obj-return-arr"><a href="#Object-keys-obj-Object-values-obj-Object-entries-obj-return-arr" class="headerlink" title="Object.keys(obj),Object.values(obj),Object.entries(obj) return arr"></a>Object.keys(obj),Object.values(obj),Object.entries(obj) return arr</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都只返回自身的,不返回继承的</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// ["foo", "baz"]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// ["bar", 42]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></span><br></pre></td></tr></table></figure><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>下面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="es6克隆对象的三种写法"><a href="#es6克隆对象的三种写法" class="headerlink" title="es6克隆对象的三种写法"></a>es6克隆对象的三种写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> clone1 = &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="built_in">Object</span>.assign(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="Null传导运算符"><a href="#Null传导运算符" class="headerlink" title="Null传导运算符"></a>Null传导运算符</h3><p>为了防止null.a 或 undefined.a报错,还只是提案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 a 是 null 或 undefined, 返回 undefined</span></span><br><span class="line"><span class="comment">// 否则返回 a.b.c().d</span></span><br><span class="line">a?.b.c().d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span></span><br><span class="line"><span class="comment">// 否则执行 a.b = 42</span></span><br><span class="line">a?.b = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span></span><br><span class="line"><span class="keyword">delete</span> a?.b</span><br></pre></td></tr></table></figure><hr><h2 id="Class-extends-类继承"><a href="#Class-extends-类继承" class="headerlink" title="Class extends 类继承"></a>Class extends 类继承</h2><h3 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h3><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><p>Class 内部调用<code>new.target</code>，返回当前 Class。</p><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><h3 id="super-1"><a href="#super-1" class="headerlink" title="super()"></a>super()</h3><p>super作为函数调用时,代表父类的构造函数. ES6要求, 子类的构造函数必须执行一次<code>super</code>函数</p><p>super只能用在子类的constructor中,相当于执行了<code>Father.prototype.constructor.call(this)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><h3 id="super-2"><a href="#super-2" class="headerlink" title="super"></a>super</h3><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><p>ES6 规定，通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向子类。</p><p>由于<code>this</code>指向子类，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><h3 id="类的Prototype属性和proto属性"><a href="#类的Prototype属性和proto属性" class="headerlink" title="类的Prototype属性和proto属性"></a>类的Prototype属性和<strong>proto</strong>属性</h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><p><img src="https://i.loli.net/2017/12/21/5a3b0244c9ed5.jpg" alt=""></p><p>上面的图代表class Son extends Father 的继承关系</p><h2 id="ES6严格模式"><a href="#ES6严格模式" class="headerlink" title="ES6严格模式"></a>ES6严格模式</h2><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li><li>顶层<code>this</code>属于undefined,不应该在顶层使用this</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let-amp-const-取消全局属性挂载&quot;&gt;&lt;a href=&quot;#let-amp-const-取消全局属性挂载&quot; class=&quot;headerlink&quot; title=&quot;let &amp;amp; const 取消全局属性挂载&quot;&gt;&lt;/a&gt;let &amp;amp; const 取消
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》函数表达式</title>
    <link href="http://yoursite.com/2017/12/20/%E9%AB%98%E7%A8%8Bvol3-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/12/20/高程vol3-第七章/</id>
    <published>2017-12-20T03:53:43.000Z</published>
    <updated>2017-12-21T03:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数表达式用于循环语句"><a href="#函数表达式用于循环语句" class="headerlink" title="函数表达式用于循环语句"></a>函数表达式用于循环语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要这样做</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; ...sth <span class="keyword">else</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换成函数表达式</span></span><br><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ...sth <span class="keyword">else</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="递归中arguments-callee的替代"><a href="#递归中arguments-callee的替代" class="headerlink" title="递归中arguments.callee的替代"></a>递归中arguments.callee的替代</h3><p>严格模式下不能使用arguments.callee,可以使用命名函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num*f(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="基础闭包"><a href="#基础闭包" class="headerlink" title="基础闭包"></a>基础闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 使用闭包,返回一个数组[0,1,2,3,4]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnNums</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      arr[num] = i;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(returnNums());</span><br></pre></td></tr></table></figure><h3 id="闭包中返回函数的this"><a href="#闭包中返回函数的this" class="headerlink" title="闭包中返回函数的this"></a>闭包中返回函数的this</h3><blockquote><p>匿名函数具有全局性,this一般指向global(浏览器为window)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  abc : <span class="string">'obj'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.abc) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()() <span class="comment">//window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> abc = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  abc : <span class="string">'obj'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.abc) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()() <span class="comment">//obj</span></span><br><span class="line"></span><br><span class="line">obj.abc(); <span class="comment">// obj</span></span><br><span class="line">(object.abc)(); <span class="comment">//obj,虽然加括号了,但没有形成表达式,等于没加</span></span><br><span class="line">(obj.abc = obj.abc)(); <span class="comment">//'window',形成表达式,表达式等于最右边的值:函数</span></span><br></pre></td></tr></table></figure><h3 id="闭包的内存回收"><a href="#闭包的内存回收" class="headerlink" title="闭包的内存回收"></a>闭包的内存回收</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>); </span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(element.id); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码存在内存泄露问题</span></span><br><span class="line"><span class="comment">// element.onclick匿名函数永远存在着对element.id的引用,所以element对象永远释放不了</span></span><br><span class="line"><span class="comment">// 修改代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;</span><br><span class="line"></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(id) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于变量id被引用,整个闭包的所有变量(包括element),还是无法释放</span></span><br><span class="line">    <span class="comment">// 所以要将element=null,让闭包内只剩下必要的id变量</span></span><br><span class="line">    element = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟块级作用域"><a href="#模拟块级作用域" class="headerlink" title="模拟块级作用域"></a>模拟块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 块级作用域</span></span><br><span class="line">    <span class="comment">// 因为没有指向自调用函数的引用,所以函数执行后会立刻销毁内部变量所占内存</span></span><br><span class="line">    <span class="comment">// 所以可以减少内存使用</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><blockquote><p>私有变量包括<code>函数的参数</code>、<code>局部变量</code>和<code>在函数内部定义的其他函数</code></p></blockquote><h3 id="特权方法"><a href="#特权方法" class="headerlink" title="特权方法"></a>特权方法</h3><blockquote><p>把有权访问<code>私有变量</code>和<code>私有函数</code>的<code>公有方法</code>称为<code>特权方法（privileged method)</code><br>外部只能通过<code>特权方法</code>访问<code>私有变量</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// name是一个私有变量(不带this,不在实例属性内,只是构造函数内部的一个变量)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 特权方法getName与setName</span></span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">alert(person.getName()); <span class="comment">//"Nicholas"</span></span><br><span class="line">person.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person.getName()); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><blockquote><p>静态私有变量: 静态的, 有所有实例共享的属性<br>静态私有变量可以增加代码复用,但每个实例不能做到拥有自己独自的私有变量<br>到底使用实例变量,还是静态私有变量,看你的需求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  Person = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">alert(person1.getName()); <span class="comment">//"Nicholas"</span></span><br><span class="line">person1.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person1.getName()); <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Michael"</span>);</span><br><span class="line">alert(person1.getName()); <span class="comment">//"Michael"</span></span><br><span class="line">alert(person2.getName()); <span class="comment">//"Michael"</span></span><br></pre></td></tr></table></figure><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><blockquote><p>为<code>单例</code>创建私有变量和特权方法<br>如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleList = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义私有变量</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = &#123;&#125;,</span><br><span class="line">    vue = &#123;&#125;,</span><br><span class="line">    react = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> Component = [jQuery, vue, react]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// return一个单例,里面的方法是特权方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getLenth: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Component.length</span><br><span class="line">    &#125;,</span><br><span class="line">    addModlue: <span class="function"><span class="keyword">function</span> (<span class="params">comp</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> comp === <span class="string">'object'</span>) &#123;</span><br><span class="line">        Component.push(comp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moduleList.getLenth()) <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> angular = &#123;&#125;</span><br><span class="line">moduleList.addModlue(angular)</span><br><span class="line"><span class="built_in">console</span>.log(moduleList.getLenth()); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><blockquote><p>有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BaseComponent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OtherComponent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有变量或方法</span></span><br><span class="line">  <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需求:application必须是BaseComponent()实例</span></span><br><span class="line">  <span class="comment">// 需求:且application必须是一个单例</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里匿名函数闭包内部的app实际上是application的一个局部拷贝</span></span><br><span class="line">  <span class="comment">// 且此app有权访问私有变量或方法</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> BaseComponent();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将特权方法放到app上</span></span><br><span class="line">  app.getComponentCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> components.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  app.registerComponent = <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>) &#123;</span><br><span class="line">      components.push(component);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">alert(application <span class="keyword">instanceof</span> BaseComponent); <span class="comment">//true</span></span><br><span class="line">application.registerComponent(<span class="keyword">new</span> OtherComponent());</span><br><span class="line">alert(application.getComponentCount()); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数表达式用于循环语句&quot;&gt;&lt;a href=&quot;#函数表达式用于循环语句&quot; class=&quot;headerlink&quot; title=&quot;函数表达式用于循环语句&quot;&gt;&lt;/a&gt;函数表达式用于循环语句&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解javaScript继承机制</title>
    <link href="http://yoursite.com/2017/12/20/17-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javaScript%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/12/20/17-深入理解javaScript继承/</id>
    <published>2017-12-19T23:14:55.000Z</published>
    <updated>2017-12-21T00:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么?"></a>这是什么?</h3><p>自己在学习《JavaScript高级程序设计》 和《ES6 标准教程》 中的一些体会. 主要关注<code>javascript</code>继承的组织模式, 自己的一些心得体会.</p><p>写博客的目的是为了学习的正反馈, 帮助自己理解.</p><blockquote><p>这篇博客会直接上最终结论, 后面再放上推导最终结论的过程.<br>这样做的理由是, 如果直接能理解最终结论, 就不太用看推导过程了</p></blockquote><h2 id="最佳实践-寄生组合式继承"><a href="#最佳实践-寄生组合式继承" class="headerlink" title="最佳实践, 寄生组合式继承"></a>最佳实践, 寄生组合式继承</h2><p>不啰嗦, 直接上结论, javaScript继承的最佳实践, 最终形态, 应该如图所示</p><p><img src="https://i.loli.net/2017/12/20/5a399d347382c.jpg" alt=""></p><blockquote><p>解释下上面的流程图.</p><ol><li><code>[[ prototype ]]</code> 的浏览器实现是 <code>.__proto__</code></li><li>首字母大写的是<code>构造函数</code> 或 <code>类</code>, 首字母小写的是 <code>构造函数实例</code> 或 <code>类实例</code></li><li>应用上图的继承方式,<code>son</code>实例继承了<code>Father</code>构造函数中的属性,且属性变为私有, 在<code>son1</code>上修改继承后的属性, 不会影响<code>son2</code>中的属性.</li><li>应用上图的继承方式, <code>son</code>实例继承了<code>Father.prototype</code>原型中的公用方法, 这些方法被<code>son1</code>,<code>son2</code>所共用, 修改<code>son1</code>上继承的方法会影响<code>son2</code>中的同名方法</li><li>所以应该这样组织我们的代码, 将需要私有的属性放入<code>构造函数</code>中用<code>Father.call(this,...args)</code>来继承, 将需要共用的属性放入<code>Father.prototype</code>中用原型链继承.</li><li>这种继承之所以是最佳实践, 因为既解决了<code>共用方法复用</code>,又解决了<code>属性私有化</code>,还解决了<code>instanceof,isPrototypeOf 指向问题</code></li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// just 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Son, Father</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用原型式继承创建一个对象,此对象原型式继承自Father.prototype</span></span><br><span class="line">  <span class="keyword">var</span> prototype = object(Father.prototype);</span><br><span class="line">  <span class="comment">// 将此对象赋值为Son的原型对象指针Son.prototype</span></span><br><span class="line">  <span class="comment">// 相当于使Son.prototype原型式继承自Father.protottype</span></span><br><span class="line">  <span class="comment">// 从而使所有Son实例获得了Father.prototype上的公用属性和方法</span></span><br><span class="line">  prototype.constructor = Son;</span><br><span class="line">  Son.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下述方法会因寄生式继承继承给Son.prototype</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用借用构造函数式继承,继承了Father构造函数中的属性</span></span><br><span class="line">  <span class="comment">// 借用构造函数继承的属性不复用.每个Son实例中的属性都是独立的</span></span><br><span class="line">  <span class="comment">// 原理是this都不一样,所以当然是独立的</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改Son.prototype指向</span></span><br><span class="line"><span class="comment">// 使其指向我们创建的继承自Father.prototype的对象</span></span><br><span class="line">inheritPrototype(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强Son.prototype,增加的方法sayAge是father实例访问不到的.</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"Jordan"</span>, <span class="number">23</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Jordan";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son(<span class="string">"Kobe"</span>, <span class="number">24</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Kobe";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//24</span></span><br></pre></td></tr></table></figure><h3 id="ES6中类的实现方式"><a href="#ES6中类的实现方式" class="headerlink" title="ES6中类的实现方式"></a>ES6中类的实现方式</h3><blockquote><p>ES6中,<code>类</code>的继承方式和<code>继承组合式</code>继承相吻合. 其中<code>Father.call(this,...args)</code>用<code>super(..args)</code>实现</p></blockquote><p><img src="https://i.loli.net/2017/12/20/5a399f0887a7a.jpg" alt=""></p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><blockquote><p>下面是最终结论的推导过程</p></blockquote><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote><p>原型链继承存在2个缺陷:<br>1.像下面代码一样,不能从<code>Father</code>构造函数中直接继承属性,还要再定义一个<code>sonName</code><br>2.像下面代码一样,steve向favorite中push了’kobe’,导致mike的favorite也发生了改变,没有做到<code>继承属性私有化</code><br>解决这个问题的方式是<code>借用构造函数</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">  <span class="keyword">this</span>.favorite = [<span class="string">'Johnson'</span>,<span class="string">'Bird'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hey,I\'m father'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sonName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hey,I\'m son'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mike = <span class="keyword">new</span> Son(<span class="string">'mike'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.name) <span class="comment">//father</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.sonName) <span class="comment">//mike</span></span><br><span class="line">mike.sayHi() <span class="comment">// hey I m son</span></span><br><span class="line"><span class="keyword">const</span> steve = <span class="keyword">new</span> Son(<span class="string">'steve'</span>)</span><br><span class="line">steve.favorite.push(<span class="string">'kobe'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.favorite); <span class="comment">//["Johnson", "Bird", "kobe"]</span></span><br></pre></td></tr></table></figure><h3 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h3><blockquote><p><code>混合继承</code> 由 <code>原型链继承</code> 添加 <code>借用构造函数</code> 修改而来<br><code>借用构造函数</code> 实现了 让每个<code>son</code>实例都有自己的name与favorite属性,且都继承自Father构造函数</p><p>但这还不够完美, 比如, <code>Son.prototype</code>中,永远存放着一个<code>name</code>和<code>favorite</code>属性,<code>son</code>实例每次都通过重写来覆盖这两个属性,这是不必要的<br>解决方法是在此基础上增加<code>寄生式继承</code>,而<code>寄生式继承</code>依赖于<code>原型式继承</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'father'</span></span><br><span class="line">  <span class="keyword">this</span>.favorite = [<span class="string">'Johnson'</span>,<span class="string">'Bird'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hey,I\'m father'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="comment">// 每个实例都有自己私有的name和favorite,且都继承自Father构造函数</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>,name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hey,I\'m son'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mike = <span class="keyword">new</span> Son(<span class="string">'mike'</span>,<span class="number">23</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mike.name) <span class="comment">//father</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.sonName) <span class="comment">//mike</span></span><br><span class="line">mike.sayHi() <span class="comment">//"hey I m son"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> steve = <span class="keyword">new</span> Son(<span class="string">'steve'</span>,<span class="number">24</span>)</span><br><span class="line">steve.favorite.push(<span class="string">'kobe'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(steve.favorite); <span class="comment">//["Johnson", "Bird", "kobe"]</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.favorite); <span class="comment">//["Johnson", "Bird"]</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/12/20/5a399d3498b67.jpg" alt=""></p><h3 id="原型式继承的原理"><a href="#原型式继承的原理" class="headerlink" title="原型式继承的原理"></a>原型式继承的原理</h3><blockquote><p>原型式继承就是让o1的原型对象是o,当然这其中有一些tricks</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用这种方法的目的是return的new F()是一个新对象</span></span><br><span class="line"><span class="comment">// 给new F()增加新的方法,并不会增加到o上.</span></span><br><span class="line"><span class="keyword">const</span> o1 = object(o)</span><br></pre></td></tr></table></figure><h3 id="ES5规范的原型式继承-Object-create"><a href="#ES5规范的原型式继承-Object-create" class="headerlink" title="ES5规范的原型式继承,Object.create()"></a>ES5规范的原型式继承,Object.create()</h3><p><code>Object.create(prototypeObj[,descriptorsObj]) return obj</code></p><blockquote><p>es5用<code>Object.create()</code>方法规范了原型式继承<br>创建一个obj对象,原型是prototypeObj(obj.<strong>proto</strong> === prototypeObj),同时用descriptorsObj(与Object.defineProperties()中的第二个参数相同)定义obj上自己的属性.<br>适用场景: 只是想让一个对象与另一个对象保持类似的情况下,用此方法简单粗暴</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> father = &#123;  <span class="attr">name</span>: <span class="string">'Father'</span>,&#125;;<span class="keyword">var</span> son = <span class="built_in">Object</span>.create(father, &#123;  <span class="attr">name</span>: &#123;    <span class="attr">value</span>: <span class="string">"son"</span>  &#125;&#125;);alert(son.name); <span class="comment">//"son"</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote><p>理解<code>寄生式继承</code>的目的是理解最终的<code>寄生组合式</code>继承. </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() </span><br><span class="line">  <span class="comment">//这里返回的事一个新对象,不是obj的浅拷贝,而是obj的原型继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inHeritance</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里创建出的o1,原型继承自o</span></span><br><span class="line">  <span class="keyword">var</span> o1 = object(o)</span><br><span class="line">  <span class="comment">//增强o1,添加sayHi()方法</span></span><br><span class="line">  <span class="comment">//且这个方法不会添加到o上</span></span><br><span class="line">  o1.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'choteewang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个newObj,寄生继承自obj,比obj多一个方法sayHi()</span></span><br><span class="line"><span class="keyword">var</span> newObj = inHeritance(obj)</span><br><span class="line">newObj.sayHi() <span class="comment">//hey</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name) <span class="comment">//choteewang,继承自原型对象</span></span><br><span class="line">obj.sayHi() <span class="comment">//报错,obj没有这个属性</span></span><br></pre></td></tr></table></figure><blockquote><p>推导过程完毕, 请跳跃到顶部理解<code>最佳实践,寄生组合式继承</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;这是什么&quot;&gt;&lt;a href=&quot;#这是什么&quot; class=&quot;headerlink&quot; title=&quot;这是什么?&quot;&gt;&lt;/a&gt;这是什么?&lt;/h3&gt;&lt;p&gt;自己在学习《JavaScript高级程序设计》 和《ES6 标准教程》 中的一些体会. 主要关注&lt;code&gt;javasc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》OOP</title>
    <link href="http://yoursite.com/2017/12/19/16-%E9%AB%98%E7%A8%8Bvol2-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/12/19/16-高程vol2-第六章/</id>
    <published>2017-12-19T13:04:41.000Z</published>
    <updated>2017-12-21T03:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="对象的底层attribute"><a href="#对象的底层attribute" class="headerlink" title="对象的底层attribute"></a>对象的底层attribute</h3><p>放在了两对儿方括号中，例如<code>[[Enumerable]]</code>,JavaScript不能直接访问他们,是为了实现引擎而实现的.</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性就是不用<code>get</code>和<code>set</code>描述的属性,包含一个数据值的位置, 可以读取或写入值, 值的位置是<code>[[value]]</code>,同时被下列属性限制着.</p><ul><li><code>[[Configurable]]</code> 表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true</li><li><code>[[Enumerable]]</code> 表示能否通过 for-in 循环返回属性,是否可枚举,对象上的属性默认true</li><li><code>[[Writable]]</code>：能否修改属性的值。</li><li><code>[[Value]]</code>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。默认值undefined</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p><code>Object.defineProperty(obj,propName,descriptorObj) return obj</code></p><p>在调用<code>obj.defineProperty()</code>方法时,如果不指定,<code>configurable, enumerable, writable</code>属性的默认值都变为false.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">//'Nicholas'</span></span><br><span class="line">person.name = <span class="string">"Michael"</span>;</span><br><span class="line">alert(person.name); <span class="comment">//'Nicholas'</span></span><br></pre></td></tr></table></figure><h3 id="configurable属性"><a href="#configurable属性" class="headerlink" title="configurable属性"></a>configurable属性</h3><p>把<code>configurable</code>设置为false,表示不能用<code>delete</code>运算符从对象中删除属性. 且不能再将此属性变为’可配置’,且此时再调用<code>obj.defineProperty()</code>方法修改除<code>writable</code>之外的特性,都会导致错误.</p><p>也就是说,可以多次调用<code>obj.defineProperty()</code>方法修改同一个属性,但在把<code>configurable</code>设置为false之后,就会有了很大限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'</span></span><br></pre></td></tr></table></figure><h3 id="访问器属性-get-set"><a href="#访问器属性-get-set" class="headerlink" title="访问器属性 get,set"></a>访问器属性 get,set</h3><p><code>访问器属性</code>这个概念相对于<code>数据属性</code>,它们包含一对<code>getter</code>和<code>setter</code>函数(都不必须),读取属性时调用<code>getter</code>,赋值时调用<code>setter</code>, 它们被下列属性限制</p><ul><li><code>[[Configurable]]</code> 表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true</li><li><code>[[Enumerable]]</code> 表示能否通过 for-in 循环返回属性,是否可枚举,对象上的属性默认true</li><li><code>[[get]]</code> 默认undefined</li><li><code>[[set]]</code> 默认undefined</li></ul><blockquote><p>访问器属性不能直接定义,必须通过Object.defineProperty()定义.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;<span class="keyword">var</span> book = &#123;    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,    &#125;,    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="comment">// 访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化</span></span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure><blockquote><p>不一定非要同时指定 <code>getter</code> 和 <code>setter</code>。只指定 <code>getter</code> 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 <code>getter</code> 函数的属性会抛出错误。<br>类似地，只指定 <code>setter</code> 函数的属性不能读<br>旧方法obj.<strong>defineGetter</strong>与__defineSetter已经被废弃</p></blockquote><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p><code>Object.defineProperties(obj,descriptorsObj) return obj</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p><code>Object.getOwnPropertyDescriptor(obj, propName) return DescriptorsObj</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//undefined</span></span><br><span class="line">alert(descriptor.enumerable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure><blockquote><p>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 <code>Object.getOwnPropertyDescriptor()</code>方法</p></blockquote><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="Object-obj"><a href="#Object-obj" class="headerlink" title="Object(obj)"></a>Object(obj)</h3><p><code>Object(obj) return obj1</code></p><p><code>Object()</code>方法可以作为传入对象的包装器,生成一个obj1对象,obj1是obj的浅拷贝</p><pre><code class="js"><span class="keyword">var</span> obj = {  name:<span class="string">'choteewang'</span>,}<span class="keyword">var</span> obj1 = <span class="built_in">Object</span>(obj)<span class="built_in">console</span>.log(obj1); <span class="built_in">console</span>.log(obj1.name); <span class="comment">// choteewang</span>obj1.name=<span class="string">'jordan'</span><span class="built_in">console</span>.log(obj.name); <span class="comment">// jordan</span></code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.job=job;</span><br><span class="line">  <span class="keyword">this</span>.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行了下面步骤:</p><ol><li>创建一个对象</li><li>将构造函数this指向此对象</li><li>执行构造函数中的代码</li><li>不用return,但返回新对象</li></ol></blockquote><h4 id="构造函数当做普通函数"><a href="#构造函数当做普通函数" class="headerlink" title="构造函数当做普通函数"></a>构造函数当做普通函数</h4><blockquote><p>不调用new运算符,构造函数与普通函数无异,this指向全局global对象,在浏览器中是window.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当做构造函数调用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);  <span class="comment">//adds to window</span></span><br><span class="line"><span class="built_in">window</span>.sayName();   <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域内被调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName();    <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure><h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj instanceOf <span class="built_in">Object</span> <span class="comment">// 判断Object.prototype是否在obj的原型链上</span></span><br></pre></td></tr></table></figure><blockquote><p>检测类型用 instanceof 好过typeof(可以检测构造函数名,类型更具体) 与 obj.constructor(原型指向后期可改,返回不了正确值)</p></blockquote><h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>为每个类似的实例都创建了相似的方法和属性,所以需要引进<code>原型模式</code>,将公用方法和属性放在原型上.</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><img src="https://i.loli.net/2017/12/19/5a390f498339e.jpg" alt=""></p><blockquote><p><code>[[Prototype]]</code> 的实现就是浏览器里的 <code>__proto__</code></p></blockquote><h4 id="Prototype-isPrototypeOf-obj"><a href="#Prototype-isPrototypeOf-obj" class="headerlink" title="Prototype.isPrototypeOf(obj)"></a>Prototype.isPrototypeOf(obj)</h4><p><code>Prototype.isPrototypeOf(obj) return boolean</code></p><blockquote><p>类似instanceOf运算符的逆方法,只要<code>Prototype</code>在<code>obj</code>的原型链上,就返回true</p></blockquote><h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p><code>Object.getPrototypeOf(obj) return obj.__proto__</code></p><p>ECMAScript 5 增加了一个新方法，叫 <code>Object.getPrototypeOf()</code>，在所有支持的实现中，这个 方法返回<code>[[Prototype]]</code>的值</p><h4 id="obj-hasOwnProperty-propName"><a href="#obj-hasOwnProperty-propName" class="headerlink" title="obj.hasOwnProperty(propName)"></a>obj.hasOwnProperty(propName)</h4><p><code>obj.hasOwnProperty(propName) return boolean</code></p><blockquote><p>用来判断propName属性是处于obj中还是继承自obj的原型链.这个方法是从Object.prototype中继承来的</p></blockquote><p>列举下从Object.prototype继承来的方法</p><ul><li><code>obj.hasOwnProperty(propertyName)</code> 用于检测给定属性在当前实例中(不包含原型链中)是否存在</li><li><code>obj.isPrototypeOf(obj2)</code> 用于检查obj是否在obj2的原型链上</li><li><code>obj.propertyIsEnumerable(propertyName)</code> 用于检查给定属性是否可枚举</li><li><code>obj.toLocaleString()</code> </li><li><code>obj.toString()</code></li><li><code>obj.valueOf()</code> 返回对象的字符串,数值,或布尔值表示,通常与toString()返回值相同</li></ul><blockquote><p>ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属 性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。</p></blockquote><h4 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h4><ul><li>用于for-in循环</li><li><code>(&quot;propName&quot; in obj)</code> // true or false</li></ul><blockquote><p>只要obj可以访问到propName,就返回true,无论propName部署在对象实例上还是其原型链上</p><p>只要用in操作符返回true &amp;&amp; 调用hasOwnProperty()返回false, 就能确定属性部署在原型链上</p></blockquote><h4 id="for-in-循环的范围"><a href="#for-in-循环的范围" class="headerlink" title="for-in 循环的范围"></a>for-in 循环的范围</h4><blockquote><p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性， 也包括存在于原型中的属性。 屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的</p></blockquote><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p><code>Object.keys(obj) return arr</code></p><blockquote><p>该方法可以取得参数对象上所有<code>可枚举</code>的属性,并将属性名组合为一个数组返回</p></blockquote><h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames(obj) return arr</code></p><blockquote><p>该方法取得所有obj实例上的属性,枚举不枚举的都算,并将属性名组合为一个数组返回</p></blockquote><h4 id="修改原型的同时修改constructor属性"><a href="#修改原型的同时修改constructor属性" class="headerlink" title="修改原型的同时修改constructor属性"></a>修改原型的同时修改constructor属性</h4><blockquote><p>修改构造函数的prototype会让新设置的prototype对象的constructor指向不准确,如下例,新prototype对象的constructor指向Object.prototype.<br>所以需要手动给新prototype对象添加constructor属性<br>constructor属性默认不可枚举,所以要用<code>Object.defineProperty()</code>修改.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.protoype = &#123; <span class="attr">new</span>: <span class="string">"new"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">'constructor'</span>,&#123;</span><br><span class="line">  enumerable:<span class="literal">false</span>;</span><br><span class="line">  value:Person;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote><p>下面的例子模拟了javaScript代码内部的原型链继承部署模式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line">alert(instance.getSuperValue()) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType) <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/12/19/5a390f4a02d8c.jpg" alt=""></p><h4 id="重写超类型的方法"><a href="#重写超类型的方法" class="headerlink" title="重写超类型的方法"></a>重写超类型的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.property = <span class="literal">true</span>;&#125;SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.property;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;&#125;<span class="comment">//inherit from SuperType</span>SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//new method</span>SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;&#125;;<span class="comment">//override existing method</span>SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;;<span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();alert(instance.getSuperValue());   <span class="comment">//false</span></span><br></pre></td></tr></table></figure><blockquote><p>在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType 中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。</p></blockquote><h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;            &#125;<span class="comment">//inherit from SuperType</span>SubType.prototype = <span class="keyword">new</span> SuperType();<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors);    <span class="comment">//"red,blue,green,black"</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();alert(instance2.colors);    <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><blockquote><p>这个例子中的 SuperType 构造函数定义了一个 colors 属性，该属性包含一个数组（引用类型值）。SuperType 的每个实例都会有各自包含自己数组的 colors 属性。当 SubType 通过原型链继承了 SuperType 之后, SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。而我们对 instance1.colors 的修改 能够通过 instance2.colors 反映出来，就已经充分证实了这一点。</p></blockquote><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><blockquote><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数，如下所示：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//inherit from SuperType</span>  SuperType.call(<span class="keyword">this</span>);&#125;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure><blockquote><p>代码中加粗的那一行代码“借调”了超类型的构造函数。通过使用 call()方法（或 apply()方法也可以），我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p></blockquote><h4 id="借用构造函数-向超类型构造函数传递参数"><a href="#借用构造函数-向超类型构造函数传递参数" class="headerlink" title="借用构造函数 - 向超类型构造函数传递参数"></a>借用构造函数 - 向超类型构造函数传递参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//inherit from SuperType passing in an argument</span>  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);  <span class="comment">//instance property</span>  <span class="keyword">this</span>.age = <span class="number">29</span>;&#125;<span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();alert(instance.name); <span class="comment">//"Nicholas";</span>alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote><p>最简单高效的继承模式,用<code>原型链继承</code>原型属性和方法,用<code>借用构造函数</code>方式实现对原型属性和方法的集成.<br>既通过<code>原型链继承</code>实现了方法复用,又通过<code>借用构造函数</code>保证了每个实例都有自己的属性.</p><p>弊端: 调用两次SuperType()构造函数, 使得SubType.prototype里有两个无用变量name,colors.<br>每次new Subtype()时,subtype实例内部自带name与colors,自带的属性覆盖掉了SubType.prototype中的name与colors,所以SubType.prototype中的name与colors没用.<br>解决方法直接看本章最后一节寄生混合式继承的笔记</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.name);&#125;;<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;  SuperType.call(<span class="keyword">this</span>, name);  <span class="keyword">this</span>.age = age;&#125;SubType.prototype = <span class="keyword">new</span> SuperType();SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.age);&#125;;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="comment">//"Nicholas";</span>instance1.sayAge(); <span class="comment">//29</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);alert(instance2.colors); <span class="comment">//"red,blue,green"</span>instance2.sayName(); <span class="comment">//"Greg";</span>instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><h3 id="Object-create-原型式继承"><a href="#Object-create-原型式继承" class="headerlink" title="Object.create() - 原型式继承"></a>Object.create() - 原型式继承</h3><p><code>Object.create(prototypeObj[,descriptorsObj]) return obj</code></p><blockquote><p>创建一个obj对象,原型是prototypeObj(obj.<strong>proto</strong> === prototypeObj),同时用descriptorsObj(与Object.defineProperties()中的第二个参数相同)定义obj上自己的属性.<br>适用场景: 只是想让一个对象与另一个对象保持类似的情况下,用此方法简单粗暴</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;  <span class="attr">name</span>: <span class="string">"Nicholas"</span>,  <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;<span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;  <span class="attr">name</span>: &#123;    <span class="attr">value</span>: <span class="string">"Greg"</span>  &#125;&#125;);alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承-只是下述寄生组合式继承的原理"><a href="#寄生式继承-只是下述寄生组合式继承的原理" class="headerlink" title="寄生式继承(只是下述寄生组合式继承的原理)"></a>寄生式继承(只是下述寄生组合式继承的原理)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() </span><br><span class="line">  <span class="comment">//这里返回的事一个新对象,不是obj的浅拷贝,而是obj的原型继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inHeritance</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = object(o)</span><br><span class="line">  <span class="comment">//增强o1,添加sayHi()方法</span></span><br><span class="line">  o1.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'choteewang'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = inHeritance(obj)</span><br><span class="line">newObj.sayHi() <span class="comment">//hey</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name) <span class="comment">//choteewang,继承自原型对象</span></span><br><span class="line">obj.sayHi() <span class="comment">//报错,obj没有这个属性</span></span><br></pre></td></tr></table></figure><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p>本章的终结,改善了<code>组合式继承</code>的缺点,是最成熟的js继承方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// just 原型式继承</span><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  F.prototype = o;  <span class="keyword">return</span> <span class="keyword">new</span> F();&#125;<span class="comment">// 寄生式继承</span><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用原型式继承创建一个对象,此对象原型式继承自superType.prototype</span>  <span class="keyword">var</span> prototype = object(superType.prototype); </span><br><span class="line">  <span class="comment">// 将此对象赋值为subType的原型对象指针subType.prototype</span></span><br><span class="line">  <span class="comment">// 相当于使subType.prototype原型式继承自superType.protottype</span></span><br><span class="line">  <span class="comment">// 从而使所有subtype实例获得了superType.prototype上的公用属性和方法</span>  prototype.constructor = subType;   subType.prototype = prototype; &#125;<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];&#125;<span class="comment">// 下述方法会因寄生式继承继承给subType.prototype</span>SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.name);&#125;;<span class="comment">// 借用构造函数继承</span><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用借用构造函数式继承,继承了SuperType构造函数中的属性</span></span><br><span class="line">  <span class="comment">// 借用构造函数继承的属性不复用.每个subType实例中的属性都是独立的</span></span><br><span class="line">  <span class="comment">// 原理是this都不一样,所以当然是独立的</span>  SuperType.call(<span class="keyword">this</span>, name);  <span class="keyword">this</span>.age = age;&#125;<span class="comment">// 修改subType.prototype指向</span></span><br><span class="line"><span class="comment">// 使其指向我们创建的继承自superType.prototype的对象</span>inheritPrototype(SubType, SuperType);<span class="comment">// 增强SubType.prototype,增加的方法sayAge是supertype实例访问不到的.</span>SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="keyword">this</span>.age);&#125;;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);instance1.colors.push(<span class="string">"black"</span>);alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="comment">//"Nicholas";</span>instance1.sayAge(); <span class="comment">//29</span><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);alert(instance2.colors); <span class="comment">//"red,blue,green"</span>instance2.sayName(); <span class="comment">//"Greg";</span>instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;对象的底层attribute&quot;&gt;&lt;a href=&quot;#对象的底层attribute&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正反馈系列:《JavaScript高级程序设计》1-5章，知识点总结 &amp; 查缺补漏</title>
    <link href="http://yoursite.com/2017/12/19/15-%E9%AB%98%E7%A8%8B1-5%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/12/19/15-高程1-5章/</id>
    <published>2017-12-18T18:22:47.000Z</published>
    <updated>2017-12-18T18:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念-第三章"><a href="#基本概念-第三章" class="headerlink" title="基本概念(第三章)"></a>基本概念(第三章)</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><code>Undefined</code> 基本</li><li><code>Null</code> 基本</li><li><code>Boolean</code> 基本</li><li><code>Number</code> 基本</li><li><code>String</code> 基本</li><li><code>Object</code> (复杂)</li></ul><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><p>返回值是字符串,有六种,对应上述6种数据类型,又略有区别,<code>null</code>返回”object”,函数单独返回”function”</p><ul><li><code>&quot;undefined&quot;</code></li><li><code>&quot;boolean&quot;</code></li><li><code>&quot;string&quot;</code></li><li><code>&quot;number&quot;</code></li><li><code>&quot;object&quot;</code> (object或null都会返回object)</li><li><code>&quot;function&quot;</code> (如果是函数对象)</li></ul><h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h3><p>此类型只有一个值即<code>undefined</code></p><h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>此类型只有一个值<code>null</code>,表示空对象指针,所以<code>typeof</code>会返回<code>&quot;object&quot;</code></p><p>定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>)&#123; <span class="comment">// 对 car 对象执行某些操作 &#125;</span></span><br></pre></td></tr></table></figure><p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>关于转型函数<code>Boolean(x)</code>转化结果</p><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">“”空字符串</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">任何对象除了null</td><td style="text-align:center">true</td></tr></tbody></table><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八进制 </span></span><br><span class="line"><span class="keyword">var</span> octal = <span class="number">013</span> <span class="comment">//0开头,严格模式下无效,任何一位&gt;7,去掉前面的0转为十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制 </span></span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0xA</span> <span class="comment">//0x开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时,八进制十六进制都转换为十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数 </span></span><br><span class="line"><span class="keyword">var</span> float = <span class="number">3.125e7</span> <span class="comment">//相当于3.125*10^7,注意底数是10不是e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值,最小值</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE, <span class="built_in">Number</span>.MIN_VALUE</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无穷</span></span><br><span class="line"><span class="comment">// 超过最大值的数会转换为特殊值Infinity</span></span><br><span class="line"><span class="comment">// 如果是负数转换为-Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isFnite() return boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">1</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 表示一个本来要返回数值的操作数未返回数值（不会抛出错误了）。</span></span><br><span class="line"><span class="comment">// isNaN() return boolean</span></span><br><span class="line"><span class="comment">// 先尝试将参数转换为数值,再返回boolean</span></span><br></pre></td></tr></table></figure><h4 id="转换数值-Number-parseInt-parseFloat"><a href="#转换数值-Number-parseInt-parseFloat" class="headerlink" title="转换数值,Number(),parseInt(),parseFloat()"></a>转换数值,Number(),parseInt(),parseFloat()</h4><p><code>Number</code>的转换规则复杂,且不合理,具体详见高程p30</p><p><code>parseInt(string,base)</code>,string按base数制转换规则转换,可以识别八进制和十六进制前缀</p><p><code>parseFloat(string)</code>,始终忽略前导0,所以不能识别十六进制与八进制前缀</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>特殊字符字面量</p><ul><li><code>\n</code> 换行</li><li><code>\r</code> 回车</li><li><code>\t</code> 制表</li><li><code>\b</code> 退格</li><li><code>\\</code> \</li><li><code>\&#39;</code> 单引号</li><li><code>\&quot;</code> 双引号</li><li><code>\xnn</code> 十六进制代码nn代表的一个字符</li><li><code>\unnnn</code> 十六进制代码nnnn代表的一个Unicode字符</li></ul><h4 id="toString-base-方法-String"><a href="#toString-base-方法-String" class="headerlink" title="toString(base)方法,String()"></a>toString(base)方法,String()</h4><p>Number,Boolean,Object,String都有toString()方法,Null和Undefined没有.</p><p>在不确定值是否是Null或Undefined的情况下,可以使用String()转换,可以输出’null’与’undefined’</p><p>如果在把num.toString(base),传入base值,可按固定base数制输出</p><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>任何Object的实例都具有下述方法</p><ul><li><code>obj.constructor</code> 保存用于创建当前对象的函数</li><li><code>obj.hasOwnProperty(propertyName)</code> 用于检测给定属性在当前实例中(不包含原型链中)是否存在</li><li><code>obj.isPrototypeOf(obj2)</code> 用于检查obj是否在obj2的原型链上</li><li><code>obj.propertyIsEnumerable(propertyName)</code> 用于检查给定属性是否可枚举</li><li><code>toLocaleString()</code> </li><li><code>toString()</code></li><li><code>valueOf()</code> 返回对象的字符串,数值,或布尔值表示,通常与toString()返回值相同</li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h4 id="逻辑非运算结果"><a href="#逻辑非运算结果" class="headerlink" title="逻辑非运算结果"></a>逻辑非运算结果</h4><ul><li><code>!obj</code> false</li><li><code>!&quot;&quot;</code> true</li><li><code>!&quot; &quot;</code> false</li><li><code>!0</code> true</li><li><code>!Infinity</code> false</li><li><code>!NaN</code> true</li><li><code>!null</code> true</li><li><code>undefined</code> true</li></ul><p>这里附上刚才写的<code>Boolean(x)</code>的结果</p><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">“”空字符串</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">任何对象除了null</td><td style="text-align:center">true</td></tr></tbody></table><h1 id="引用类型-第五章"><a href="#引用类型-第五章" class="headerlink" title="引用类型(第五章)"></a>引用类型(第五章)</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray(arr) return boolean</code> 用于检测arr是不是数组</p><p>arr instanceof Array虽然也能返回一个boolean值判断Array.prototoype在不在arr的原型链上, 但若网络中存在多个不同的执行环境, arr可能来自于不同执行环境中的不同构造函数,这个判断可能会出错, 所以建议用Arr.isArray()</p><h3 id="数组的toString-与valueOf"><a href="#数组的toString-与valueOf" class="headerlink" title="数组的toString()与valueOf()"></a>数组的toString()与valueOf()</h3><p><code>arr.toString()</code>,<code>arr.valueOf()</code>返回相同的值, 后者实际上调用了前者, 输出的都是与<code>arr.split(&#39;,&#39;)</code>一样的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组 </span></span><br><span class="line">alert(colors.toString()); <span class="comment">// red,blue,green </span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure><h3 id="arr-sort"><a href="#arr-sort" class="headerlink" title="arr.sort()"></a>arr.sort()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 1,10,2,3</span></span><br></pre></td></tr></table></figure><p>产生上述结果的原因是如果sort方法不传参数默认先调用<code>arr.toString()</code>,再调用<code>arr.sort</code></p><p>向<code>arr.sort</code>传回调函数可解决此问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b <span class="comment">// 升序,降序b-a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆: a,b相当于数组相邻的两个值, a-b降序, b-a升序</span></span><br></pre></td></tr></table></figure><h3 id="arr-reduce-arr-reduceRight"><a href="#arr-reduce-arr-reduceRight" class="headerlink" title="arr.reduce(), arr.reduceRight"></a>arr.reduce(), arr.reduceRight</h3><p><code>arr.reduce(callback[, initialValue]) return sum</code></p><ul><li><p>callback</p><ul><li>accumulator 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。</li><li>currentValue 数组中正在处理的元素。</li><li>currentIndex 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。</li><li>array 调用reduce的数组</li></ul></li><li><p>initialValue [可选] 归并基础值,就是return回去的值,不传即是数组的第一个元素  </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum + value;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// total is 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><code>arr.reduceRight</code>与<code>arr.reduce</code>都是一个套路,只不过reduceRight是从数组最后一项往前,reduce是从第一项往后.</p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><h3 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h3><p><code>var now = new Date()</code></p><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse"></a>Date.parse</h3><p>传达日期格式,用作<code>new Date()</code>的回调函数,具体有几种格式,详细请参阅高程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>); <span class="comment">//用表示日期的字符串传递给Date构造函数,会在后台自动调用Date.parse()</span></span><br></pre></td></tr></table></figure><p><code>Date.UTC()</code>也能做类似的事,但格式和<code>Date.parse()</code>不同,详细请参阅高程</p><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p><code>Date.now()</code>简化上述转换操作直接返回一个毫秒数,在不支持它的浏览器中,使用<code>+new Date()</code> </p><h3 id="Date的toLocalString-toString-ValueOf"><a href="#Date的toLocalString-toString-ValueOf" class="headerlink" title="Date的toLocalString(),toString() ValueOf()"></a>Date的toLocalString(),toString() ValueOf()</h3><blockquote><p>很明显,这三个方法都没啥用</p></blockquote><p><code>date.tolocalString()</code>会按照与浏览器 设置的地区相适应的格式返回日期和时间,不同浏览器差别大</p><p><code>date.toString()</code>通常返回带有时区信息的日期和 时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示</p><p><code>date.valueOf()</code> 返回毫秒显示</p><h3 id="Date的组件方法"><a href="#Date的组件方法" class="headerlink" title="Date的组件方法"></a>Date的组件方法</h3><p><img src="https://i.loli.net/2017/12/19/5a38081a34f0e.jpg" alt=""></p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p><a href="https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin" target="_blank" rel="external">正则表达式符号,百度百科跳转</a></p><h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 使用RegExp构造函数，接收两个参数：要匹配的字符串模式，可选的标志字符串。</span></span><br><span class="line"><span class="comment">// var pattern1 = /[bc]at/i;</span></span><br><span class="line"><span class="comment">// 注意若使用了元字符作为正则表达式普通字符, 要进行双重转义</span></span><br><span class="line"><span class="comment">// 例,用来匹配字符串'[',第一次转义为了将元字符转化为普通字符'\['</span></span><br><span class="line"><span class="comment">// 第二次为了将'/n'字符转化为构造函数参数字符串'\\[')</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul><li>g: 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li><li>i: 表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li><li>m: 表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 匹配字符串中所有"at"的实例 */</span> </span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配第一个"bat"或"cat"，不区分大小写 */</span> </span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* * 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写 */</span> </span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure><p>正则表达式所有元字符都必须转义,元字符包括</p><p><code>( [ { \ ^ $ | ) ? * + .]}</code></p><h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p><code>RegExp</code>的每个实例都具有下列属性,通过这些属性可以取得有关模式的各种信息</p><ul><li><code>global</code>: 布尔值，表示是否设置了 g 标志。</li><li><code>ingoreCase</code>: 布尔值，表示是否设置了 i 标志。</li><li><code>lastIndex</code>: 整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li><li><code>multiline</code>: 布尔值，表示是否设置了 m 标志。</li><li><code>source</code>: 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line">    </span><br><span class="line">alert(pattern1.global);     <span class="comment">//false</span></span><br><span class="line">alert(pattern1.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern1.multiline);  <span class="comment">//false</span></span><br><span class="line">alert(pattern1.lastIndex);  <span class="comment">//0</span></span><br><span class="line">alert(pattern1.source);     <span class="comment">//"\[bc\]at"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line"></span><br><span class="line">alert(pattern2.global);     <span class="comment">//false</span></span><br><span class="line">alert(pattern2.ignoreCase); <span class="comment">//true</span></span><br><span class="line">alert(pattern2.multiline);  <span class="comment">//false</span></span><br><span class="line">alert(pattern2.lastIndex);  <span class="comment">//0</span></span><br><span class="line">alert(pattern2.source);     <span class="comment">//"\[bc\]at"</span></span><br></pre></td></tr></table></figure><h3 id="reg-exec"><a href="#reg-exec" class="headerlink" title="reg.exec()"></a>reg.exec()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"帅,不是一般的帅,也不是外在的帅,也不是内在的帅"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/帅/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure><p>该方法每次匹配成功会改变正则表达式实例对象的lastIndex属性,下次搜索从lastIndex开始</p><p><img src="https://i.loli.net/2017/12/19/5a38081a1df77.jpg" alt=""></p><blockquote><p>此方法还能匹配不同的捕获组,从而形成result[1],result[2],关于捕获组有关例子,具体看高程</p></blockquote><h3 id="reg-test"><a href="#reg-test" class="headerlink" title="reg.test()"></a>reg.test()</h3><p><code>reg.text(str) return boolean</code>,嗯,就这样.</p><h3 id="reg-toLocaleString-reg-toString-valueOf"><a href="#reg-toLocaleString-reg-toString-valueOf" class="headerlink" title="reg.toLocaleString(),reg.toString(),valueOf()"></a>reg.toLocaleString(),reg.toString(),valueOf()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>); </span><br><span class="line">alert(pattern.toString()); <span class="comment">// /\[bc\]at/gi </span></span><br><span class="line">alert(pattern.toLocaleString()); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure><p>正则表达式的valueOf()方法返回正则表达式本身</p><h3 id="regExp构造函数属性"><a href="#regExp构造函数属性" class="headerlink" title="regExp构造函数属性"></a>regExp构造函数属性</h3><p>RegExp 构造函数包含一些属性（静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独 特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名(短属性名需要通过方括号方式访问)</p><p><img src="https://i.loli.net/2017/12/19/5a38081a07454.jpg" alt=""></p><p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语 法是 RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在 调用 exec()或 test()方法时</p><blockquote><p>一看就用的不多,具体demo看高程p108</p></blockquote><p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语 法是 RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在 调用 exec()或 test()方法时被改变</p><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="使用Function构造函数创建函数"><a href="#使用Function构造函数创建函数" class="headerlink" title="使用Function构造函数创建函数"></a>使用Function构造函数创建函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="comment">// 最后一个字符串是函数体,前面是参数,接收变量名是函数名</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123; <span class="keyword">return</span> num1 + num2; &#125;;</span><br></pre></td></tr></table></figure><h3 id="内部属性arguments"><a href="#内部属性arguments" class="headerlink" title="内部属性arguments"></a>内部属性arguments</h3><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>指向拥有arguments对象的函数,即自己</p><h3 id="内部属性this"><a href="#内部属性this" class="headerlink" title="内部属性this"></a>内部属性this</h3><p>函数执行的环境对象,网页全局window</p><h3 id="内部属性caller"><a href="#内部属性caller" class="headerlink" title="内部属性caller"></a>内部属性caller</h3><p>这个属性中保存着调用当前函数的函数的引用,不能被赋值,否则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller) <span class="comment">// 显示outer函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数实例属性和方法"><a href="#函数实例属性和方法" class="headerlink" title="函数实例属性和方法"></a>函数实例属性和方法</h3><h4 id="函数实例属性length"><a href="#函数实例属性length" class="headerlink" title="函数实例属性length"></a>函数实例属性length</h4><p>表示函数希望接收的命名参数的个数</p><h4 id="函数实例属性prototype"><a href="#函数实例属性prototype" class="headerlink" title="函数实例属性prototype"></a>函数实例属性prototype</h4><p>不可枚举,<code>for-in</code>无法发现</p><h4 id="函数实例方法call-apply-bind"><a href="#函数实例方法call-apply-bind" class="headerlink" title="函数实例方法call,apply,bind"></a>函数实例方法call,apply,bind</h4><p><code>func.apply(this[,arr])</code> === <code>this.func(...arr)</code></p><p><code>func.call(this[,arg1,arg2,arg3])</code> === <code>this.func(arg1,arg2,arg3)</code></p><p><code>func.bind(this) return newFunc</code></p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>包含Boolean,Number,String三种,与其他引用类型相似,但同时也具有与各自基本类型相应的特殊行为</p><p>在需要时执行类似下列过程: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// js内部执行的方法</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>); <span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>); <span class="comment">// 调用方法</span></span><br><span class="line"> s1 = <span class="literal">null</span>; <span class="comment">//销毁实例</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>; </span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><h3 id="基本包装Boolean类型"><a href="#基本包装Boolean类型" class="headerlink" title="基本包装Boolean类型"></a>基本包装Boolean类型</h3><blockquote><p>永远不要使用Boolean对象,坑多.具体见高程p120</p></blockquote><h3 id="基本包装Number类型"><a href="#基本包装Number类型" class="headerlink" title="基本包装Number类型"></a>基本包装Number类型</h3><blockquote><p>与Boolean类型一样,不建议用Number()构造函数直接实例化Number()类型</p></blockquote><h4 id="num-toFiexed-args"><a href="#num-toFiexed-args" class="headerlink" title="num.toFiexed(args)"></a>num.toFiexed(args)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFiexed(<span class="number">2</span>)) <span class="comment">//10.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toFixed(<span class="number">2</span>)) <span class="comment">//10.01,能够自动舍入</span></span><br></pre></td></tr></table></figure><h4 id="num-toExponential-args"><a href="#num-toExponential-args" class="headerlink" title="num.toExponential(args)"></a>num.toExponential(args)</h4><p>返回指数表示法,接收一个参数,指定输出结果中的小数位数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>)) <span class="comment">// 1.0e+1</span></span><br></pre></td></tr></table></figure><h4 id="num-toPrecision-args"><a href="#num-toPrecision-args" class="headerlink" title="num.toPrecision(args)"></a>num.toPrecision(args)</h4><p>根据所传的num和args,智能调用上面的<code>num.toFixed(args)</code>或<code>num.toExponential(args)</code>方法,总是返回最准确的值</p><h3 id="基本包装String类型"><a href="#基本包装String类型" class="headerlink" title="基本包装String类型"></a>基本包装String类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><h4 id="str-length"><a href="#str-length" class="headerlink" title="str.length"></a>str.length</h4><p>表示字符串长度</p><h4 id="str-index"><a href="#str-index" class="headerlink" title="str[index]"></a>str[index]</h4><p>ES5定义的访问个别字符的方法,使用类数组的访问方式</p><h4 id="String实例方法"><a href="#String实例方法" class="headerlink" title="String实例方法"></a>String实例方法</h4><ul><li><code>str.charAt(index) return char</code></li><li><code>str.charCodeAt(index) return charCode</code></li><li><code>str.concat(str1) return newStr</code></li><li><code>str.slice(start[,end]) return newStr</code></li><li><code>str.subString(start[,end]) return newStr</code> 与slice的区别是end不能是负值,但还有些细节,具体看高程p124</li><li><code>str.substr(start[,num]) return newStr</code></li><li><code>str.indexOf(str1[,index]) return index/-1</code></li><li><code>str.lastIndexOf(str1[,index]) return index/-1</code></li><li><code>str.trim()</code></li><li><code>toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()</code> 推荐用带Locale的替换不带Locale的,有些语言会出问题</li><li><code>str.split(str1/regExp) return arr</code> 当参数是regExp时看mdn相关说明或高程p128</li></ul><blockquote><p>下面两个方法有些冷门</p></blockquote><ul><li><code>str.localeCompare(str1) return 1/0/-1</code> 比较str1和str1的字母表顺序,若str1排在前,返回+1,以此类推</li><li><code>String.fromCharCode(104,101,108,108,111) return &#39;hello&#39;</code> 静态方法,接受字符编码,返回字符串</li></ul><h4 id="String实例的模式匹配方法"><a href="#String实例的模式匹配方法" class="headerlink" title="String实例的模式匹配方法"></a>String实例的模式匹配方法</h4><ul><li><code>str.match(str1/regExp) return arr</code> 是<code>regExp.exec(str)</code>的逆方法,输出一模一样</li><li><code>str.search(str1/regExp) return index/-1</code> 是str.match的变更版本,不返回数组了,返回第一次出现的索引.</li><li><code>str.replace(regExp/string,replacement) return newStr</code> //若regExp设置g属性则替换全部,replacement除了是str还可以是function,具体看高程p128</li></ul><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>由ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了.意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了. 之前介绍的Object,Array,String等都是这样.</p><p>下面说两个单体内置对象Global和Math</p><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>isNaN()、isFinite()、parseInt()以及 parseFloat() 都是Global对象的方法,没处归类的方法都是他的.</p><h4 id="Global对象的属性"><a href="#Global对象的属性" class="headerlink" title="Global对象的属性"></a>Global对象的属性</h4><p>Global 对象还包含一些属性， 其中一部分属性已经在本书前面介绍过了。 例如，特殊的值 undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和 Function，也都是 Global 对象的属性。下表列出了 Global 对象的所有属性。</p><p><img src="https://i.loli.net/2017/12/19/5a38081a2a5a9.jpg" alt=""></p><h4 id="URI方法"><a href="#URI方法" class="headerlink" title="URI方法"></a>URI方法</h4><p>Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。</p><p>有效的 URI 中不能包含某些字符，例如 空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符， 从而让浏览器能够接受和理解。</p><p>其中，<code>encodeURI()</code>主要用于整个 URI（例如，<a href="http://www.wrox.com/illegal" target="_blank" rel="external">http://www.wrox.com/illegal</a> value.htm），而 <code>encodeURIComponent()</code>主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm）进行编码。 它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而 <code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码。来看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>encodeURIComponent()</code>要比使用 <code>encodeURI()</code>更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</p></blockquote><p>对应解码方法是 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code>，<code>decodeURI()</code>只能对使用 <code>encodeURI()</code>替换的字符进行解码。它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号（#），而井字号不是使用<code>encodeURI()</code>替换的。同样地，<code>decodeURIComponent()</code>能够解码使用 <code>encodeURIComponent()</code>编码</p><blockquote><p>URI 方法 encodeURI()、encodeURIComponent()、decodeURI()和 decodeURIComponent()用于替代已经被 ECMA-262第 3版废弃的 escape()和 unescape() 方法。URI 方法能够编码所有 Unicode 字符，而原来的方法只能正确地编码 ASCII 字符。 因此在开发实践中，特别是在产品级的代码中，一定要使用 URI 方法，不要使用 escape() 和 unescape()方法。</p></blockquote><h4 id="eval方法"><a href="#eval方法" class="headerlink" title="eval方法"></a>eval方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eval内部定义的变量和函数没有变量提升,外部访问不到</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; alert('hi'); &#125;"</span>); </span><br><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'; "</span>); </span><br><span class="line">alert(msg); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure><p>当解析器发现代码中调用 <code>eval()</code>方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。通过 <code>eval()</code>执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 <code>eval()</code>执行的代码可以引用在包 含环境中定义的变量</p><p>在<code>eval()</code>中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 <code>eval()</code>执行的时候创建。</p><p>严格模式下，在外部访问不到 <code>eval()</code>中创建的任何变量或函数，没有提升,没有变量声明,所以会导致错误。 同样，在严格模式下，为 eval 赋值也会导致错误</p><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>在浏览器环境中,<code>window</code>对象就是<code>Global</code>对象,</p><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4><p><img src="https://i.loli.net/2017/12/19/5a38081a29ecb.jpg" alt=""></p><h4 id="Math-min-Math-max"><a href="#Math-min-Math-max" class="headerlink" title="Math.min(),Math.max()"></a>Math.min(),Math.max()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">alert(max);    <span class="comment">//54</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">alert(min);    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求数组的最大值</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]; </span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure><h4 id="Math-ceil-、Math-floor-和-Math-round-Math-Random"><a href="#Math-ceil-、Math-floor-和-Math-round-Math-Random" class="headerlink" title="Math.ceil()、Math.floor()和 Math.round(),Math.Random()"></a>Math.ceil()、Math.floor()和 Math.round(),Math.Random()</h4><ul><li><code>Math.ceil()</code></li><li><code>Math.floor()</code></li><li><code>Math.round()</code> 总是将数值四舍五入为最接近的整数</li><li><code>Math.random()</code> 返回一个大于等于0小于1的一个随机数</li></ul><p><code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code> ,范围公式</p><p>范围工具函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Math的其他方法"><a href="#Math的其他方法" class="headerlink" title="Math的其他方法"></a>Math的其他方法</h4><p><img src="https://i.loli.net/2017/12/19/5a38081a36443.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念-第三章&quot;&gt;&lt;a href=&quot;#基本概念-第三章&quot; class=&quot;headerlink&quot; title=&quot;基本概念(第三章)&quot;&gt;&lt;/a&gt;基本概念(第三章)&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vuex 03 : 代码拆分 &amp; mapAnything</title>
    <link href="http://yoursite.com/2017/12/06/12-Vuex-03/"/>
    <id>http://yoursite.com/2017/12/06/12-Vuex-03/</id>
    <published>2017-12-06T08:06:45.000Z</published>
    <updated>2017-12-20T03:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mapActions-mapGetters-mapMutations"><a href="#mapActions-mapGetters-mapMutations" class="headerlink" title="mapActions,mapGetters,mapMutations"></a>mapActions,mapGetters,mapMutations</h3><p>map系列函数能帮我们用更简洁的语法将store.actions,mutations,getters绑定到组件中, 是很好的语法糖. 这里以<code>mapGetters</code>举例,剩下剩下两个也是一个套路.</p><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性, 可以向方法中传一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回到本例,我们可以修改代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">"oddOrEven"</span>])</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([<span class="string">"increment"</span>, <span class="string">"decrement"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件拆分"><a href="#文件拆分" class="headerlink" title="文件拆分"></a>文件拆分</h3><p>接下来将文件拆分:</p><ol><li>将所有与store相关的方法移到store.js中, </li><li>将Counter组件提出称为单文件组件Counter.vue</li><li>将store.js与Counter.vue一起import进入口文件index.js,并在入口的根实例中绑定store</li></ol><p>测试一下,完成! 下面是分文件的完整代码</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><hr><h3 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用常量替代字符串</span></span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">// getter方法的第一个参数是state,第二个参数是getters对象</span></span><br><span class="line">  oddOrEven(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">// ES6计算属性写法,来命名函数名,payload是组件内部提交的&#123;type:string,step:string&#125;的对象</span></span><br><span class="line">  [INCREMENT](state, payload) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.count += payload.step</span><br><span class="line">  &#125;,</span><br><span class="line">  [DECREMENT](state, payload) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state.count -= payload.step</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// 用action将mutation包一层,把触发mutation的逻辑写在action中</span></span><br><span class="line">  increment(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="comment">// 对象风格提交方式提交mutation, 与Redux统一</span></span><br><span class="line">    commit(&#123; <span class="attr">type</span>: INCREMENT, <span class="attr">step</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// action可以是异步的,可以用Promise包装</span></span><br><span class="line">  decrement(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(&#123; <span class="attr">type</span>: DECREMENT, <span class="attr">step</span>: <span class="number">1</span> &#125;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Counter-vue"><a href="#Counter-vue" class="headerlink" title="Counter.vue"></a>Counter.vue</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; $store.state.count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="increment"&gt; + &lt;/</span>button&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">"decrement"</span>&gt; - (Async) &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import Vue from "vue";</span></span><br><span class="line"><span class="regexp">import &#123; mapActions, mapGetters &#125; from "vuex";</span></span><br><span class="line"><span class="regexp">export default Vue.component("Counter", &#123;</span></span><br><span class="line"><span class="regexp">  computed: &#123;</span></span><br><span class="line"><span class="regexp">    ...mapGetters(["oddOrEven"])</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    ...mapActions(["increment", "decrement"])</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>至此, 我们已经完成了一个具备大多数Vuex功能的counter, 当然Vuex可以做的事比这个例子更多, 比如Module模块分割和路径管理等. 但都是在这个基础上进行改动的. 相信看文档与实际项目结合,接受的会很快</p><p>其实Flux架构的大体思路都差不多, 单向数据流, 视图触发<code>dispatch</code>一个<code>action</code>, 从而修改<code>store</code>中的<code>state</code>, View层监视到<code>state</code>的修改从而更新数据触发渲染. 不管是Vuex还是Redux都是一个套路. 希望从这几篇blog的总结中, 我自己可以有收获!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mapActions-mapGetters-mapMutations&quot;&gt;&lt;a href=&quot;#mapActions-mapGetters-mapMutations&quot; class=&quot;headerlink&quot; title=&quot;mapActions,mapGetters,ma
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vuex 02 : 基于Getter, Mutation, Action,继续改造Demo</title>
    <link href="http://yoursite.com/2017/12/06/11-vuex-02/"/>
    <id>http://yoursite.com/2017/12/06/11-vuex-02/</id>
    <published>2017-12-06T00:25:08.000Z</published>
    <updated>2017-12-20T03:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过上篇的旅程, 已经可以做出一个有Vuex基本功能的Counter了. 为了让Counter的逻辑更完善, 今天引入Getter, Mutation, Action 来继续优化代码</p><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>在本例中,将count是奇书还是偶数的逻辑写在getter中.</p><p>Getter接收<code>state</code>作为第一个参数,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">  <span class="comment">// getter方法的第一个参数是state,第二个参数是getters对象</span></span><br><span class="line">  oddOrEven(state)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件内部的写法,这里getter会暴露为Store.getters对象, 同时getter也接收getters对象本身作为第二个参数, 这样可以接受其他getter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  count()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">  &#125;,</span><br><span class="line">  oddOrEven()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.oddOrEven</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>在Vuex里,提交状态需要用到<code>mutation</code>与<code>action</code>,<code>action</code>更像在mutation外面包了一层, 类似Redux中的<code>action creater</code>产生<code>action</code>一样, 在Vuex里, <code>mutation</code>只保留最原始的逻辑, 操作state中的数据, 其他commit mutation的逻辑和异步操作交给<code>action</code>去处理.</p><p>所以,异步和其他逻辑处理交给<code>action</code>,所以<code>mutation</code>必须是同步的</p><p><code>mutation</code>的类型最好用常量去代替, 这点也与Redux等Flux架构相统一, 可以使用ES6的计算属性优化常量作为函数名的写法.</p><p>提交mutation的唯一方式是<code>store.commit(mutation)</code>,这里可以在<code>commit mutation</code>时附加提交数据<code>payload</code>,习惯写成对象的提交方式如<code>{type:INCREMENT,step:1}</code>,这个对象在store定义时的<code>mutation</code>方法中是第二个参数, 写成<code>payload</code>是很好的社区规范.这里用step来定义 counter 加减的跨度</p><p>总结一下,如下改写mutation:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations:&#123;</span><br><span class="line">  <span class="comment">// ES6计算属性写法,来命名函数名,payload是组件内部提交的&#123;type:string,step:string&#125;的对象</span></span><br><span class="line">  [INCREMENT](state,payload)&#123;</span><br><span class="line">    <span class="keyword">this</span>.state.count += payload.step</span><br><span class="line">  &#125;,</span><br><span class="line">  [DECREMENT](state,payload)&#123;</span><br><span class="line">    <span class="keyword">this</span>.state.count -= payload.step</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件内提交时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>action</code>是在<code>mutation</code>外包的一层方法, 用来定义触发<code>commit mutation</code>的逻辑, 更主要的是异步逻辑.</p><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters</p><p>实践中，我们会经常用到 ES6的解构赋值来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Action 通过 store.dispatch 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在在dispatch时可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另一个action内也可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到本例,将提交mutation的逻辑全部移入action,将做减法的逻辑改成异步,1秒以后执行,代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store配置内</span></span><br><span class="line">actions:&#123;</span><br><span class="line">    <span class="comment">// 用action将mutation包一层,把触发mutation的逻辑写在action中</span></span><br><span class="line">    [INCREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="comment">// 对象风格提交方式提交mutation, 与Redux统一</span></span><br><span class="line">      commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// action可以是异步的,可以用Promise包装</span></span><br><span class="line">    [DECREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          commit(&#123;<span class="attr">type</span>:DECREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 组件methods内</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  increment()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(INCREMENT) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//store.dispatch可以处理被触发的action的处理函数返回的promiste,dispatch仍旧返回Promise</span></span><br><span class="line">  decrement()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(DECREMENT).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Async deduct works!'</span>)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://i.loli.net/2017/12/06/5a27a4aade6b2.jpg" alt=""></p><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用常量替代字符串</span></span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'INCREMENT'</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'DECREMENT'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    count:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;</span><br><span class="line">    <span class="comment">// getter方法的第一个参数是state,第二个参数是getters对象</span></span><br><span class="line">    oddOrEven(state)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    <span class="comment">// ES6计算属性写法,来命名函数名,payload是组件内部提交的&#123;type:string,step:string&#125;的对象</span></span><br><span class="line">    [INCREMENT](state,payload)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count += payload.step</span><br><span class="line">    &#125;,</span><br><span class="line">    [DECREMENT](state,payload)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count -= payload.step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">    <span class="comment">// 用action将mutation包一层,把触发mutation的逻辑写在action中</span></span><br><span class="line">    [INCREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="comment">// 对象风格提交方式提交mutation, 与Redux统一</span></span><br><span class="line">      commit(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// action可以是异步的,可以用Promise包装</span></span><br><span class="line">    [DECREMENT](&#123;commit&#125;)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          commit(&#123;<span class="attr">type</span>:DECREMENT,<span class="attr">step</span>:<span class="number">1</span>&#125;)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="increment"&gt; + &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="decrement"&gt; - (Async) &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    oddOrEven()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.oddOrEven</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(INCREMENT) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//store.dispatch可以处理被触发的action的处理函数返回的promiste,dispatch仍旧返回Promise</span></span><br><span class="line">    decrement()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(DECREMENT).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Async deduct works!'</span>)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">  components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在, 我们已经完成了一个符合Vuex规范的Counter, 其可以完美的运行和异步处理数据, 下一次将会对代码进行拆分解耦, 并在组件内部优化action与getter的部署代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过上篇的旅程, 已经可以做出一个有Vuex基本功能的Counter了. 为了让Counter的逻辑更完善, 今天引入Getter, Mutation, Action 来继续优化代码&lt;/p&gt;
&lt;h3 id=&quot;Getter&quot;&gt;&lt;a href=&quot;#Getter&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vuex 01 : 入门</title>
    <link href="http://yoursite.com/2017/12/05/10-vuex-01/"/>
    <id>http://yoursite.com/2017/12/05/10-vuex-01/</id>
    <published>2017-12-05T00:18:36.000Z</published>
    <updated>2017-12-06T09:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前学习了Redux, 这次学Vuex就快速多了, 总的来说思路是一样的, 都是用闭包实现了对一些数据的维护, 再用从闭包return出去的方法操作这些数据, 或获得此时闭包数据的snapshot. </p><h3 id="Vuex-安装"><a href="#Vuex-安装" class="headerlink" title="Vuex 安装"></a>Vuex 安装</h3><p>在一个模块化的打包系统中，您必须显式地通过 <code>Vue.use()</code> 来安装 Vuex：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>当使用script标签引入时, 不需要以上过程.</p><h3 id="什么是状态管理-单向数据流的意义"><a href="#什么是状态管理-单向数据流的意义" class="headerlink" title="什么是状态管理? 单向数据流的意义"></a>什么是状态管理? 单向数据流的意义</h3><p><img src="https://i.loli.net/2017/12/05/5a25e7c210411.jpg" alt=""></p><p>状态自管理应用包含以下几个部分：</p><ul><li><strong>state</strong>，驱动应用的数据源；</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><p>简单来说, 就是app维护一个State库, 将很多组件需要共同使用的状态存储在这个库中, 上图的动作可以分解为几个步骤.</p><ol><li><p>需要使用到其中状态数据的组件, 通过<code>State</code>向其传递的<code>props</code>向<code>View</code>层展示数据, </p></li><li><p>在View层操作数据之后, 通过<code>dispatch</code>相应的<code>action</code>修改<code>state</code>中维护的闭包数据,</p></li><li><p>闭包中的数据改变后, 在<code>dispatch</code>方法中, 操作数据得到个更新后的<code>State</code>后, 调用<code>listener</code>数组中的方法, 通知<code>View</code>层更新数据, 这里回到步骤1, <code>View</code>层再次请求<code>State</code>向其传递的<code>props</code></p></li></ol><p>与<strong>后台API接口</strong>结合后, 用vuex官网更形象更具体的图来描述这个过程</p><p><img src="https://i.loli.net/2017/12/06/5a27396e59fd9.png" alt=""></p><h3 id="Vuex-Counter-最初形态"><a href="#Vuex-Counter-最初形态" class="headerlink" title="Vuex Counter 最初形态"></a>Vuex Counter 最初形态</h3><p>具体上简单的代码来实现以下刚才说的东西</p><p>我们采用vue-cli构建,首先来写一个最简单的vue计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="Increase"&gt; + &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="Decrease"&gt; - (Async) &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    oddOrEven()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    Increase()&#123;</span><br><span class="line">      <span class="keyword">this</span>.count ++</span><br><span class="line">    &#125;,</span><br><span class="line">    Decrease()&#123;</span><br><span class="line">      <span class="keyword">this</span>.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">  components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/12/06/5a27396e6a067.jpg" alt=""></p><p>此时的计数器是完全没有应用状态管理技术的, 虽然引入了vuex.js, 但没有使用, 计数的count完全来自组件内部的data对象.下面要一步步的把他改造成应用状态管理vuex的组件</p><h3 id="创建store-在组件内部引入store-state和store-commit-实现最简单的vuex功能"><a href="#创建store-在组件内部引入store-state和store-commit-实现最简单的vuex功能" class="headerlink" title="创建store,在组件内部引入store.state和store.commit,实现最简单的vuex功能"></a>创建store,在组件内部引入store.state和store.commit,实现最简单的vuex功能</h3><p><code>store</code>就是一个仓库, 是一个容器, 是一个闭包, <code>store</code>中维护者组件中需要的<code>state</code>数据, 和触发这些数据更改的方法</p><p><code>store</code>的存储状态应该是响应式的, 所以最佳实践是<code>store.state</code>中的状态数据通过计算属性返回</p><p>在Vue组件中, 不能直接改变<code>store.state</code>, 只能<code>store.commit(相应的mutation)</code>来改变数据</p><p><code>mutations</code>对象中的键对应的是函数, 其第一个参数是<code>state</code>,在组件内部的<code>methods</code>中,可以在方法内部调用<code>store.commit(mutation)</code>来对应触发<code>store</code>中定义的<code>mutation</code>, 从而修改<code>store.state</code>中的数据</p><p><code>mutation</code>有点像<code>Redux</code>中的<code>action</code>, 不带异步的<code>action</code>, 但不是<code>action creater</code>, 在Vuex中, 有<code>Action</code>更像Redux中的<code>action creater</code>, 这个会在后面进行讨论</p><p>下面把之前的Counter代码修改一下, 让它具备基本的Vuex功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="comment">// 在构建中使用Vuex中间件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    count:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    <span class="comment">// mutation的第一个参数对应store.state</span></span><br><span class="line">    increment(state)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(state)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="increment"&gt; + &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="decrement"&gt; - (Async) &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">      <span class="comment">// 由于要保证store.state数据的响应式, 用计算属性返回state中的数据值</span></span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    oddOrEven()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">      <span class="comment">// store.commit('对应的mutation名称'),这是提交mutation的方法</span></span><br><span class="line">      store.commit(<span class="string">'increment'</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    decrement()&#123;</span><br><span class="line">      store.commit(<span class="string">'decrement'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">  components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="根组件注入store-mapState辅助函数生成计算属性"><a href="#根组件注入store-mapState辅助函数生成计算属性" class="headerlink" title="根组件注入store, mapState辅助函数生成计算属性"></a>根组件注入store, mapState辅助函数生成计算属性</h3><p>继续改进代码.Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p><p>通过在根实例中注册 <code>store</code> 选项，该 <code>store</code> 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code>访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    count:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    increment(state)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement(state)&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123; count &#125;&#125; is &#123;&#123; oddOrEven &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="increment"&gt; + &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="decrement"&gt; - (Async) &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">      <span class="comment">// 这里因为根组件注入了store, 可以访问到this.$store对象了.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    oddOrEven()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'even'</span> : <span class="string">'odd'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    decrement()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'decrement'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 根组件处注入store, 子组件全部可以访问store中的状态数据</span></span><br><span class="line">  store,</span><br><span class="line">  template: <span class="string">'&lt;Counter/&gt;'</span>,</span><br><span class="line">  components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此, 根组件已经注入了在状态仓库store, this.$store在Vue组件内部可访问, 组件和视图间的数据传递和更新用Vuex实现.</p><p>下一篇, 主要说说关于computed属性中的Getter与和methods中的Mutation的改造.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为之前学习了Redux, 这次学Vuex就快速多了, 总的来说思路是一样的, 都是用闭包实现了对一些数据的维护, 再用从闭包return出去的方法操作这些数据, 或获得此时闭包数据的snapshot. &lt;/p&gt;
&lt;h3 id=&quot;Vuex-安装&quot;&gt;&lt;a href=&quot;#Vue
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React高阶组件(1):Intro</title>
    <link href="http://yoursite.com/2017/11/20/9-React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B61%20:%20Intro/"/>
    <id>http://yoursite.com/2017/11/20/9-React高阶组件1 : Intro/</id>
    <published>2017-11-20T00:03:53.000Z</published>
    <updated>2017-11-20T08:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引子-高阶函数"><a href="#引子-高阶函数" class="headerlink" title="引子,高阶函数"></a>引子,高阶函数</h3><p>收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello chotee'</span>)  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapped</span>(<span class="params"> fn </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wrapped'</span>)</span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">hello = wrapped(hello)</span><br><span class="line"></span><br><span class="line">hello() <span class="comment">// wrapped hello chotee</span></span><br></pre></td></tr></table></figure><p>容易出现混淆的一点是: 虽然在hello = wrapped(hello) 这句话执行之后, hello这个变量指向的函数发生了变化, 但传入wrapped闭包内部的hello却仍然是最初定义的hello, 并没有被改写. </p><p>原因是进入wrapped内部执行后, 形参fn重新指向了最初hello定义时所指向的地址, 且wrapped运行完成后由于闭包形成, 这个地址不会被释放. 所以虽然hello重新被赋值, 但传入的函数在闭包内部却不会随着赋值操作发生改变.</p><h3 id="简单的React高阶组件"><a href="#简单的React高阶组件" class="headerlink" title="简单的React高阶组件"></a>简单的React高阶组件</h3><p>高阶组件的定义类似高阶函数, 它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p><p>实现一个withHeader的高阶组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通React组件Hello</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;这是Hello组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 定义一个包裹函数,参数是传入的'要被包裹的组件',return一个'包裹着参数组件的高阶组件'</span></span><br><span class="line"><span class="regexp">function withHeader(Component) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    class HOC extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">      render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h1&gt;wrapped Header&lt;/</span>h1&gt;</span><br><span class="line">            &lt;Component &#123;...this.props&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 被withHeader包裹后的组件高阶组件HelloWithHeader</span></span><br><span class="line"><span class="regexp">const HelloWithHeader = withHeader(Hello)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;HelloWithHeader&gt;&lt;/</span>HelloWithHeader&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><ul><li>渲染结果</li></ul><p><img src="https://i.loli.net/2017/11/20/5a12442bbf77d.png" alt="Jietu20171120-105321"></p><ul><li>dom结构<br><img src="https://i.loli.net/2017/11/20/5a124442cdf6c.png" alt="Jietu20171120-105501"></li></ul><h3 id="关于上述代码的对象展开语法的注意点"><a href="#关于上述代码的对象展开语法的注意点" class="headerlink" title="关于上述代码的对象展开语法的注意点"></a>关于上述代码的对象展开语法的注意点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line"><span class="comment">// is equivalent to</span></span><br><span class="line">React.createElement(WrappedComponent, <span class="keyword">this</span>.props, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h3 id="ES7-装饰器写法"><a href="#ES7-装饰器写法" class="headerlink" title="ES7 装饰器写法"></a>ES7 装饰器写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里省略了和上面例子一模一样的withHeader函数的定义代码</span></span><br><span class="line"></span><br><span class="line">@withHeader <span class="comment">// @ withHeader 等同于写了 Hello = withHeader(Hello)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;这是Hello组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Hello&gt;&lt;/</span>Hello&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')); /</span><span class="regexp">/得到与上面同样结果</span></span><br></pre></td></tr></table></figure><h3 id="柯里化-组件参数"><a href="#柯里化-组件参数" class="headerlink" title="柯里化,组件参数"></a>柯里化,组件参数</h3><blockquote><p>柯里化 Curry<br>概念: 只传递函数的一部分参数来调用它,让它返回一个函数去处理剩下的参数<br>函数签名:func(params)(otherParams)<br>应用: 在React里,通过柯里化,通过传入不同的参数得到不同的高阶组件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求:在刚才的例子里, 在h1标签里输出传入的参数title,以这个需求改造withHeader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withHeader</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h1&gt;&#123;<span class="string">`包裹的是一个名字叫<span class="subst">$&#123;title&#125;</span>的组件`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Component &#123;...this.props&#125;&gt;&lt;/</span>Component&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 注意这里为了区分特意传入了小写'h'开头的'hello'参数</span></span><br><span class="line"><span class="regexp">@withHeader('hello')</span></span><br><span class="line"><span class="regexp">class Hello extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;这是Hello组件&lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><ul><li><p>渲染结果<br><img src="https://i.loli.net/2017/11/20/5a12502b3ffe1.png" alt="Jietu20171120-114530"></p></li><li><p>使用ES6写法可以更加简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withHeader = <span class="function">(<span class="params">title</span>) =&gt;</span> (Component) =&gt; (</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1&gt;&#123;<span class="string">`包裹的是一个名字叫<span class="subst">$&#123;title&#125;</span>的组件`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Component &#123;...this.props&#125;&gt;&lt;/</span>Component&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><p>高阶组件有两种常见的使用方式,第一种是属性代理,第二种是反向继承,直接上属性代理的示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将被包裹组件的props和新生成的props一起传递给被包裹的组件,称之为属性代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withHeader</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">          test : <span class="string">'HOC'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;wrapped Header&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Component &#123;...newProps &#125; &#123;...this.props&#125; &gt;&lt;/</span>Component&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">@withHeader</span></span><br><span class="line"><span class="regexp">class Hello extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;这是Hello组件&lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Hello&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>这种方式返回的React组件继承了被传入的组件，所以它能够访问到的区域、权限更多，相比属性代理方式，它更像打入组织内部，对其进行修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withHeader</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是高阶组件额外的生命周期'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="comment">// super([arguments]),调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// super.xxx,调用父类上的xxx方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render() </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@withHeader</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;这是Hello组件&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Hello&gt;&lt;/</span>Hello&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/28138664" target="_blank" rel="external">深入浅出React高阶组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引子-高阶函数&quot;&gt;&lt;a href=&quot;#引子-高阶函数&quot; class=&quot;headerlink&quot; title=&quot;引子,高阶函数&quot;&gt;&lt;/a&gt;引子,高阶函数&lt;/h3&gt;&lt;p&gt;收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>由 &quot;对象深拷贝&quot; 引发的思考</title>
    <link href="http://yoursite.com/2017/11/15/8-%E7%94%B1%22%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%22%E5%BC%95%E5%8F%91%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>http://yoursite.com/2017/11/15/8-由&quot;对象深拷贝&quot;引发的尝试/</id>
    <published>2017-11-15T00:03:53.000Z</published>
    <updated>2017-11-20T02:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天做什么"><a href="#今天做什么" class="headerlink" title="今天做什么?"></a>今天做什么?</h3><p>今天在用到<code>Object.assign</code>方法时,发现这个方法进行的是对象的浅拷贝. 借此契机复习一下浅拷贝与深拷贝的知识, 解决一些实际问题.</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>  首先说下<code>Object.assign</code>方法,这是一个es6方法, 可以用来合并对象,直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(a, b)</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// &#123; a:2,b:&#123;a:1,b:2&#125; &#125;</span></span><br></pre></td></tr></table></figure><p>但是在上述代码下面再加一行,将b对象b属性中a的值由1改成3,再打印c的值,得:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.b.a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// &#123; a:2,b:&#123;a:3,b:2&#125; &#125;</span></span><br></pre></td></tr></table></figure><p>可见,Object.assign中的拷贝,是浅拷贝. </p><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝?"></a>什么是浅拷贝?</h3><p>即在给对象赋值时 (比如本例中<code>Object.assign</code>方法要给对象c的b属性赋值为<code>b.b</code>的值<code>{a:1,b:2}</code>) , </p><p>只将另一个对象 (本例中的<code>b.b</code>)在内存栈中的引用传递了过去,并没有在堆中开辟新的空间用来存储一个新的对象<code>c.b</code>的值),</p><p>所以在后面例子中当<code>b.b</code>中的属性a改变时, 由于<code>c.b</code>与<code>b.b</code>指向了堆中的同一个地址, 导致<code>c.b.a</code>也发生了改变.</p><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝?"></a>什么是深拷贝?</h3><p>给对象赋值时,在堆中开辟新的空间用来存储对象的数据,形成新的地址传给栈,将要赋的值复制过来放在新的空间中. 这就是深拷贝</p><h3 id="浅拷贝的代码实现"><a href="#浅拷贝的代码实现" class="headerlink" title="浅拷贝的代码实现"></a>浅拷贝的代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">arr</span>: [<span class="number">2</span>,<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> shallowObj = shallowCopy(obj); <span class="comment">// &#123;a:1,arr[2:3]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      result[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shallowObj.arr[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">obj.arr[<span class="number">1</span>]   <span class="comment">// = 5</span></span><br></pre></td></tr></table></figure><p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址，大概的示意图如下。</p><p><img src="https://pic4.zhimg.com/50/v2-39761dfd012733879e0d100ec260a5d7_hd.jpg" alt="enter image description here"></p><p>而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。</p><p><img src="https://pic1.zhimg.com/50/6604224933c95787764d941432a1f968_hd.jpg" alt="enter image description here"></p><h3 id="深拷贝的代码实现"><a href="#深拷贝的代码实现" class="headerlink" title="深拷贝的代码实现"></a>深拷贝的代码实现</h3><p>简单的说就是”遇到复制对象就递归,一直到拷贝值,才进行拷贝”,因为进行对象属性的赋值运算时,会在堆内自动开辟空间存储值,从而实现深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">arr</span>: [<span class="number">2</span>,<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> deepObj = deepCopy(obj);</span><br><span class="line"></span><br><span class="line">deepObj.arr[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">obj.arr[<span class="number">1</span>]   <span class="comment">// = 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, start</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  start = start || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        start[i] = obj[i]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        start[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? []:&#123;&#125;</span><br><span class="line">        deepCopy(obj[i], start[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start[i] = obj[i]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="number">22</span>,</span><br><span class="line">    b: <span class="number">33</span>,</span><br><span class="line">    c: <span class="number">44</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="number">55</span>,</span><br><span class="line">  d: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  e: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="number">33</span>,</span><br><span class="line">    c: &#123;</span><br><span class="line">      a: <span class="number">44</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  e: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法,合并对象obj1,与obj2,要求输出</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a: 2,</span></span><br><span class="line"><span class="comment">//   b: &#123;</span></span><br><span class="line"><span class="comment">//     a: 33,</span></span><br><span class="line"><span class="comment">//     b: 33,</span></span><br><span class="line"><span class="comment">//     c: &#123;</span></span><br><span class="line"><span class="comment">//       a: 44</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   c: 55,</span></span><br><span class="line"><span class="comment">//   d: function () &#123;</span></span><br><span class="line"><span class="comment">//     return false</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   e: [1, 3, 5, 4, 5]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面这个面试题,比深拷贝复杂一点, 仔细分析需求, 发现在要拷贝的属性与原对象属性重名,且类型一样时,需要保留原对象属性的未修改字段,那么需要对前面的算法做一些修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeObj</span>(<span class="params">obj, start</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  start = start || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        start[i] = obj[i]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line"></span><br><span class="line">        start[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ?</span><br><span class="line">          <span class="comment">/* 如果原对象的[i]属性也是数组,则将原对象[i]属性对</span></span><br><span class="line"><span class="comment">          应的数组传入,否则传入一个空数组 */</span></span><br><span class="line">          ((start[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? start[i] : []) :</span><br><span class="line">          <span class="comment">/* 如果原对象的[i]属性也是对象,则将原对象[i]属性</span></span><br><span class="line"><span class="comment">          对应的对象传入,否则传入一个空对象 */</span></span><br><span class="line">          ((start[i] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) ? start[i] : &#123;&#125;)</span><br><span class="line">        deepCopy(obj[i], start[i])</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start[i] = obj[i]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mergeObj(obj1,obj2))</span><br></pre></td></tr></table></figure><h3 id="黑科技JSON直接进行深拷贝对象"><a href="#黑科技JSON直接进行深拷贝对象" class="headerlink" title="黑科技JSON直接进行深拷贝对象"></a>黑科技JSON直接进行深拷贝对象</h3><p>其实不涉及复杂的需求时,将一个对象深拷贝最简单的方式是用JSON.stringify直接转为字符串,然后用JSON.parse直接创建一个字面量对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天做什么&quot;&gt;&lt;a href=&quot;#今天做什么&quot; class=&quot;headerlink&quot; title=&quot;今天做什么?&quot;&gt;&lt;/a&gt;今天做什么?&lt;/h3&gt;&lt;p&gt;今天在用到&lt;code&gt;Object.assign&lt;/code&gt;方法时,发现这个方法进行的是对象的浅拷贝. 借此契
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redux 6: React Router 4 + Redux 数据流 模拟注册登录</title>
    <link href="http://yoursite.com/2017/11/14/7-React%20Router%204%20+%20Redux%20%E6%95%B0%E6%8D%AE%E6%B5%81%20%E6%A8%A1%E6%8B%9F%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2017/11/14/7-React Router 4 + Redux 数据流 模拟注册登录/</id>
    <published>2017-11-14T00:03:53.000Z</published>
    <updated>2017-12-20T03:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BEFORE"><a href="#BEFORE" class="headerlink" title="BEFORE"></a>BEFORE</h2><p>在Redux学习的三篇学习笔记之后,加上React-Router 4的学习,模拟了一个注册登录+计数器的Redux数据流</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js Provider,路由,根组件挂载处</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &#123;<span class="comment">/* Switch:命中第一个路由后不再继续跳转 */</span>&#125;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &#123;<span class="comment">/* Route匹配路由跳转路径与组件间的关系,exact开启精确匹配,不再继续向下查找 */</span>&#125;</span><br><span class="line">        &lt;Route path='/login' exact component=&#123;Auth&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route path='/dashboard' component=&#123;DashBoard&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &#123;<span class="comment">/* Redirect发起重定向 */</span>&#125;</span><br><span class="line">        &lt;Redirect to='/dashboard'&gt;&lt;/Redirect&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Auth.redux.js</span></span><br><span class="line"><span class="comment">// 权限登录的reducer与action creater</span></span><br><span class="line"><span class="comment">// isAuth代表是否登录</span></span><br><span class="line"><span class="keyword">const</span> LOGIN = <span class="string">'LOGIN'</span></span><br><span class="line"><span class="keyword">const</span> LOGOUT = <span class="string">'LOGOUT'</span></span><br><span class="line"><span class="comment">//reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AuthReducer = <span class="function">(<span class="params">state = &#123; isAuth: <span class="literal">false</span>, user: <span class="string">'choteewang'</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOGIN:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> LOGOUT:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//action creater</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGIN &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGOUT &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//myRedux.js</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'increase'</span></span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'decrease'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state  = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrease'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: INCREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: DECREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncreaseAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(onIncrease())</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reducer.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'./myRedux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AuthReducer &#125; <span class="keyword">from</span> <span class="string">'./Auth.redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 利用combineReducers合并两个Reducer</span></span><br><span class="line"><span class="comment">// 变为store中的state对象包裹2个reducer定义的state小对象的数据结构&#123;counter:&#123;&#125;,AutuReducer:&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 这里要注意改键名,防止之前使用小state的组件访问根组件state时key名发生错误</span></span><br><span class="line"><span class="comment">// 所以最佳实践是reducer要起名要有语义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;<span class="attr">counter</span>:reducer, <span class="attr">AuthReducer</span>:AuthReducer&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Auth.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; from <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;login&#125; from <span class="string">'./Auth.redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Redirect&#125; from <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    const redirect = &lt;Redirect to='/dashboard'&gt;&lt;/Redirect&gt;</span><br><span class="line">    <span class="keyword">const</span> login = (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;您没登录,请登录&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.props.login&#125;&gt;点我模拟登录&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 若登录了,则跳转到dashboard页面,若没登录,显示登录页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.isAuth ? redirect : login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> Auth = connect(</span><br><span class="line">  (state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isAuth:state.AuthReducer.isAuth,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;login&#125;</span><br><span class="line">)(Auth)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dashboard.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; from <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;login&#125; from <span class="string">'./Auth.redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Redirect&#125; from <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    const redirect = &lt;Redirect to='/dashboard'&gt;&lt;/Redirect&gt;</span><br><span class="line">    <span class="keyword">const</span> login = (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;您没登录,请登录&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.props.login&#125;&gt;点我模拟登录&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 若登录了,则跳转到dashboard页面,若没登录,显示登录页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.isAuth ? redirect : login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> Auth = connect(</span><br><span class="line">  (state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isAuth:state.AuthReducer.isAuth,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;login&#125;</span><br><span class="line">)(Auth)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; from <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;login&#125; from <span class="string">'./Auth.redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Redirect&#125; from <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    const redirect = &lt;Redirect to='/dashboard'&gt;&lt;/Redirect&gt;</span><br><span class="line">    <span class="keyword">const</span> login = (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;您没登录,请登录&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.props.login&#125;&gt;点我模拟登录&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 若登录了,则跳转到dashboard页面,若没登录,显示登录页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.isAuth ? redirect : login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> Auth = connect(</span><br><span class="line">  (state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isAuth:state.AuthReducer.isAuth,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;login&#125;</span><br><span class="line">)(Auth)</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://i.loli.net/2017/11/14/5a0a34278b587.png" alt="Jietu20171112-085631"></p><p><img src="https://i.loli.net/2017/11/14/5a0a343ce1d95.png" alt="Jietu20171112-085643"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BEFORE&quot;&gt;&lt;a href=&quot;#BEFORE&quot; class=&quot;headerlink&quot; title=&quot;BEFORE&quot;&gt;&lt;/a&gt;BEFORE&lt;/h2&gt;&lt;p&gt;在Redux学习的三篇学习笔记之后,加上React-Router 4的学习,模拟了一个注册登录+计数器的R
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 5: 使用axios 配合redux 实现 异步请求的Redux数据流</title>
    <link href="http://yoursite.com/2017/11/14/6-%E4%BD%BF%E7%94%A8axios%E9%85%8D%E5%90%88Redux%E5%AE%9E%E7%8E%B0%20%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E7%9A%84Redux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://yoursite.com/2017/11/14/6-使用axios配合Redux实现 异步请求后台数据的Redux数据流/</id>
    <published>2017-11-14T00:02:52.000Z</published>
    <updated>2017-12-20T03:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识-axios-API"><a href="#前置知识-axios-API" class="headerlink" title="前置知识 axios API"></a>前置知识 axios API</h2><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">axios API</a></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Express Server Code</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建express服务</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/data'</span>,(req,res) =&gt; &#123;</span><br><span class="line">  res.json(&#123;<span class="attr">hobby</span>:<span class="string">"basketball"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'chotee server'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="package-json-配置proxy字段-解决跨域问题"><a href="#package-json-配置proxy字段-解决跨域问题" class="headerlink" title="package.json 配置proxy字段,解决跨域问题"></a>package.json 配置proxy字段,解决跨域问题</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"proxy":"http://localhost:3001"</span><br></pre></td></tr></table></figure><h3 id="Auth-redux-js"><a href="#Auth-redux-js" class="headerlink" title="Auth.redux.js"></a>Auth.redux.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限登录的AuthReducer与action creater</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">const</span> LOGIN = <span class="string">'LOGIN'</span></span><br><span class="line"><span class="keyword">const</span> LOGOUT = <span class="string">'LOGOUT'</span></span><br><span class="line"><span class="keyword">const</span> GETUSERDATA = <span class="string">'GETUSERDATA'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//initState</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  name: <span class="string">'choteewang'</span>,</span><br><span class="line">  isAuth: <span class="literal">false</span>,</span><br><span class="line">  hobby: <span class="string">'football'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AuthReducer = <span class="function">(<span class="params">state = initState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOGIN:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> LOGOUT:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> GETUSERDATA:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">hobby</span>: action.payload &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//action creater</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增支持异步请求的action creater, 返回一个函数,函数参数是store.dispatch与store.getState</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUserData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在return出的函数内进行异步请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(<span class="string">'/data'</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="comment">// res是axios的响应数据,格式见下面图</span></span><br><span class="line">      <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">        dispatch(getuserdataAsync(res.data.hobby))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getuserdataAsync = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">type</span>: GETUSERDATA, <span class="attr">payload</span>: data&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGIN &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGOUT &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/11/14/5a0a3b5b0874e.png" alt="Jietu20171114-083933"></p><h3 id="Auth-js-对应路由-login"><a href="#Auth-js-对应路由-login" class="headerlink" title="Auth.js 对应路由/login"></a>Auth.js 对应路由/login</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; login, getUserData &#125; <span class="keyword">from</span> <span class="string">'./Auth.redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 组件mount完成后发起异步请求,这里的getUserData是经过react-thunk中间件处理的action creater</span></span><br><span class="line">    <span class="keyword">this</span>.props.getUserData()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> redirect = <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">'/dashboard'</span>&gt;</span><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br><span class="line">    <span class="keyword">const</span> login = (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="string">`我叫<span class="subst">$&#123;<span class="keyword">this</span>.props.name&#125;</span>,我的爱好是<span class="subst">$&#123;<span class="keyword">this</span>.props.hobby&#125;</span>`</span>&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h3&gt;您没登录,请登录&lt;/</span>h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.props.login&#125;&gt;点我模拟登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 若登录了,则跳转到dashboard页面,若没登录,显示登录页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.isAuth ? redirect : login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Auth = connect(</span><br><span class="line">  <span class="comment">//引入AuthReducer的字段给Auth的UI组件作为参数</span></span><br><span class="line">  (state) =&gt; state.AuthReducer,</span><br><span class="line">  <span class="comment">// 拿到getUserData的actionCreater</span></span><br><span class="line">  &#123; login, getUserData &#125;</span><br><span class="line">)(Auth)</span><br></pre></td></tr></table></figure><h3 id="config-js-设置全局拦截器"><a href="#config-js-设置全局拦截器" class="headerlink" title="config.js 设置全局拦截器"></a>config.js 设置全局拦截器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置全局拦截器的config.js,在根组件页面index.js页面引入</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">'antd-mobile'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  Toast.loading(<span class="string">'请求中'</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Toast.hide()</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://i.loli.net/2017/11/14/5a0a32dfd3da7.png" alt="Jietu20171112-111033"></p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/choteewang/BLOG-NOTE/tree/master/Demos/axios+redux_demo" target="_blank" rel="external">https://github.com/choteewang/BLOG-NOTE/tree/master/Demos/axios+redux_demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识-axios-API&quot;&gt;&lt;a href=&quot;#前置知识-axios-API&quot; class=&quot;headerlink&quot; title=&quot;前置知识 axios API&quot;&gt;&lt;/a&gt;前置知识 axios API&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.k
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 4 :关于combineReducers生成的数据结构</title>
    <link href="http://yoursite.com/2017/11/14/5-%E5%85%B3%E4%BA%8EcombineReducers%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/11/14/5-关于combineReducers生成的数据结构/</id>
    <published>2017-11-13T23:33:50.000Z</published>
    <updated>2017-12-20T03:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>reducer太多后,要将所有reducer合成为一个,使用combineReducers方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myReducer.js</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'increase'</span></span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'decrease'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state  = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrease'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: INCREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: DECREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncreaseAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(onIncrease())</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Auth.reducer.js</span></span><br><span class="line"><span class="comment">// 权限登录的reducer与action creater</span></span><br><span class="line"><span class="comment">// isAuth代表是否登录</span></span><br><span class="line"><span class="keyword">const</span> LOGIN = <span class="string">'LOGIN'</span></span><br><span class="line"><span class="keyword">const</span> LOGOUT = <span class="string">'LOGOUT'</span></span><br><span class="line"><span class="comment">//reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AuthReducer = <span class="function">(<span class="params">state = &#123; isAuth: <span class="literal">false</span>, user: <span class="string">'choteewang'</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOGIN:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> LOGOUT:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isAuth</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//action creater</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGIN &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> logout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: LOGOUT &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"><span class="comment">// 利用combineReducers合并两个Reducer</span></span><br><span class="line"><span class="comment">// 变为store中的state对象包裹2个reducer定义的state小对象的数据结构&#123;counter:&#123;&#125;,AutuReducer:&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 这里要注意改键名,防止之前使用小state的组件访问根组件state时key名发生错误</span></span><br><span class="line"><span class="comment">// 所以最佳实践是reducer要起名要有语义</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;<span class="attr">counter</span>:reducer, <span class="attr">AuthReducer</span>:AuthReducer&#125;)</span><br></pre></td></tr></table></figure><p><code>根组件挂载store后拿到的store.getState()</code> 可以清晰的看到数据结构<br><img src="https://i.loli.net/2017/11/14/5a0a2b3033179.png" alt="Jietu20171112-080243"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;reducer太多后,要将所有reducer合成为一个,使用combineReducers方法&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 3: react-redux继续改造Redux数据流</title>
    <link href="http://yoursite.com/2017/11/13/4-react-redux%E7%BB%A7%E7%BB%AD%E6%94%B9%E9%80%A0redux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://yoursite.com/2017/11/13/4-react-redux继续改造redux数据流/</id>
    <published>2017-11-13T14:23:52.000Z</published>
    <updated>2017-12-20T03:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p><h3 id="UI-组件"><a href="#UI-组件" class="headerlink" title="UI 组件"></a>UI 组件</h3><ul><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>没有状态（即不使用this.state这个变量）</li><li>所有数据都由参数（this.props）提供</li><li>不使用任何 Redux 的 API<h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3></li><li>负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>带有内部状态</li><li>使用 Redux 的 API</li></ul><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。<br>将组件拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。<br>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><p><code>下面是将已模块化拆分的,支持异步的redux数据流, 继续改造为react-redux的代码</code></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myRedux.js 代码保持不变</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'increase'</span></span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'decrease'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrease'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: INCREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: DECREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncreaseAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(onIncrease())</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js 根节点挂载处</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// applyMiddleware用来处理异步中间件thunk,compose用来将chrome插件与react-thunk按固定顺序连接起来</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore , applyMiddleware ,compose &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 为了在根组件页面定义store并传入,需要将reducer引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'./myRedux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//chrome插件redux-devtools github文档规定的插件声明方式</span></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,composeEnhancers(applyMiddleware(thunk)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除subcribe和listener,把ReactDOM.renden重写</span></span><br><span class="line"><span class="comment">//const unsubscribe = store.subscribe(listener)</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">//根组件外套一层Provider传入Store</span></span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js, UI组件定义处 与 包裹UI的容器组件生成处</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">// 引入react-redux的connect函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; from <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="comment">// 引入所有Action Creator</span></span><br><span class="line"><span class="keyword">import</span> &#123; onIncrease, onDecrease, onIncreaseAsync &#125; from <span class="string">'./myRedux'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//UI组件,只用来做数据展示和分发,将来可以抽离出去</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppUI</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"increase"</span> onClick=&#123;<span class="keyword">this</span>.props.onIncrease&#125; /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"decrease"</span> onClick=&#123;<span class="keyword">this</span>.props.onDecrease&#125; /&gt;</span><br><span class="line">        &#123;&lt;input type=<span class="string">"button"</span> value=<span class="string">"increaseAsync"</span> onClick=&#123;<span class="keyword">this</span>.props.onIncreaseAsync&#125; /&gt;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mapStateToProps是一个函数,返回一个对象,key对应UI组件上的参数名称,"值"应该是state或算出state的方法的调用</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mapDispatchToProps是一个对象,key对应UI组件对应的参数名称,"值"对应传入的actionCreater</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onIncrease, onDecrease, onIncreaseAsync</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用connect函数生成包裹UI组件的容器组件</span></span><br><span class="line"><span class="keyword">const</span> App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(AppUI)</span><br><span class="line">export <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/11/13/5a099fedeaa9e.png" alt="Jietu20171111-033033_iutjibikf"></p><h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="external">阮一峰 Redux 3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h2&gt;&lt;p&gt;React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 2: Redux模块的抽离,Action Creator,异步支持的实现(redux-thunk)</title>
    <link href="http://yoursite.com/2017/11/13/3-Redux-2-Redux%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8A%BD%E7%A6%BB-Action-Creator-%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%E7%9A%84%E5%AE%9E%E7%8E%B0-redux-thunk/"/>
    <id>http://yoursite.com/2017/11/13/3-Redux-2-Redux模块的抽离-Action-Creator-异步支持的实现-redux-thunk/</id>
    <published>2017-11-13T13:23:52.000Z</published>
    <updated>2017-12-20T03:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><a href="./redux的实现原理(发布订阅模式,闭包">上一篇redux的总结</a>.md)中,写了一个小的Counter Demo, 但是代码耦合度太高, 在复杂项目中组织代码难度增加, 且无法进行异步redux操作, 这篇总结中, 将代码以模块化思想解耦合, 并让redux可以支持异步操作.</p><p>需要用到redux-thunk这个库,这个库的作用是让store.dispatch接受以函数作为参数,从而从函数参数中拿到dispatch与getState执行异步操作, 最底层的原理可以移步阮一峰博客redux第二篇,这里只做代码实现,和详细注释</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index.js : 根组件挂载处</span></span><br><span class="line"><span class="keyword">import</span> App from <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM from <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 引入redux-thunk,使dispatch可以接受一个函数作为参数,从而支持applyMiddleware的中间件处理</span></span><br><span class="line"><span class="keyword">import</span> thunk from <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; from <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 引入自己抽离的actionCreater与reducer模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; onIncrease, onDecrease, onIncreaseAsync,reducer &#125; from <span class="string">'./myRedux'</span>;</span><br><span class="line"><span class="comment">// 在根组件的挂载处挂载store与reducer,actionCreater控制整个app的redux数据流</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer,applyMiddleware(thunk))</span><br><span class="line"><span class="keyword">const</span> unsubscribe = store.subscribe(listener)</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;App</span><br><span class="line">      <span class="comment">//将store和actionCreater传入组件内部</span></span><br><span class="line">      store=&#123;store&#125;</span><br><span class="line">      onIncrease=&#123;onIncrease&#125;</span><br><span class="line">      onDecrease=&#123;onDecrease&#125;</span><br><span class="line">      onIncreaseAsync=&#123;onIncreaseAsync&#125;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/App&gt;,</span><br><span class="line">    document.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br><span class="line">listener()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js : UI组件定义处</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">// App就是上篇文章的Counter,不同的是它是一个UI组件,只负责UI的展示和数据流的分派</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// store与ActionCreater从根组件挂载处index.js处拿到</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="keyword">this</span>.props.store</span><br><span class="line">    <span class="keyword">const</span> onIncrease = <span class="keyword">this</span>.props.onIncrease</span><br><span class="line">    <span class="keyword">const</span> onDecrease = <span class="keyword">this</span>.props.onDecrease</span><br><span class="line">    <span class="keyword">const</span> onIncreaseAsync = <span class="keyword">this</span>.props.onIncreaseAsync</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;store.getState()&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"increase"</span> onClick=&#123;() =&gt; &#123; store.dispatch(onIncrease()) &#125;&#125; /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"decrease"</span> onClick=&#123;() =&gt; &#123; store.dispatch(onDecrease()) &#125;&#125; /&gt;</span><br><span class="line">        &#123;<span class="comment">/* 添加异步操作UI */</span>&#125;</span><br><span class="line">        &#123;&lt;input type=<span class="string">"button"</span> value=<span class="string">"increaseAsync"</span> onClick=&#123;() =&gt; &#123; store.dispatch(onIncreaseAsync()) &#125;&#125; /&gt;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myRedux.js</span></span><br><span class="line"><span class="comment">// 将actionCreater与reducer抽离成一个单独的js模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义action.type对应的常量,防止后期频繁修改</span></span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'increase'</span></span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'decrease'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrease'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了不频繁写action,创建actionCreater方法,自动生成action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: INCREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onDecrease = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: DECREASE &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// redux异步的解决方案:写出返回函数的actionCreator，使用reduxThunk中间件改造dispatch使函数可以作为其参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异步的actionCreater,返回一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onIncreaseAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里return出的方法参数是dispatch与getState,后续applyMiddleWare方法会将store.dispatch与store.getState传入</span></span><br><span class="line">  <span class="comment">// 这里return出的方法是一个中间件方法,applyMiddleWare会在这个方法执行之前发一个action,执行之后再发一个action,从而实现异步处理.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(onIncrease())</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2017/11/13/5a099c902645b.png" alt="Jietu20171111-033033"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="external">阮一峰 redux(2)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;./redux的实现原理(发布订阅模式,闭包&quot;&gt;上一篇redux的总结&lt;/a&gt;.md)中,写了一个小的Co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 1: Redux的实现原理(发布订阅模式,闭包)</title>
    <link href="http://yoursite.com/2017/11/13/2-redux%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/11/13/2-redux的实现原理-发布订阅模式-闭包/</id>
    <published>2017-11-13T12:57:01.000Z</published>
    <updated>2017-12-20T03:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识-发布订阅者模式"><a href="#前置知识-发布订阅者模式" class="headerlink" title="前置知识:发布订阅者模式"></a>前置知识:发布订阅者模式</h2><p><a href="https://www.cnblogs.com/tugenhua0707/p/4687947.html" target="_blank" rel="external">发布订阅者模式_阅读</a></p><h2 id="createStore的实现-闭包-发布订阅模式"><a href="#createStore的实现-闭包-发布订阅模式" class="headerlink" title="createStore的实现,闭包,发布订阅模式"></a>createStore的实现,闭包,发布订阅模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 闭包内要操作的数据,state是数据,listeners是发布订阅模式的订阅数组</span></span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line">  <span class="comment">// 通过getState返回state的值</span></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过dispatch的参数接收action对象</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 将action对象传入reducer更新state</span></span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    <span class="comment">// 一旦state被更新,订阅数组中的所有listener方法被执行</span></span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过subscribe的参数接收listener方法</span></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 将listner方法放入订阅数组listeners</span></span><br><span class="line">    listeners.push(listener);</span><br><span class="line">    <span class="comment">// 同时return一个方法形成闭包,这个方法用来从订阅数组listeners中删除掉listener方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行一次dispatch,形成最初的state数据</span></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将getState, dispatch, subscribe方法向外return,形成闭包</span></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最基础的Redux数据流"><a href="#最基础的Redux数据流" class="headerlink" title="最基础的Redux数据流"></a>最基础的Redux数据流</h2><p><img src="https://i.loli.net/2017/11/13/5a099379e0660.png" alt="Jietu20171110-094632"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM from <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 从redux中拿到createStore函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; from <span class="string">"redux"</span>;</span><br><span class="line"><span class="comment">// ui组件,只有props从外界接收数据并展示,让redux帮我们处理state数据的传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Increase"</span> onClick=&#123;<span class="keyword">this</span>.props.onIncrease&#125; /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Decrease"</span> onClick=&#123;<span class="keyword">this</span>.props.onDecrease&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer,在createStore形成的闭包内部处理state的过滤器,</span></span><br><span class="line"><span class="comment">// 在createStore形成的闭包内部 使用state=reducer(state,action)实现,return的值重新赋值给state</span></span><br><span class="line"><span class="keyword">const</span> reducer = (state = <span class="number">0</span>, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrease'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store是createStore闭包的返回值,是一个对象,结构是&#123;getState,dispatch,subscribe&#125;,</span></span><br><span class="line"><span class="comment">// createStore通过参数传入的reducer形成state的生成规则</span></span><br><span class="line"><span class="comment">// createStore方法还可以接受第二个参数，表示整个应用的state的初始状态,会覆盖reducer函数中的默认初始值</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"><span class="comment">// 通过store.subscribe(listener)方法拿到的listener函数进行订阅发布者模式监听,只要state的值变化,订阅数组listenrs中的所有listener方法就会被执行</span></span><br><span class="line"><span class="keyword">const</span> unsubscribe = store.subscribe(listener)</span><br><span class="line"><span class="comment">// store.subscribe的返回值是一个方法unsubscribe(),可以从订阅数组listeners中移除listener方法,取消监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是subscribe调用的listener方法,state的值改变后会被调用,内部让其自动执行渲染函数更新UI组件Counter</span></span><br><span class="line"><span class="function">function <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      <span class="comment">// 新生成的state值可以通过store.getState()方法得到闭包快照</span></span><br><span class="line">      count=&#123;store.getState()&#125;</span><br><span class="line">      <span class="comment">// 通过store.dispatch(action)方法拿到action对象传入reducer参数更新state值,state=reducer(state,action)</span></span><br><span class="line">      <span class="comment">// action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置</span></span><br><span class="line">      onIncrease=&#123;() =&gt; &#123; store.dispatch(&#123; type: <span class="string">'increase'</span> &#125;) &#125;&#125;</span><br><span class="line">      onDecrease=&#123;() =&gt; &#123; store.dispatch(&#123; type: <span class="string">'decrease'</span> &#125;) &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/Counter&gt;,</span><br><span class="line">    document.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首次进入页面先渲染一次页面</span></span><br><span class="line">listener()</span><br></pre></td></tr></table></figure><p><img src="https://ooo.0o0.ooo/2017/11/13/5a0993bd51d99.png" alt="Jietu20171110-082736"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">阮一峰 redux (1)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识-发布订阅者模式&quot;&gt;&lt;a href=&quot;#前置知识-发布订阅者模式&quot; class=&quot;headerlink&quot; title=&quot;前置知识:发布订阅者模式&quot;&gt;&lt;/a&gt;前置知识:发布订阅者模式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gulp构建 es6运行在browser端 自动化工作流</title>
    <link href="http://yoursite.com/2017/11/10/1-gulp%E6%9E%84%E5%BB%BAes6%E8%BF%90%E8%A1%8C%E5%9C%A8browser%E7%AB%AF%E7%9A%84work%20flow/"/>
    <id>http://yoursite.com/2017/11/10/1-gulp构建es6运行在browser端的work flow/</id>
    <published>2017-11-10T14:23:52.000Z</published>
    <updated>2017-11-14T00:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用来做什么"><a href="#用来做什么" class="headerlink" title="用来做什么?"></a>用来做什么?</h3><p>1.支持监视前端页面js,css,ejs模板文件热更新,babel语法自动转换,自动刷新浏览器页面,</p><p>2.支持后台静态资源的处理,js文件的压缩打包,更新静态css与ejs模板文件,也可以在express端构建逻辑mock数据</p><hr><h3 id="项目自动化构建思路"><a href="#项目自动化构建思路" class="headerlink" title="项目自动化构建思路"></a>项目自动化构建思路</h3><p><img src="https://ooo.0o0.ooo/2017/11/14/5a0a30c88f806.png" alt="1"></p><h3 id="自动化构建逻辑"><a href="#自动化构建逻辑" class="headerlink" title="自动化构建逻辑"></a>自动化构建逻辑</h3><ol><li>若app文件夹(前端静. 态页面)资源发生改变 -&gt;</li><li>调用browser.js脚本 -&gt;</li><li>browser.js运行script脚本 -&gt;</li><li>将新的js文件打包后写入server目录public目录下 -&gt;</li><li>此行为触发server.js监听到服务端js静态资源文件被修改 -&gt;</li><li>执行服务器重启重新渲染页面 -&gt;</li><li>前台看到浏览器热更新<h3 id="构建目录结构-安装服务端脚手架工具"><a href="#构建目录结构-安装服务端脚手架工具" class="headerlink" title="构建目录结构,安装服务端脚手架工具"></a>构建目录结构,安装服务端脚手架工具</h3></li><li>创建项目目录 <code>app</code>(放置静态页面资源),<code>server</code>(用express脚手架初始化,将来放入热更新后的静态资源),<code>tasks</code>放置所有上述过程的脚本文件</li><li>初始化服务端express<pre><code>`npm install -g express-generator`  //安装express脚手架`express -e .` //使用express脚手架命令,初始化脚手架,-e代表使用ejs模板引擎</code></pre></li><li>在根目录创建 .babelrc文件,此为babel转码器</li><li>在根目录创建<code>gulpfile.js</code>, 若用es6语法写gulpfile文件就创建<code>gulpfile.babel.js</code></li></ol><hr><h2 id="gulp工作流代码构建流程"><a href="#gulp工作流代码构建流程" class="headerlink" title="gulp工作流代码构建流程"></a>gulp工作流代码构建流程</h2><h3 id="args-js-–处理命令行参数"><a href="#args-js-–处理命令行参数" class="headerlink" title="args.js –处理命令行参数"></a>args.js –处理命令行参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yargs <span class="keyword">from</span> <span class="string">'yargs'</span>; <span class="comment">//处理命令行参数的包</span></span><br><span class="line"><span class="comment">//区分开发环境和线上环境</span></span><br><span class="line"><span class="keyword">const</span> args = yargs  </span><br><span class="line">  <span class="comment">//提取--production参数</span></span><br><span class="line">  .option(<span class="string">'production'</span>,&#123; </span><br><span class="line">    boolean:<span class="literal">true</span>,<span class="comment">//选项是布尔类型</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="literal">false</span>,<span class="comment">//默认是false</span></span><br><span class="line">    describe:<span class="string">'min all scripts'</span> <span class="comment">//只是给人看的描述</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//用来监听文件改变的选项</span></span><br><span class="line">  .option(<span class="string">'watch'</span>,&#123;</span><br><span class="line">    boolean:<span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">default</span>:<span class="literal">false</span>,</span><br><span class="line">    describe:<span class="string">'watch all files'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//要不要输出命令行详细监视的日志</span></span><br><span class="line">  .option(<span class="string">'verbose'</span>,&#123;</span><br><span class="line">    boolean:<span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">default</span>:<span class="literal">false</span>,</span><br><span class="line">    describe:<span class="string">'log'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//强制生成sourcemaps映射</span></span><br><span class="line">  .option(<span class="string">'sourcemaps'</span>,&#123;</span><br><span class="line">    describe:<span class="string">'force the creation of sroucemaps'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//端口号</span></span><br><span class="line">  .option(<span class="string">'port'</span>,&#123;</span><br><span class="line">    string:<span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">default</span>:<span class="number">8080</span>,</span><br><span class="line">    describe:<span class="string">'server port'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//表示把输入的命令以字符串的方式进行解析</span></span><br><span class="line">  .argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> args;</span><br></pre></td></tr></table></figure><h3 id="script-js-–处理js"><a href="#script-js-–处理js" class="headerlink" title="script.js –处理js"></a>script.js –处理js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpif <span class="keyword">from</span> <span class="string">'gulp-if'</span>; <span class="comment">//gulp语句中做if判断</span></span><br><span class="line"><span class="keyword">import</span> concat <span class="keyword">from</span> <span class="string">'gulp-concat'</span>; <span class="comment">//gulp中处理文件拼接</span></span><br><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpWebpack <span class="keyword">from</span> <span class="string">'webpack-stream'</span>; <span class="comment">//支持webpack在gulp stream中的功能</span></span><br><span class="line"><span class="keyword">import</span> named <span class="keyword">from</span> <span class="string">'vinyl-named'</span>; <span class="comment">//保证webpack生成的文件名能够和原文件对上</span></span><br><span class="line"><span class="keyword">import</span> livereload <span class="keyword">from</span> <span class="string">'gulp-livereload'</span>; <span class="comment">//浏览器热更新</span></span><br><span class="line"><span class="keyword">import</span> plumber <span class="keyword">from</span> <span class="string">'gulp-plumber'</span>; <span class="comment">//处理文件信息流</span></span><br><span class="line"><span class="keyword">import</span> rename <span class="keyword">from</span> <span class="string">'gulp-rename'</span>; <span class="comment">//对文件重命名</span></span><br><span class="line"><span class="keyword">import</span> uglify <span class="keyword">from</span> <span class="string">'gulp-uglify'</span>; <span class="comment">//压缩js</span></span><br><span class="line"><span class="keyword">import</span> &#123;log, colors&#125; <span class="keyword">from</span> <span class="string">'gulp-util'</span>; <span class="comment">//命令行工具包,log与色彩输出</span></span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>; <span class="comment">//刚自己写的对命令行参数进行解析的包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了集中处理项目js文件抛出异常引起gulp流出现问题,需用plumber统一处理错误</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">'app/js/index.js'</span>])</span><br><span class="line">    .pipe(plumber(&#123;<span class="attr">errorHandle</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;&#125;))</span><br><span class="line">    .pipe(named())</span><br><span class="line">    .pipe(gulpWebpack(&#123;</span><br><span class="line">      <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;), <span class="literal">null</span>, (err, stats) =&gt; &#123;</span><br><span class="line">      log(<span class="string">`Finished '<span class="subst">$&#123;colors.cyan(<span class="string">'scripts'</span>)&#125;</span>'`</span>, stats.toString(&#123;<span class="attr">chunks</span>: <span class="literal">false</span>&#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//gulp处理完的js指定写入路径,api:gulp.dest</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'server/public/js'</span>))</span><br><span class="line">    <span class="comment">//js文件重命名为cp.min.js,还没压缩,只是复制一份</span></span><br><span class="line">    .pipe(rename(&#123;<span class="attr">basename</span>: <span class="string">'cp'</span>, <span class="attr">extname</span>: <span class="string">'.min.js'</span>&#125;))</span><br><span class="line">    <span class="comment">// 压缩</span></span><br><span class="line">    .pipe(uglify(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        properties: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        <span class="string">'quote_keys'</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">// 把压缩后的文件放入服务器目录</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'server/public/js'</span>))</span><br><span class="line">    <span class="comment">// 使用gulpif监视命令行传入的参数,若有--watch,则执行热更新</span></span><br><span class="line">    .pipe(gulpif(args.watch, livereload()))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="pages-js-–处理后台页面模板"><a href="#pages-js-–处理后台页面模板" class="headerlink" title="pages.js –处理后台页面模板"></a>pages.js –处理后台页面模板</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpif <span class="keyword">from</span> <span class="string">'gulp-if'</span>;</span><br><span class="line"><span class="keyword">import</span> livereload <span class="keyword">from</span> <span class="string">'gulp-livereload'</span>;</span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'pages'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'app/**/*.ejs'</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'server'</span>)) <span class="comment">//文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。这里实际写到的路径是server下的/**/*.ejs,即server/views/*.ejs</span></span><br><span class="line">    .pipe(gulpif(args.watch,livereload()))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="css-js-–处理css"><a href="#css-js-–处理css" class="headerlink" title="css.js –处理css"></a>css.js –处理css</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpif <span class="keyword">from</span> <span class="string">'gulp-if'</span>;</span><br><span class="line"><span class="keyword">import</span> livereload <span class="keyword">from</span> <span class="string">'gulp-livereload'</span>;</span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'css'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'app/**/*.css'</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'server/public'</span>))</span><br><span class="line">    <span class="comment">//文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。这里实际写到的路径是server下的/**/*.css,即server/public/css/*.css</span></span><br><span class="line">    .pipe(gulpif(args.watch,livereload()))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="server-js-–处理服务端热重启"><a href="#server-js-–处理服务端热重启" class="headerlink" title="server.js –处理服务端热重启"></a>server.js –处理服务端热重启</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpif <span class="keyword">from</span> <span class="string">'gulp-if'</span>;</span><br><span class="line"><span class="keyword">import</span> liveserver <span class="keyword">from</span> <span class="string">'gulp-live-server'</span>; <span class="comment">//启动gulp服务器的包</span></span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'serve'</span>,(cb)=&gt;&#123;</span><br><span class="line">  <span class="comment">//如果没在监听,直接运行回调函数</span></span><br><span class="line">  <span class="keyword">if</span>(!args.watch) <span class="keyword">return</span> cb(); </span><br><span class="line">  <span class="comment">//启动express脚手架默认的服务器脚本</span></span><br><span class="line">  <span class="keyword">const</span> server = liveserver.new([<span class="string">'--harmony'</span>,<span class="string">'server/bin/www'</span>]); </span><br><span class="line">  server.start();</span><br><span class="line">  <span class="comment">//监听server目录下的js文件和ejs模板文件,通知服务器哪些文件改变了</span></span><br><span class="line">  gulp.watch([<span class="string">'server/public/**/*.js'</span>,<span class="string">'server/views/**/*.ejs'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">    server.notify.apply(server,[file]);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//监视服务器路由及入口文件的改变,进行服务器重启</span></span><br><span class="line">  gulp.watch([<span class="string">'server/routes/**/*.js'</span>,<span class="string">'server/app.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    server.start.bind(server)()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="browser-js-–监视前端文件改变-触发热更新"><a href="#browser-js-–监视前端文件改变-触发热更新" class="headerlink" title="browser.js –监视前端文件改变,触发热更新"></a>browser.js –监视前端文件改变,触发热更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpif <span class="keyword">from</span> <span class="string">'gulp-if'</span>;</span><br><span class="line"><span class="keyword">import</span> gutil <span class="keyword">from</span> <span class="string">'gulp-util'</span>;</span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'browser'</span>,(cb)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(!args.watch) <span class="keyword">return</span> cb();<span class="comment">//若没监听,则直接执行回调</span></span><br><span class="line">  gulp.watch(<span class="string">'app/**/*.js'</span>,[<span class="string">'scripts'</span>]);<span class="comment">//若js文件发生改变,则调用刚才创建的scripts脚本</span></span><br><span class="line">  gulp.watch(<span class="string">'app/**/*.ejs'</span>,[<span class="string">'pages'</span>]); <span class="comment">//同上</span></span><br><span class="line">  gulp.watch(<span class="string">'app/**/*.css'</span>,[<span class="string">'css'</span>]); <span class="comment">//同上</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="clean-js-–处理服务器清除旧文件"><a href="#clean-js-–处理服务器清除旧文件" class="headerlink" title="clean.js –处理服务器清除旧文件"></a>clean.js –处理服务器清除旧文件</h3><p>每次服务器监听到静态资源文件的改变, 会触发重启, 用新的静态资源去render页面,此时需要删除旧的静态资源文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> del <span class="keyword">from</span> <span class="string">'del'</span>;</span><br><span class="line"><span class="keyword">import</span> args <span class="keyword">from</span> <span class="string">'./util/args'</span>;</span><br><span class="line"><span class="comment">//清除服务端的静态资源文件和模板文件</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'server/public'</span>,<span class="string">'server/views'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="build-js-–处理所有gulp文件运行关联顺序"><a href="#build-js-–处理所有gulp文件运行关联顺序" class="headerlink" title="build.js –处理所有gulp文件运行关联顺序"></a>build.js –处理所有gulp文件运行关联顺序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> gulpSequence <span class="keyword">from</span> <span class="string">'gulp-sequence'</span>; <span class="comment">//处理文件关联关系和先后顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先clean,再css,再pages,再编译js,最后一个数组说明数组里的任务都放在前面四个任务执行过一次之后再执行,且serve端更新一定 在 browser静态资源改变之后 </span></span><br><span class="line">gulp.task(<span class="string">'build'</span>,gulpSequence(<span class="string">'clean'</span>,<span class="string">'css'</span>,<span class="string">'pages'</span>,<span class="string">'scripts'</span>,[<span class="string">'browser'</span>,<span class="string">'serve'</span>]));</span><br></pre></td></tr></table></figure><h3 id="default-js-–gulp工作流默认入口"><a href="#default-js-–gulp工作流默认入口" class="headerlink" title="default.js –gulp工作流默认入口"></a>default.js –gulp工作流默认入口</h3><p>gulp在无命令行参数时会优先运行defalut.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'build'</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="gulpfile-babel-js-–gulp程序入口"><a href="#gulpfile-babel-js-–gulp程序入口" class="headerlink" title="gulpfile.babel.js –gulp程序入口"></a>gulpfile.babel.js –gulp程序入口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requireDir <span class="keyword">from</span> <span class="string">'require-dir'</span>;<span class="comment">//需要运行某一文件夹的gulp任务</span></span><br><span class="line">requireDir(<span class="string">'./tasks'</span>); <span class="comment">//放入tasks目录</span></span><br></pre></td></tr></table></figure><h3 id="编辑-babelrc"><a href="#编辑-babelrc" class="headerlink" title="编辑.babelrc"></a>编辑.babelrc</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>:[<span class="string">"env"</span>,<span class="string">"stage-0"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给express脚手架添加热更新中间件"><a href="#给express脚手架添加热更新中间件" class="headerlink" title="给express脚手架添加热更新中间件"></a>给express脚手架添加热更新中间件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在处理路由前,express优先处理静态资源,若在这个static方法定义的目录中没有找到req.url对应的静态资源,则调用Next()方法传入下一个中间件,最终会传递到路由中间件上</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"><span class="comment">//一定要再静态资源设置之后使用热更新中间件,此插件的安装要再最外层项目目录下的依赖安装,而不是server目录的依赖</span></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'connect-livereload'</span>)());</span><br></pre></td></tr></table></figure><h3 id="gulp程序启动"><a href="#gulp程序启动" class="headerlink" title="gulp程序启动"></a>gulp程序启动</h3><p><code>gulp --watch</code><br>在app/public/js下写一个简单的js,再在app/public/css下写一个chotee.css,例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chotee</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'chotee 啊,成功!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ct1 = <span class="keyword">new</span> Chotee</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = ct1.name;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app/views/目录下的index.ejs模板中引入<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/chotee.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hello chotee</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/index.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>打开浏览器访问localhost:3000端口(express脚手架默认端口), 看到<br><img src="https://i.loli.net/2017/11/14/5a0a30b96f6c1.png" alt="2"></p><p>成功! 此时再去修改js文件,模板文件,热更新文件,成功</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址:"></a>源码地址:</h2><p><a href="https://github.com/choteewang/gulp-es6-work-flow" target="_blank" rel="external">https://github.com/choteewang/gulp-es6-work-flow</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用来做什么&quot;&gt;&lt;a href=&quot;#用来做什么&quot; class=&quot;headerlink&quot; title=&quot;用来做什么?&quot;&gt;&lt;/a&gt;用来做什么?&lt;/h3&gt;&lt;p&gt;1.支持监视前端页面js,css,ejs模板文件热更新,babel语法自动转换,自动刷新浏览器页面,&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
